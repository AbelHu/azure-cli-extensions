# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
from typing import Any, Callable, Dict, Generic, List, Optional, TypeVar, Union
import warnings

from azure.core.exceptions import HttpResponseError, ResourceExistsError, ResourceNotFoundError, map_error
from azure.core.paging import ItemPaged
from azure.core.pipeline import PipelineResponse
from azure.core.pipeline.transport import HttpRequest, HttpResponse
from azure.mgmt.core.exceptions import ARMErrorFormat

from .. import models

T = TypeVar('T')
ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]

class LinkedServiceOperations(object):
    """LinkedServiceOperations operations.

    You should not instantiate this class directly. Instead, you should create a Client instance that
    instantiates it for you and attaches it as an attribute.

    :ivar models: Alias to model classes used in this operation group.
    :type models: ~azure.mgmt.datafactory.models
    :param client: Client for service requests.
    :param config: Configuration of service client.
    :param serializer: An object model serializer.
    :param deserializer: An object model deserializer.
    """

    models = models

    def __init__(self, client, config, serializer, deserializer):
        self._client = client
        self._serialize = serializer
        self._deserialize = deserializer
        self._config = config

    def list_by_factory(
        self,
        resource_group_name,  # type: str
        factory_name,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.LinkedServiceListResponse"
        """Lists linked services.

        :param resource_group_name: The resource group name.
        :type resource_group_name: str
        :param factory_name: The factory name.
        :type factory_name: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: LinkedServiceListResponse or the result of cls(response)
        :rtype: ~azure.mgmt.datafactory.models.LinkedServiceListResponse
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.LinkedServiceListResponse"]
        error_map = kwargs.pop('error_map', {404: ResourceNotFoundError, 409: ResourceExistsError})
        api_version = "2018-06-01"

        def prepare_request(next_link=None):
            if not next_link:
                # Construct URL
                url = self.list_by_factory.metadata['url']
                path_format_arguments = {
                    'subscriptionId': self._serialize.url("self._config.subscription_id", self._config.subscription_id, 'str'),
                    'resourceGroupName': self._serialize.url("resource_group_name", resource_group_name, 'str', max_length=90, min_length=1, pattern=r'^[-\w\._\(\)]+$'),
                    'factoryName': self._serialize.url("factory_name", factory_name, 'str', max_length=63, min_length=3, pattern=r'^[A-Za-z0-9]+(?:-[A-Za-z0-9]+)*$'),
                }
                url = self._client.format_url(url, **path_format_arguments)
            else:
                url = next_link

            # Construct parameters
            query_parameters = {}  # type: Dict[str, Any]
            query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = 'application/json'

            # Construct and send request
            request = self._client.get(url, query_parameters, header_parameters)
            return request

        def extract_data(pipeline_response):
            deserialized = self._deserialize('LinkedServiceListResponse', pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.next_link or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response

        return ItemPaged(
            get_next, extract_data
        )
    list_by_factory.metadata = {'url': '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataFactory/factories/{factoryName}/linkedservices'}

    def create_or_update(
        self,
        resource_group_name,  # type: str
        factory_name,  # type: str
        linked_service_name,  # type: str
        properties,  # type: "models.LinkedService"
        if_match=None,  # type: Optional[str]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.LinkedServiceResource"
        """Creates or updates a linked service.

        :param resource_group_name: The resource group name.
        :type resource_group_name: str
        :param factory_name: The factory name.
        :type factory_name: str
        :param linked_service_name: The linked service name.
        :type linked_service_name: str
        :param properties: Properties of linked service.
        :type properties: ~azure.mgmt.datafactory.models.LinkedService
        :param if_match: ETag of the linkedService entity.  Should only be specified for update, for
         which it should match existing entity or can be * for unconditional update.
        :type if_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: LinkedServiceResource or the result of cls(response)
        :rtype: ~azure.mgmt.datafactory.models.LinkedServiceResource
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.LinkedServiceResource"]
        error_map = kwargs.pop('error_map', {404: ResourceNotFoundError, 409: ResourceExistsError})

        _linked_service = models.LinkedServiceResource(properties=properties)
        api_version = "2018-06-01"
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.create_or_update.metadata['url']
        path_format_arguments = {
            'subscriptionId': self._serialize.url("self._config.subscription_id", self._config.subscription_id, 'str'),
            'resourceGroupName': self._serialize.url("resource_group_name", resource_group_name, 'str', max_length=90, min_length=1, pattern=r'^[-\w\._\(\)]+$'),
            'factoryName': self._serialize.url("factory_name", factory_name, 'str', max_length=63, min_length=3, pattern=r'^[A-Za-z0-9]+(?:-[A-Za-z0-9]+)*$'),
            'linkedServiceName': self._serialize.url("linked_service_name", linked_service_name, 'str', max_length=260, min_length=1, pattern=r'^[A-Za-z0-9_][^<>*#.%&:\\+?/]*$'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = 'application/json'

        # Construct and send request
        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_linked_service, 'LinkedServiceResource')
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = self._deserialize('LinkedServiceResource', pipeline_response)

        if cls:
          return cls(pipeline_response, deserialized, {})

        return deserialized
    create_or_update.metadata = {'url': '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataFactory/factories/{factoryName}/linkedservices/{linkedServiceName}'}

    def get(
        self,
        resource_group_name,  # type: str
        factory_name,  # type: str
        linked_service_name,  # type: str
        if_none_match=None,  # type: Optional[str]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.LinkedServiceResource"
        """Gets a linked service.

        :param resource_group_name: The resource group name.
        :type resource_group_name: str
        :param factory_name: The factory name.
        :type factory_name: str
        :param linked_service_name: The linked service name.
        :type linked_service_name: str
        :param if_none_match: ETag of the linked service entity. Should only be specified for get. If
         the ETag matches the existing entity tag, or if * was provided, then no content will be
         returned.
        :type if_none_match: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: LinkedServiceResource or the result of cls(response)
        :rtype: ~azure.mgmt.datafactory.models.LinkedServiceResource or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.LinkedServiceResource"]
        error_map = kwargs.pop('error_map', {404: ResourceNotFoundError, 409: ResourceExistsError})
        api_version = "2018-06-01"

        # Construct URL
        url = self.get.metadata['url']
        path_format_arguments = {
            'subscriptionId': self._serialize.url("self._config.subscription_id", self._config.subscription_id, 'str'),
            'resourceGroupName': self._serialize.url("resource_group_name", resource_group_name, 'str', max_length=90, min_length=1, pattern=r'^[-\w\._\(\)]+$'),
            'factoryName': self._serialize.url("factory_name", factory_name, 'str', max_length=63, min_length=3, pattern=r'^[A-Za-z0-9]+(?:-[A-Za-z0-9]+)*$'),
            'linkedServiceName': self._serialize.url("linked_service_name", linked_service_name, 'str', max_length=260, min_length=1, pattern=r'^[A-Za-z0-9_][^<>*#.%&:\\+?/]*$'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_none_match is not None:
            header_parameters['If-None-Match'] = self._serialize.header("if_none_match", if_none_match, 'str')
        header_parameters['Accept'] = 'application/json'

        # Construct and send request
        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 304]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('LinkedServiceResource', pipeline_response)

        if cls:
          return cls(pipeline_response, deserialized, {})

        return deserialized
    get.metadata = {'url': '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataFactory/factories/{factoryName}/linkedservices/{linkedServiceName}'}

    def delete(
        self,
        resource_group_name,  # type: str
        factory_name,  # type: str
        linked_service_name,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Deletes a linked service.

        :param resource_group_name: The resource group name.
        :type resource_group_name: str
        :param factory_name: The factory name.
        :type factory_name: str
        :param linked_service_name: The linked service name.
        :type linked_service_name: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = kwargs.pop('error_map', {404: ResourceNotFoundError, 409: ResourceExistsError})
        api_version = "2018-06-01"

        # Construct URL
        url = self.delete.metadata['url']
        path_format_arguments = {
            'subscriptionId': self._serialize.url("self._config.subscription_id", self._config.subscription_id, 'str'),
            'resourceGroupName': self._serialize.url("resource_group_name", resource_group_name, 'str', max_length=90, min_length=1, pattern=r'^[-\w\._\(\)]+$'),
            'factoryName': self._serialize.url("factory_name", factory_name, 'str', max_length=63, min_length=3, pattern=r'^[A-Za-z0-9]+(?:-[A-Za-z0-9]+)*$'),
            'linkedServiceName': self._serialize.url("linked_service_name", linked_service_name, 'str', max_length=260, min_length=1, pattern=r'^[A-Za-z0-9_][^<>*#.%&:\\+?/]*$'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]

        # Construct and send request
        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
          return cls(pipeline_response, None, {})

    delete.metadata = {'url': '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataFactory/factories/{factoryName}/linkedservices/{linkedServiceName}'}

    def create_or_update_amazonmws(
        self,
        resource_group_name,  # type: str
        factory_name,  # type: str
        linked_service_name,  # type: str
        amazonmws_type,  # type: str
        amazonmws_endpoint,  # type: object
        amazonmws_marketplace_id,  # type: object
        amazonmws_seller_id,  # type: object
        amazonmws_access_key_id,  # type: object
        if_match=None,  # type: Optional[str]
        amazonmws_connect_via=None,  # type: Optional["models.IntegrationRuntimeReference"]
        amazonmws_description=None,  # type: Optional[str]
        amazonmws_parameters=None,  # type: Optional[Dict[str, "ParameterSpecification"]]
        amazonmws_annotations=None,  # type: Optional[List[object]]
        amazonmws_mws_auth_token=None,  # type: Optional["models.SecretBase"]
        amazonmws_secret_key=None,  # type: Optional["models.SecretBase"]
        amazonmws_use_encrypted_endpoints=None,  # type: Optional[object]
        amazonmws_use_host_verification=None,  # type: Optional[object]
        amazonmws_use_peer_verification=None,  # type: Optional[object]
        amazonmws_encrypted_credential=None,  # type: Optional[object]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.LinkedServiceResource"
        """Creates or updates a linked service.

        :param resource_group_name: The resource group name.
        :type resource_group_name: str
        :param factory_name: The factory name.
        :type factory_name: str
        :param linked_service_name: The linked service name.
        :type linked_service_name: str
        :param amazonmws_type: Type of linked service.
        :type amazonmws_type: str
        :param amazonmws_endpoint: The endpoint of the Amazon MWS server, (i.e.
         mws.amazonservices.com).
        :type amazonmws_endpoint: object
        :param amazonmws_marketplace_id: The Amazon Marketplace ID you want to retrieve data from. To
         retrieve data from multiple Marketplace IDs, separate them with a comma (,). (i.e.
         A2EUQ1WTGCTBG2).
        :type amazonmws_marketplace_id: object
        :param amazonmws_seller_id: The Amazon seller ID.
        :type amazonmws_seller_id: object
        :param amazonmws_access_key_id: The access key id used to access data.
        :type amazonmws_access_key_id: object
        :param if_match: ETag of the linkedService entity.  Should only be specified for update, for
         which it should match existing entity or can be * for unconditional update.
        :type if_match: str
        :param amazonmws_connect_via: The integration runtime reference.
        :type amazonmws_connect_via: ~azure.mgmt.datafactory.models.IntegrationRuntimeReference
        :param amazonmws_description: Linked service description.
        :type amazonmws_description: str
        :param amazonmws_parameters: Parameters for linked service.
        :type amazonmws_parameters: dict[str, ~azure.mgmt.datafactory.models.ParameterSpecification]
        :param amazonmws_annotations: List of tags that can be used for describing the linked service.
        :type amazonmws_annotations: list[object]
        :param amazonmws_mws_auth_token: The Amazon MWS authentication token.
        :type amazonmws_mws_auth_token: ~azure.mgmt.datafactory.models.SecretBase
        :param amazonmws_secret_key: The secret key used to access data.
        :type amazonmws_secret_key: ~azure.mgmt.datafactory.models.SecretBase
        :param amazonmws_use_encrypted_endpoints: Specifies whether the data source endpoints are
         encrypted using HTTPS. The default value is true.
        :type amazonmws_use_encrypted_endpoints: object
        :param amazonmws_use_host_verification: Specifies whether to require the host name in the
         server's certificate to match the host name of the server when connecting over SSL. The default
         value is true.
        :type amazonmws_use_host_verification: object
        :param amazonmws_use_peer_verification: Specifies whether to verify the identity of the server
         when connecting over SSL. The default value is true.
        :type amazonmws_use_peer_verification: object
        :param amazonmws_encrypted_credential: The encrypted credential used for authentication.
         Credentials are encrypted using the integration runtime credential manager. Type: string (or
         Expression with resultType string).
        :type amazonmws_encrypted_credential: object
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: LinkedServiceResource or the result of cls(response)
        :rtype: ~azure.mgmt.datafactory.models.LinkedServiceResource
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.LinkedServiceResource"]
        error_map = kwargs.pop('error_map', {404: ResourceNotFoundError, 409: ResourceExistsError})

        _linked_service = models.LinkedServiceResource(properties=properties, type=amazonmws_type, connect_via=amazonmws_connect_via, description=amazonmws_description, parameters=amazonmws_parameters, annotations=amazonmws_annotations, endpoint=amazonmws_endpoint, marketplace_id=amazonmws_marketplace_id, seller_id=amazonmws_seller_id, mws_auth_token=amazonmws_mws_auth_token, access_key_id=amazonmws_access_key_id, secret_key=amazonmws_secret_key, use_encrypted_endpoints=amazonmws_use_encrypted_endpoints, use_host_verification=amazonmws_use_host_verification, use_peer_verification=amazonmws_use_peer_verification, encrypted_credential=amazonmws_encrypted_credential)
        api_version = "2018-06-01"
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.create_or_update_amazonmws.metadata['url']
        path_format_arguments = {
            'subscriptionId': self._serialize.url("self._config.subscription_id", self._config.subscription_id, 'str'),
            'resourceGroupName': self._serialize.url("resource_group_name", resource_group_name, 'str', max_length=90, min_length=1, pattern=r'^[-\w\._\(\)]+$'),
            'factoryName': self._serialize.url("factory_name", factory_name, 'str', max_length=63, min_length=3, pattern=r'^[A-Za-z0-9]+(?:-[A-Za-z0-9]+)*$'),
            'linkedServiceName': self._serialize.url("linked_service_name", linked_service_name, 'str', max_length=260, min_length=1, pattern=r'^[A-Za-z0-9_][^<>*#.%&:\\+?/]*$'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = 'application/json'

        # Construct and send request
        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_linked_service, 'LinkedServiceResource')
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = self._deserialize('LinkedServiceResource', pipeline_response)

        if cls:
          return cls(pipeline_response, deserialized, {})

        return deserialized
    create_or_update_amazonmws.metadata = {'url': '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataFactory/factories/{factoryName}/linkedservices/{linkedServiceName}'}

    def create_or_update_amazonredshift(
        self,
        resource_group_name,  # type: str
        factory_name,  # type: str
        linked_service_name,  # type: str
        amazonredshift_type,  # type: str
        amazonredshift_server,  # type: object
        amazonredshift_database,  # type: object
        if_match=None,  # type: Optional[str]
        amazonredshift_connect_via=None,  # type: Optional["models.IntegrationRuntimeReference"]
        amazonredshift_description=None,  # type: Optional[str]
        amazonredshift_parameters=None,  # type: Optional[Dict[str, "ParameterSpecification"]]
        amazonredshift_annotations=None,  # type: Optional[List[object]]
        amazonredshift_username=None,  # type: Optional[object]
        amazonredshift_password=None,  # type: Optional["models.SecretBase"]
        amazonredshift_port=None,  # type: Optional[object]
        amazonredshift_encrypted_credential=None,  # type: Optional[object]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.LinkedServiceResource"
        """Creates or updates a linked service.

        :param resource_group_name: The resource group name.
        :type resource_group_name: str
        :param factory_name: The factory name.
        :type factory_name: str
        :param linked_service_name: The linked service name.
        :type linked_service_name: str
        :param amazonredshift_type: Type of linked service.
        :type amazonredshift_type: str
        :param amazonredshift_server: The name of the Amazon Redshift server. Type: string (or
         Expression with resultType string).
        :type amazonredshift_server: object
        :param amazonredshift_database: The database name of the Amazon Redshift source. Type: string
         (or Expression with resultType string).
        :type amazonredshift_database: object
        :param if_match: ETag of the linkedService entity.  Should only be specified for update, for
         which it should match existing entity or can be * for unconditional update.
        :type if_match: str
        :param amazonredshift_connect_via: The integration runtime reference.
        :type amazonredshift_connect_via: ~azure.mgmt.datafactory.models.IntegrationRuntimeReference
        :param amazonredshift_description: Linked service description.
        :type amazonredshift_description: str
        :param amazonredshift_parameters: Parameters for linked service.
        :type amazonredshift_parameters: dict[str, ~azure.mgmt.datafactory.models.ParameterSpecification]
        :param amazonredshift_annotations: List of tags that can be used for describing the linked
         service.
        :type amazonredshift_annotations: list[object]
        :param amazonredshift_username: The username of the Amazon Redshift source. Type: string (or
         Expression with resultType string).
        :type amazonredshift_username: object
        :param amazonredshift_password: The password of the Amazon Redshift source.
        :type amazonredshift_password: ~azure.mgmt.datafactory.models.SecretBase
        :param amazonredshift_port: The TCP port number that the Amazon Redshift server uses to listen
         for client connections. The default value is 5439. Type: integer (or Expression with resultType
         integer).
        :type amazonredshift_port: object
        :param amazonredshift_encrypted_credential: The encrypted credential used for authentication.
         Credentials are encrypted using the integration runtime credential manager. Type: string (or
         Expression with resultType string).
        :type amazonredshift_encrypted_credential: object
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: LinkedServiceResource or the result of cls(response)
        :rtype: ~azure.mgmt.datafactory.models.LinkedServiceResource
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.LinkedServiceResource"]
        error_map = kwargs.pop('error_map', {404: ResourceNotFoundError, 409: ResourceExistsError})

        _linked_service = models.LinkedServiceResource(properties=properties, type=amazonredshift_type, connect_via=amazonredshift_connect_via, description=amazonredshift_description, parameters=amazonredshift_parameters, annotations=amazonredshift_annotations, server=amazonredshift_server, username=amazonredshift_username, password=amazonredshift_password, database=amazonredshift_database, port=amazonredshift_port, encrypted_credential=amazonredshift_encrypted_credential)
        api_version = "2018-06-01"
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.create_or_update_amazonredshift.metadata['url']
        path_format_arguments = {
            'subscriptionId': self._serialize.url("self._config.subscription_id", self._config.subscription_id, 'str'),
            'resourceGroupName': self._serialize.url("resource_group_name", resource_group_name, 'str', max_length=90, min_length=1, pattern=r'^[-\w\._\(\)]+$'),
            'factoryName': self._serialize.url("factory_name", factory_name, 'str', max_length=63, min_length=3, pattern=r'^[A-Za-z0-9]+(?:-[A-Za-z0-9]+)*$'),
            'linkedServiceName': self._serialize.url("linked_service_name", linked_service_name, 'str', max_length=260, min_length=1, pattern=r'^[A-Za-z0-9_][^<>*#.%&:\\+?/]*$'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = 'application/json'

        # Construct and send request
        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_linked_service, 'LinkedServiceResource')
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = self._deserialize('LinkedServiceResource', pipeline_response)

        if cls:
          return cls(pipeline_response, deserialized, {})

        return deserialized
    create_or_update_amazonredshift.metadata = {'url': '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataFactory/factories/{factoryName}/linkedservices/{linkedServiceName}'}

    def create_or_update_amazons3(
        self,
        resource_group_name,  # type: str
        factory_name,  # type: str
        linked_service_name,  # type: str
        amazons3_type,  # type: str
        if_match=None,  # type: Optional[str]
        amazons3_connect_via=None,  # type: Optional["models.IntegrationRuntimeReference"]
        amazons3_description=None,  # type: Optional[str]
        amazons3_parameters=None,  # type: Optional[Dict[str, "ParameterSpecification"]]
        amazons3_annotations=None,  # type: Optional[List[object]]
        amazons3_access_key_id=None,  # type: Optional[object]
        amazons3_secret_access_key=None,  # type: Optional["models.SecretBase"]
        amazons3_service_url=None,  # type: Optional[object]
        amazons3_encrypted_credential=None,  # type: Optional[object]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.LinkedServiceResource"
        """Creates or updates a linked service.

        :param resource_group_name: The resource group name.
        :type resource_group_name: str
        :param factory_name: The factory name.
        :type factory_name: str
        :param linked_service_name: The linked service name.
        :type linked_service_name: str
        :param amazons3_type: Type of linked service.
        :type amazons3_type: str
        :param if_match: ETag of the linkedService entity.  Should only be specified for update, for
         which it should match existing entity or can be * for unconditional update.
        :type if_match: str
        :param amazons3_connect_via: The integration runtime reference.
        :type amazons3_connect_via: ~azure.mgmt.datafactory.models.IntegrationRuntimeReference
        :param amazons3_description: Linked service description.
        :type amazons3_description: str
        :param amazons3_parameters: Parameters for linked service.
        :type amazons3_parameters: dict[str, ~azure.mgmt.datafactory.models.ParameterSpecification]
        :param amazons3_annotations: List of tags that can be used for describing the linked service.
        :type amazons3_annotations: list[object]
        :param amazons3_access_key_id: The access key identifier of the Amazon S3 Identity and Access
         Management (IAM) user. Type: string (or Expression with resultType string).
        :type amazons3_access_key_id: object
        :param amazons3_secret_access_key: The secret access key of the Amazon S3 Identity and Access
         Management (IAM) user.
        :type amazons3_secret_access_key: ~azure.mgmt.datafactory.models.SecretBase
        :param amazons3_service_url: This value specifies the endpoint to access with the S3 Connector.
         This is an optional property; change it only if you want to try a different service endpoint or
         want to switch between https and http. Type: string (or Expression with resultType string).
        :type amazons3_service_url: object
        :param amazons3_encrypted_credential: The encrypted credential used for authentication.
         Credentials are encrypted using the integration runtime credential manager. Type: string (or
         Expression with resultType string).
        :type amazons3_encrypted_credential: object
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: LinkedServiceResource or the result of cls(response)
        :rtype: ~azure.mgmt.datafactory.models.LinkedServiceResource
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.LinkedServiceResource"]
        error_map = kwargs.pop('error_map', {404: ResourceNotFoundError, 409: ResourceExistsError})

        _linked_service = models.LinkedServiceResource(properties=properties, type=amazons3_type, connect_via=amazons3_connect_via, description=amazons3_description, parameters=amazons3_parameters, annotations=amazons3_annotations, access_key_id=amazons3_access_key_id, secret_access_key=amazons3_secret_access_key, service_url=amazons3_service_url, encrypted_credential=amazons3_encrypted_credential)
        api_version = "2018-06-01"
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.create_or_update_amazons3.metadata['url']
        path_format_arguments = {
            'subscriptionId': self._serialize.url("self._config.subscription_id", self._config.subscription_id, 'str'),
            'resourceGroupName': self._serialize.url("resource_group_name", resource_group_name, 'str', max_length=90, min_length=1, pattern=r'^[-\w\._\(\)]+$'),
            'factoryName': self._serialize.url("factory_name", factory_name, 'str', max_length=63, min_length=3, pattern=r'^[A-Za-z0-9]+(?:-[A-Za-z0-9]+)*$'),
            'linkedServiceName': self._serialize.url("linked_service_name", linked_service_name, 'str', max_length=260, min_length=1, pattern=r'^[A-Za-z0-9_][^<>*#.%&:\\+?/]*$'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = 'application/json'

        # Construct and send request
        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_linked_service, 'LinkedServiceResource')
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = self._deserialize('LinkedServiceResource', pipeline_response)

        if cls:
          return cls(pipeline_response, deserialized, {})

        return deserialized
    create_or_update_amazons3.metadata = {'url': '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataFactory/factories/{factoryName}/linkedservices/{linkedServiceName}'}

    def create_or_update_azurebatch(
        self,
        resource_group_name,  # type: str
        factory_name,  # type: str
        linked_service_name,  # type: str
        azurebatch_type,  # type: str
        azurebatch_account_name,  # type: object
        azurebatch_batch_uri,  # type: object
        azurebatch_pool_name,  # type: object
        azurebatch_linked_service_name,  # type: "models.LinkedServiceReference"
        if_match=None,  # type: Optional[str]
        azurebatch_connect_via=None,  # type: Optional["models.IntegrationRuntimeReference"]
        azurebatch_description=None,  # type: Optional[str]
        azurebatch_parameters=None,  # type: Optional[Dict[str, "ParameterSpecification"]]
        azurebatch_annotations=None,  # type: Optional[List[object]]
        azurebatch_access_key=None,  # type: Optional["models.SecretBase"]
        azurebatch_encrypted_credential=None,  # type: Optional[object]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.LinkedServiceResource"
        """Creates or updates a linked service.

        :param resource_group_name: The resource group name.
        :type resource_group_name: str
        :param factory_name: The factory name.
        :type factory_name: str
        :param linked_service_name: The linked service name.
        :type linked_service_name: str
        :param azurebatch_type: Type of linked service.
        :type azurebatch_type: str
        :param azurebatch_account_name: The Azure Batch account name. Type: string (or Expression with
         resultType string).
        :type azurebatch_account_name: object
        :param azurebatch_batch_uri: The Azure Batch URI. Type: string (or Expression with resultType
         string).
        :type azurebatch_batch_uri: object
        :param azurebatch_pool_name: The Azure Batch pool name. Type: string (or Expression with
         resultType string).
        :type azurebatch_pool_name: object
        :param azurebatch_linked_service_name: The Azure Storage linked service reference.
        :type azurebatch_linked_service_name: ~azure.mgmt.datafactory.models.LinkedServiceReference
        :param if_match: ETag of the linkedService entity.  Should only be specified for update, for
         which it should match existing entity or can be * for unconditional update.
        :type if_match: str
        :param azurebatch_connect_via: The integration runtime reference.
        :type azurebatch_connect_via: ~azure.mgmt.datafactory.models.IntegrationRuntimeReference
        :param azurebatch_description: Linked service description.
        :type azurebatch_description: str
        :param azurebatch_parameters: Parameters for linked service.
        :type azurebatch_parameters: dict[str, ~azure.mgmt.datafactory.models.ParameterSpecification]
        :param azurebatch_annotations: List of tags that can be used for describing the linked service.
        :type azurebatch_annotations: list[object]
        :param azurebatch_access_key: The Azure Batch account access key.
        :type azurebatch_access_key: ~azure.mgmt.datafactory.models.SecretBase
        :param azurebatch_encrypted_credential: The encrypted credential used for authentication.
         Credentials are encrypted using the integration runtime credential manager. Type: string (or
         Expression with resultType string).
        :type azurebatch_encrypted_credential: object
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: LinkedServiceResource or the result of cls(response)
        :rtype: ~azure.mgmt.datafactory.models.LinkedServiceResource
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.LinkedServiceResource"]
        error_map = kwargs.pop('error_map', {404: ResourceNotFoundError, 409: ResourceExistsError})

        _linked_service = models.LinkedServiceResource(properties=properties, type=azurebatch_type, connect_via=azurebatch_connect_via, description=azurebatch_description, parameters=azurebatch_parameters, annotations=azurebatch_annotations, account_name=azurebatch_account_name, access_key=azurebatch_access_key, batch_uri=azurebatch_batch_uri, pool_name=azurebatch_pool_name, linked_service_name=azurebatch_linked_service_name, encrypted_credential=azurebatch_encrypted_credential)
        api_version = "2018-06-01"
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.create_or_update_azurebatch.metadata['url']
        path_format_arguments = {
            'subscriptionId': self._serialize.url("self._config.subscription_id", self._config.subscription_id, 'str'),
            'resourceGroupName': self._serialize.url("resource_group_name", resource_group_name, 'str', max_length=90, min_length=1, pattern=r'^[-\w\._\(\)]+$'),
            'factoryName': self._serialize.url("factory_name", factory_name, 'str', max_length=63, min_length=3, pattern=r'^[A-Za-z0-9]+(?:-[A-Za-z0-9]+)*$'),
            'linkedServiceName': self._serialize.url("linked_service_name", linked_service_name, 'str', max_length=260, min_length=1, pattern=r'^[A-Za-z0-9_][^<>*#.%&:\\+?/]*$'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = 'application/json'

        # Construct and send request
        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_linked_service, 'LinkedServiceResource')
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = self._deserialize('LinkedServiceResource', pipeline_response)

        if cls:
          return cls(pipeline_response, deserialized, {})

        return deserialized
    create_or_update_azurebatch.metadata = {'url': '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataFactory/factories/{factoryName}/linkedservices/{linkedServiceName}'}

    def create_or_update_azureblobfs(
        self,
        resource_group_name,  # type: str
        factory_name,  # type: str
        linked_service_name,  # type: str
        azureblobfs_type,  # type: str
        azureblobfs_url,  # type: object
        if_match=None,  # type: Optional[str]
        azureblobfs_connect_via=None,  # type: Optional["models.IntegrationRuntimeReference"]
        azureblobfs_description=None,  # type: Optional[str]
        azureblobfs_parameters=None,  # type: Optional[Dict[str, "ParameterSpecification"]]
        azureblobfs_annotations=None,  # type: Optional[List[object]]
        azureblobfs_account_key=None,  # type: Optional[object]
        azureblobfs_service_principal_id=None,  # type: Optional[object]
        azureblobfs_service_principal_key=None,  # type: Optional["models.SecretBase"]
        azureblobfs_tenant=None,  # type: Optional[object]
        azureblobfs_encrypted_credential=None,  # type: Optional[object]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.LinkedServiceResource"
        """Creates or updates a linked service.

        :param resource_group_name: The resource group name.
        :type resource_group_name: str
        :param factory_name: The factory name.
        :type factory_name: str
        :param linked_service_name: The linked service name.
        :type linked_service_name: str
        :param azureblobfs_type: Type of linked service.
        :type azureblobfs_type: str
        :param azureblobfs_url: Endpoint for the Azure Data Lake Storage Gen2 service. Type: string (or
         Expression with resultType string).
        :type azureblobfs_url: object
        :param if_match: ETag of the linkedService entity.  Should only be specified for update, for
         which it should match existing entity or can be * for unconditional update.
        :type if_match: str
        :param azureblobfs_connect_via: The integration runtime reference.
        :type azureblobfs_connect_via: ~azure.mgmt.datafactory.models.IntegrationRuntimeReference
        :param azureblobfs_description: Linked service description.
        :type azureblobfs_description: str
        :param azureblobfs_parameters: Parameters for linked service.
        :type azureblobfs_parameters: dict[str, ~azure.mgmt.datafactory.models.ParameterSpecification]
        :param azureblobfs_annotations: List of tags that can be used for describing the linked
         service.
        :type azureblobfs_annotations: list[object]
        :param azureblobfs_account_key: Account key for the Azure Data Lake Storage Gen2 service. Type:
         string (or Expression with resultType string).
        :type azureblobfs_account_key: object
        :param azureblobfs_service_principal_id: The ID of the application used to authenticate against
         the Azure Data Lake Storage Gen2 account. Type: string (or Expression with resultType string).
        :type azureblobfs_service_principal_id: object
        :param azureblobfs_service_principal_key: The Key of the application used to authenticate
         against the Azure Data Lake Storage Gen2 account.
        :type azureblobfs_service_principal_key: ~azure.mgmt.datafactory.models.SecretBase
        :param azureblobfs_tenant: The name or ID of the tenant to which the service principal belongs.
         Type: string (or Expression with resultType string).
        :type azureblobfs_tenant: object
        :param azureblobfs_encrypted_credential: The encrypted credential used for authentication.
         Credentials are encrypted using the integration runtime credential manager. Type: string (or
         Expression with resultType string).
        :type azureblobfs_encrypted_credential: object
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: LinkedServiceResource or the result of cls(response)
        :rtype: ~azure.mgmt.datafactory.models.LinkedServiceResource
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.LinkedServiceResource"]
        error_map = kwargs.pop('error_map', {404: ResourceNotFoundError, 409: ResourceExistsError})

        _linked_service = models.LinkedServiceResource(properties=properties, type=azureblobfs_type, connect_via=azureblobfs_connect_via, description=azureblobfs_description, parameters=azureblobfs_parameters, annotations=azureblobfs_annotations, url=azureblobfs_url, account_key=azureblobfs_account_key, service_principal_id=azureblobfs_service_principal_id, service_principal_key=azureblobfs_service_principal_key, tenant=azureblobfs_tenant, encrypted_credential=azureblobfs_encrypted_credential)
        api_version = "2018-06-01"
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.create_or_update_azureblobfs.metadata['url']
        path_format_arguments = {
            'subscriptionId': self._serialize.url("self._config.subscription_id", self._config.subscription_id, 'str'),
            'resourceGroupName': self._serialize.url("resource_group_name", resource_group_name, 'str', max_length=90, min_length=1, pattern=r'^[-\w\._\(\)]+$'),
            'factoryName': self._serialize.url("factory_name", factory_name, 'str', max_length=63, min_length=3, pattern=r'^[A-Za-z0-9]+(?:-[A-Za-z0-9]+)*$'),
            'linkedServiceName': self._serialize.url("linked_service_name", linked_service_name, 'str', max_length=260, min_length=1, pattern=r'^[A-Za-z0-9_][^<>*#.%&:\\+?/]*$'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = 'application/json'

        # Construct and send request
        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_linked_service, 'LinkedServiceResource')
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = self._deserialize('LinkedServiceResource', pipeline_response)

        if cls:
          return cls(pipeline_response, deserialized, {})

        return deserialized
    create_or_update_azureblobfs.metadata = {'url': '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataFactory/factories/{factoryName}/linkedservices/{linkedServiceName}'}

    def create_or_update_azureblobstorage(
        self,
        resource_group_name,  # type: str
        factory_name,  # type: str
        linked_service_name,  # type: str
        azureblobstorage_type,  # type: str
        if_match=None,  # type: Optional[str]
        azureblobstorage_connect_via=None,  # type: Optional["models.IntegrationRuntimeReference"]
        azureblobstorage_description=None,  # type: Optional[str]
        azureblobstorage_parameters=None,  # type: Optional[Dict[str, "ParameterSpecification"]]
        azureblobstorage_annotations=None,  # type: Optional[List[object]]
        azureblobstorage_connection_string=None,  # type: Optional[object]
        azureblobstorage_account_key=None,  # type: Optional["models.AzureKeyVaultSecretReference"]
        azureblobstorage_sas_uri=None,  # type: Optional[object]
        azureblobstorage_sas_token=None,  # type: Optional["models.AzureKeyVaultSecretReference"]
        azureblobstorage_service_endpoint=None,  # type: Optional[str]
        azureblobstorage_service_principal_id=None,  # type: Optional[object]
        azureblobstorage_service_principal_key=None,  # type: Optional["models.SecretBase"]
        azureblobstorage_tenant=None,  # type: Optional[object]
        azureblobstorage_encrypted_credential=None,  # type: Optional[str]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.LinkedServiceResource"
        """Creates or updates a linked service.

        :param resource_group_name: The resource group name.
        :type resource_group_name: str
        :param factory_name: The factory name.
        :type factory_name: str
        :param linked_service_name: The linked service name.
        :type linked_service_name: str
        :param azureblobstorage_type: Type of linked service.
        :type azureblobstorage_type: str
        :param if_match: ETag of the linkedService entity.  Should only be specified for update, for
         which it should match existing entity or can be * for unconditional update.
        :type if_match: str
        :param azureblobstorage_connect_via: The integration runtime reference.
        :type azureblobstorage_connect_via: ~azure.mgmt.datafactory.models.IntegrationRuntimeReference
        :param azureblobstorage_description: Linked service description.
        :type azureblobstorage_description: str
        :param azureblobstorage_parameters: Parameters for linked service.
        :type azureblobstorage_parameters: dict[str, ~azure.mgmt.datafactory.models.ParameterSpecification]
        :param azureblobstorage_annotations: List of tags that can be used for describing the linked
         service.
        :type azureblobstorage_annotations: list[object]
        :param azureblobstorage_connection_string: The connection string. It is mutually exclusive with
         sasUri, serviceEndpoint property. Type: string, SecureString or AzureKeyVaultSecretReference.
        :type azureblobstorage_connection_string: object
        :param azureblobstorage_account_key: The Azure key vault secret reference of accountKey in
         connection string.
        :type azureblobstorage_account_key: ~azure.mgmt.datafactory.models.AzureKeyVaultSecretReference
        :param azureblobstorage_sas_uri: SAS URI of the Azure Blob Storage resource. It is mutually
         exclusive with connectionString, serviceEndpoint property. Type: string, SecureString or
         AzureKeyVaultSecretReference.
        :type azureblobstorage_sas_uri: object
        :param azureblobstorage_sas_token: The Azure key vault secret reference of sasToken in sas uri.
        :type azureblobstorage_sas_token: ~azure.mgmt.datafactory.models.AzureKeyVaultSecretReference
        :param azureblobstorage_service_endpoint: Blob service endpoint of the Azure Blob Storage
         resource. It is mutually exclusive with connectionString, sasUri property.
        :type azureblobstorage_service_endpoint: str
        :param azureblobstorage_service_principal_id: The ID of the service principal used to
         authenticate against Azure SQL Data Warehouse. Type: string (or Expression with resultType
         string).
        :type azureblobstorage_service_principal_id: object
        :param azureblobstorage_service_principal_key: The key of the service principal used to
         authenticate against Azure SQL Data Warehouse.
        :type azureblobstorage_service_principal_key: ~azure.mgmt.datafactory.models.SecretBase
        :param azureblobstorage_tenant: The name or ID of the tenant to which the service principal
         belongs. Type: string (or Expression with resultType string).
        :type azureblobstorage_tenant: object
        :param azureblobstorage_encrypted_credential: The encrypted credential used for authentication.
         Credentials are encrypted using the integration runtime credential manager. Type: string (or
         Expression with resultType string).
        :type azureblobstorage_encrypted_credential: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: LinkedServiceResource or the result of cls(response)
        :rtype: ~azure.mgmt.datafactory.models.LinkedServiceResource
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.LinkedServiceResource"]
        error_map = kwargs.pop('error_map', {404: ResourceNotFoundError, 409: ResourceExistsError})

        _linked_service = models.LinkedServiceResource(properties=properties, type=azureblobstorage_type, connect_via=azureblobstorage_connect_via, description=azureblobstorage_description, parameters=azureblobstorage_parameters, annotations=azureblobstorage_annotations, connection_string=azureblobstorage_connection_string, account_key=azureblobstorage_account_key, sas_uri=azureblobstorage_sas_uri, sas_token=azureblobstorage_sas_token, service_endpoint=azureblobstorage_service_endpoint, service_principal_id=azureblobstorage_service_principal_id, service_principal_key=azureblobstorage_service_principal_key, tenant=azureblobstorage_tenant, encrypted_credential=azureblobstorage_encrypted_credential)
        api_version = "2018-06-01"
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.create_or_update_azureblobstorage.metadata['url']
        path_format_arguments = {
            'subscriptionId': self._serialize.url("self._config.subscription_id", self._config.subscription_id, 'str'),
            'resourceGroupName': self._serialize.url("resource_group_name", resource_group_name, 'str', max_length=90, min_length=1, pattern=r'^[-\w\._\(\)]+$'),
            'factoryName': self._serialize.url("factory_name", factory_name, 'str', max_length=63, min_length=3, pattern=r'^[A-Za-z0-9]+(?:-[A-Za-z0-9]+)*$'),
            'linkedServiceName': self._serialize.url("linked_service_name", linked_service_name, 'str', max_length=260, min_length=1, pattern=r'^[A-Za-z0-9_][^<>*#.%&:\\+?/]*$'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = 'application/json'

        # Construct and send request
        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_linked_service, 'LinkedServiceResource')
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = self._deserialize('LinkedServiceResource', pipeline_response)

        if cls:
          return cls(pipeline_response, deserialized, {})

        return deserialized
    create_or_update_azureblobstorage.metadata = {'url': '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataFactory/factories/{factoryName}/linkedservices/{linkedServiceName}'}

    def create_or_update_azuredataexplorer(
        self,
        resource_group_name,  # type: str
        factory_name,  # type: str
        linked_service_name,  # type: str
        azuredataexplorer_type,  # type: str
        azuredataexplorer_endpoint,  # type: object
        azuredataexplorer_service_principal_id,  # type: object
        azuredataexplorer_service_principal_key,  # type: "models.SecretBase"
        azuredataexplorer_database,  # type: object
        azuredataexplorer_tenant,  # type: object
        if_match=None,  # type: Optional[str]
        azuredataexplorer_connect_via=None,  # type: Optional["models.IntegrationRuntimeReference"]
        azuredataexplorer_description=None,  # type: Optional[str]
        azuredataexplorer_parameters=None,  # type: Optional[Dict[str, "ParameterSpecification"]]
        azuredataexplorer_annotations=None,  # type: Optional[List[object]]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.LinkedServiceResource"
        """Creates or updates a linked service.

        :param resource_group_name: The resource group name.
        :type resource_group_name: str
        :param factory_name: The factory name.
        :type factory_name: str
        :param linked_service_name: The linked service name.
        :type linked_service_name: str
        :param azuredataexplorer_type: Type of linked service.
        :type azuredataexplorer_type: str
        :param azuredataexplorer_endpoint: The endpoint of Azure Data Explorer (the engine's endpoint).
         URL will be in the format https://:code:`<clusterName>`.:code:`<regionName>`.kusto.windows.net.
         Type: string (or Expression with resultType string).
        :type azuredataexplorer_endpoint: object
        :param azuredataexplorer_service_principal_id: The ID of the service principal used to
         authenticate against Azure Data Explorer. Type: string (or Expression with resultType string).
        :type azuredataexplorer_service_principal_id: object
        :param azuredataexplorer_service_principal_key: The key of the service principal used to
         authenticate against Kusto.
        :type azuredataexplorer_service_principal_key: ~azure.mgmt.datafactory.models.SecretBase
        :param azuredataexplorer_database: Database name for connection. Type: string (or Expression
         with resultType string).
        :type azuredataexplorer_database: object
        :param azuredataexplorer_tenant: The name or ID of the tenant to which the service principal
         belongs. Type: string (or Expression with resultType string).
        :type azuredataexplorer_tenant: object
        :param if_match: ETag of the linkedService entity.  Should only be specified for update, for
         which it should match existing entity or can be * for unconditional update.
        :type if_match: str
        :param azuredataexplorer_connect_via: The integration runtime reference.
        :type azuredataexplorer_connect_via: ~azure.mgmt.datafactory.models.IntegrationRuntimeReference
        :param azuredataexplorer_description: Linked service description.
        :type azuredataexplorer_description: str
        :param azuredataexplorer_parameters: Parameters for linked service.
        :type azuredataexplorer_parameters: dict[str, ~azure.mgmt.datafactory.models.ParameterSpecification]
        :param azuredataexplorer_annotations: List of tags that can be used for describing the linked
         service.
        :type azuredataexplorer_annotations: list[object]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: LinkedServiceResource or the result of cls(response)
        :rtype: ~azure.mgmt.datafactory.models.LinkedServiceResource
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.LinkedServiceResource"]
        error_map = kwargs.pop('error_map', {404: ResourceNotFoundError, 409: ResourceExistsError})

        _linked_service = models.LinkedServiceResource(properties=properties, type=azuredataexplorer_type, connect_via=azuredataexplorer_connect_via, description=azuredataexplorer_description, parameters=azuredataexplorer_parameters, annotations=azuredataexplorer_annotations, endpoint=azuredataexplorer_endpoint, service_principal_id=azuredataexplorer_service_principal_id, service_principal_key=azuredataexplorer_service_principal_key, database=azuredataexplorer_database, tenant=azuredataexplorer_tenant)
        api_version = "2018-06-01"
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.create_or_update_azuredataexplorer.metadata['url']
        path_format_arguments = {
            'subscriptionId': self._serialize.url("self._config.subscription_id", self._config.subscription_id, 'str'),
            'resourceGroupName': self._serialize.url("resource_group_name", resource_group_name, 'str', max_length=90, min_length=1, pattern=r'^[-\w\._\(\)]+$'),
            'factoryName': self._serialize.url("factory_name", factory_name, 'str', max_length=63, min_length=3, pattern=r'^[A-Za-z0-9]+(?:-[A-Za-z0-9]+)*$'),
            'linkedServiceName': self._serialize.url("linked_service_name", linked_service_name, 'str', max_length=260, min_length=1, pattern=r'^[A-Za-z0-9_][^<>*#.%&:\\+?/]*$'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = 'application/json'

        # Construct and send request
        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_linked_service, 'LinkedServiceResource')
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = self._deserialize('LinkedServiceResource', pipeline_response)

        if cls:
          return cls(pipeline_response, deserialized, {})

        return deserialized
    create_or_update_azuredataexplorer.metadata = {'url': '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataFactory/factories/{factoryName}/linkedservices/{linkedServiceName}'}

    def create_or_update_azuredatalakeanalytics(
        self,
        resource_group_name,  # type: str
        factory_name,  # type: str
        linked_service_name,  # type: str
        azuredatalakeanalytics_type,  # type: str
        azuredatalakeanalytics_account_name,  # type: object
        azuredatalakeanalytics_tenant,  # type: object
        if_match=None,  # type: Optional[str]
        azuredatalakeanalytics_connect_via=None,  # type: Optional["models.IntegrationRuntimeReference"]
        azuredatalakeanalytics_description=None,  # type: Optional[str]
        azuredatalakeanalytics_parameters=None,  # type: Optional[Dict[str, "ParameterSpecification"]]
        azuredatalakeanalytics_annotations=None,  # type: Optional[List[object]]
        azuredatalakeanalytics_service_principal_id=None,  # type: Optional[object]
        azuredatalakeanalytics_service_principal_key=None,  # type: Optional["models.SecretBase"]
        azuredatalakeanalytics_subscription_id=None,  # type: Optional[object]
        azuredatalakeanalytics_resource_group_name=None,  # type: Optional[object]
        azuredatalakeanalytics_data_lake_analytics_uri=None,  # type: Optional[object]
        azuredatalakeanalytics_encrypted_credential=None,  # type: Optional[object]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.LinkedServiceResource"
        """Creates or updates a linked service.

        :param resource_group_name: The resource group name.
        :type resource_group_name: str
        :param factory_name: The factory name.
        :type factory_name: str
        :param linked_service_name: The linked service name.
        :type linked_service_name: str
        :param azuredatalakeanalytics_type: Type of linked service.
        :type azuredatalakeanalytics_type: str
        :param azuredatalakeanalytics_account_name: The Azure Data Lake Analytics account name. Type:
         string (or Expression with resultType string).
        :type azuredatalakeanalytics_account_name: object
        :param azuredatalakeanalytics_tenant: The name or ID of the tenant to which the service
         principal belongs. Type: string (or Expression with resultType string).
        :type azuredatalakeanalytics_tenant: object
        :param if_match: ETag of the linkedService entity.  Should only be specified for update, for
         which it should match existing entity or can be * for unconditional update.
        :type if_match: str
        :param azuredatalakeanalytics_connect_via: The integration runtime reference.
        :type azuredatalakeanalytics_connect_via: ~azure.mgmt.datafactory.models.IntegrationRuntimeReference
        :param azuredatalakeanalytics_description: Linked service description.
        :type azuredatalakeanalytics_description: str
        :param azuredatalakeanalytics_parameters: Parameters for linked service.
        :type azuredatalakeanalytics_parameters: dict[str, ~azure.mgmt.datafactory.models.ParameterSpecification]
        :param azuredatalakeanalytics_annotations: List of tags that can be used for describing the
         linked service.
        :type azuredatalakeanalytics_annotations: list[object]
        :param azuredatalakeanalytics_service_principal_id: The ID of the application used to
         authenticate against the Azure Data Lake Analytics account. Type: string (or Expression with
         resultType string).
        :type azuredatalakeanalytics_service_principal_id: object
        :param azuredatalakeanalytics_service_principal_key: The Key of the application used to
         authenticate against the Azure Data Lake Analytics account.
        :type azuredatalakeanalytics_service_principal_key: ~azure.mgmt.datafactory.models.SecretBase
        :param azuredatalakeanalytics_subscription_id: Data Lake Analytics account subscription ID (if
         different from Data Factory account). Type: string (or Expression with resultType string).
        :type azuredatalakeanalytics_subscription_id: object
        :param azuredatalakeanalytics_resource_group_name: Data Lake Analytics account resource group
         name (if different from Data Factory account). Type: string (or Expression with resultType
         string).
        :type azuredatalakeanalytics_resource_group_name: object
        :param azuredatalakeanalytics_data_lake_analytics_uri: Azure Data Lake Analytics URI Type:
         string (or Expression with resultType string).
        :type azuredatalakeanalytics_data_lake_analytics_uri: object
        :param azuredatalakeanalytics_encrypted_credential: The encrypted credential used for
         authentication. Credentials are encrypted using the integration runtime credential manager.
         Type: string (or Expression with resultType string).
        :type azuredatalakeanalytics_encrypted_credential: object
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: LinkedServiceResource or the result of cls(response)
        :rtype: ~azure.mgmt.datafactory.models.LinkedServiceResource
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.LinkedServiceResource"]
        error_map = kwargs.pop('error_map', {404: ResourceNotFoundError, 409: ResourceExistsError})

        _linked_service = models.LinkedServiceResource(properties=properties, type=azuredatalakeanalytics_type, connect_via=azuredatalakeanalytics_connect_via, description=azuredatalakeanalytics_description, parameters=azuredatalakeanalytics_parameters, annotations=azuredatalakeanalytics_annotations, account_name=azuredatalakeanalytics_account_name, service_principal_id=azuredatalakeanalytics_service_principal_id, service_principal_key=azuredatalakeanalytics_service_principal_key, tenant=azuredatalakeanalytics_tenant, subscription_id=azuredatalakeanalytics_subscription_id, resource_group_name=azuredatalakeanalytics_resource_group_name, data_lake_analytics_uri=azuredatalakeanalytics_data_lake_analytics_uri, encrypted_credential=azuredatalakeanalytics_encrypted_credential)
        api_version = "2018-06-01"
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.create_or_update_azuredatalakeanalytics.metadata['url']
        path_format_arguments = {
            'subscriptionId': self._serialize.url("self._config.subscription_id", self._config.subscription_id, 'str'),
            'resourceGroupName': self._serialize.url("resource_group_name", resource_group_name, 'str', max_length=90, min_length=1, pattern=r'^[-\w\._\(\)]+$'),
            'factoryName': self._serialize.url("factory_name", factory_name, 'str', max_length=63, min_length=3, pattern=r'^[A-Za-z0-9]+(?:-[A-Za-z0-9]+)*$'),
            'linkedServiceName': self._serialize.url("linked_service_name", linked_service_name, 'str', max_length=260, min_length=1, pattern=r'^[A-Za-z0-9_][^<>*#.%&:\\+?/]*$'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = 'application/json'

        # Construct and send request
        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_linked_service, 'LinkedServiceResource')
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = self._deserialize('LinkedServiceResource', pipeline_response)

        if cls:
          return cls(pipeline_response, deserialized, {})

        return deserialized
    create_or_update_azuredatalakeanalytics.metadata = {'url': '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataFactory/factories/{factoryName}/linkedservices/{linkedServiceName}'}

    def create_or_update_azuredatalakestore(
        self,
        resource_group_name,  # type: str
        factory_name,  # type: str
        linked_service_name,  # type: str
        azuredatalakestore_type,  # type: str
        azuredatalakestore_data_lake_store_uri,  # type: object
        if_match=None,  # type: Optional[str]
        azuredatalakestore_connect_via=None,  # type: Optional["models.IntegrationRuntimeReference"]
        azuredatalakestore_description=None,  # type: Optional[str]
        azuredatalakestore_parameters=None,  # type: Optional[Dict[str, "ParameterSpecification"]]
        azuredatalakestore_annotations=None,  # type: Optional[List[object]]
        azuredatalakestore_service_principal_id=None,  # type: Optional[object]
        azuredatalakestore_service_principal_key=None,  # type: Optional["models.SecretBase"]
        azuredatalakestore_tenant=None,  # type: Optional[object]
        azuredatalakestore_account_name=None,  # type: Optional[object]
        azuredatalakestore_subscription_id=None,  # type: Optional[object]
        azuredatalakestore_resource_group_name=None,  # type: Optional[object]
        azuredatalakestore_encrypted_credential=None,  # type: Optional[object]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.LinkedServiceResource"
        """Creates or updates a linked service.

        :param resource_group_name: The resource group name.
        :type resource_group_name: str
        :param factory_name: The factory name.
        :type factory_name: str
        :param linked_service_name: The linked service name.
        :type linked_service_name: str
        :param azuredatalakestore_type: Type of linked service.
        :type azuredatalakestore_type: str
        :param azuredatalakestore_data_lake_store_uri: Data Lake Store service URI. Type: string (or
         Expression with resultType string).
        :type azuredatalakestore_data_lake_store_uri: object
        :param if_match: ETag of the linkedService entity.  Should only be specified for update, for
         which it should match existing entity or can be * for unconditional update.
        :type if_match: str
        :param azuredatalakestore_connect_via: The integration runtime reference.
        :type azuredatalakestore_connect_via: ~azure.mgmt.datafactory.models.IntegrationRuntimeReference
        :param azuredatalakestore_description: Linked service description.
        :type azuredatalakestore_description: str
        :param azuredatalakestore_parameters: Parameters for linked service.
        :type azuredatalakestore_parameters: dict[str, ~azure.mgmt.datafactory.models.ParameterSpecification]
        :param azuredatalakestore_annotations: List of tags that can be used for describing the linked
         service.
        :type azuredatalakestore_annotations: list[object]
        :param azuredatalakestore_service_principal_id: The ID of the application used to authenticate
         against the Azure Data Lake Store account. Type: string (or Expression with resultType string).
        :type azuredatalakestore_service_principal_id: object
        :param azuredatalakestore_service_principal_key: The Key of the application used to
         authenticate against the Azure Data Lake Store account.
        :type azuredatalakestore_service_principal_key: ~azure.mgmt.datafactory.models.SecretBase
        :param azuredatalakestore_tenant: The name or ID of the tenant to which the service principal
         belongs. Type: string (or Expression with resultType string).
        :type azuredatalakestore_tenant: object
        :param azuredatalakestore_account_name: Data Lake Store account name. Type: string (or
         Expression with resultType string).
        :type azuredatalakestore_account_name: object
        :param azuredatalakestore_subscription_id: Data Lake Store account subscription ID (if
         different from Data Factory account). Type: string (or Expression with resultType string).
        :type azuredatalakestore_subscription_id: object
        :param azuredatalakestore_resource_group_name: Data Lake Store account resource group name (if
         different from Data Factory account). Type: string (or Expression with resultType string).
        :type azuredatalakestore_resource_group_name: object
        :param azuredatalakestore_encrypted_credential: The encrypted credential used for
         authentication. Credentials are encrypted using the integration runtime credential manager.
         Type: string (or Expression with resultType string).
        :type azuredatalakestore_encrypted_credential: object
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: LinkedServiceResource or the result of cls(response)
        :rtype: ~azure.mgmt.datafactory.models.LinkedServiceResource
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.LinkedServiceResource"]
        error_map = kwargs.pop('error_map', {404: ResourceNotFoundError, 409: ResourceExistsError})

        _linked_service = models.LinkedServiceResource(properties=properties, type=azuredatalakestore_type, connect_via=azuredatalakestore_connect_via, description=azuredatalakestore_description, parameters=azuredatalakestore_parameters, annotations=azuredatalakestore_annotations, data_lake_store_uri=azuredatalakestore_data_lake_store_uri, service_principal_id=azuredatalakestore_service_principal_id, service_principal_key=azuredatalakestore_service_principal_key, tenant=azuredatalakestore_tenant, account_name=azuredatalakestore_account_name, subscription_id=azuredatalakestore_subscription_id, resource_group_name=azuredatalakestore_resource_group_name, encrypted_credential=azuredatalakestore_encrypted_credential)
        api_version = "2018-06-01"
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.create_or_update_azuredatalakestore.metadata['url']
        path_format_arguments = {
            'subscriptionId': self._serialize.url("self._config.subscription_id", self._config.subscription_id, 'str'),
            'resourceGroupName': self._serialize.url("resource_group_name", resource_group_name, 'str', max_length=90, min_length=1, pattern=r'^[-\w\._\(\)]+$'),
            'factoryName': self._serialize.url("factory_name", factory_name, 'str', max_length=63, min_length=3, pattern=r'^[A-Za-z0-9]+(?:-[A-Za-z0-9]+)*$'),
            'linkedServiceName': self._serialize.url("linked_service_name", linked_service_name, 'str', max_length=260, min_length=1, pattern=r'^[A-Za-z0-9_][^<>*#.%&:\\+?/]*$'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = 'application/json'

        # Construct and send request
        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_linked_service, 'LinkedServiceResource')
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = self._deserialize('LinkedServiceResource', pipeline_response)

        if cls:
          return cls(pipeline_response, deserialized, {})

        return deserialized
    create_or_update_azuredatalakestore.metadata = {'url': '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataFactory/factories/{factoryName}/linkedservices/{linkedServiceName}'}

    def create_or_update_azuredatabricks(
        self,
        resource_group_name,  # type: str
        factory_name,  # type: str
        linked_service_name,  # type: str
        azuredatabricks_type,  # type: str
        azuredatabricks_domain,  # type: object
        azuredatabricks_access_token,  # type: "models.SecretBase"
        if_match=None,  # type: Optional[str]
        azuredatabricks_connect_via=None,  # type: Optional["models.IntegrationRuntimeReference"]
        azuredatabricks_description=None,  # type: Optional[str]
        azuredatabricks_parameters=None,  # type: Optional[Dict[str, "ParameterSpecification"]]
        azuredatabricks_annotations=None,  # type: Optional[List[object]]
        azuredatabricks_existing_cluster_id=None,  # type: Optional[object]
        azuredatabricks_instance_pool_id=None,  # type: Optional[object]
        azuredatabricks_new_cluster_version=None,  # type: Optional[object]
        azuredatabricks_new_cluster_num_of_worker=None,  # type: Optional[object]
        azuredatabricks_new_cluster_node_type=None,  # type: Optional[object]
        azuredatabricks_new_cluster_spark_conf=None,  # type: Optional[Dict[str, object]]
        azuredatabricks_new_cluster_spark_env_vars=None,  # type: Optional[Dict[str, object]]
        azuredatabricks_new_cluster_custom_tags=None,  # type: Optional[Dict[str, object]]
        azuredatabricks_new_cluster_driver_node_type=None,  # type: Optional[object]
        azuredatabricks_new_cluster_init_scripts=None,  # type: Optional[object]
        azuredatabricks_new_cluster_enable_elastic_disk=None,  # type: Optional[object]
        azuredatabricks_encrypted_credential=None,  # type: Optional[object]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.LinkedServiceResource"
        """Creates or updates a linked service.

        :param resource_group_name: The resource group name.
        :type resource_group_name: str
        :param factory_name: The factory name.
        :type factory_name: str
        :param linked_service_name: The linked service name.
        :type linked_service_name: str
        :param azuredatabricks_type: Type of linked service.
        :type azuredatabricks_type: str
        :param azuredatabricks_domain: :code:`<REGION>`.azuredatabricks.net, domain name of your
         Databricks deployment. Type: string (or Expression with resultType string).
        :type azuredatabricks_domain: object
        :param azuredatabricks_access_token: Access token for databricks REST API. Refer to
         https://docs.azuredatabricks.net/api/latest/authentication.html. Type: string (or Expression
         with resultType string).
        :type azuredatabricks_access_token: ~azure.mgmt.datafactory.models.SecretBase
        :param if_match: ETag of the linkedService entity.  Should only be specified for update, for
         which it should match existing entity or can be * for unconditional update.
        :type if_match: str
        :param azuredatabricks_connect_via: The integration runtime reference.
        :type azuredatabricks_connect_via: ~azure.mgmt.datafactory.models.IntegrationRuntimeReference
        :param azuredatabricks_description: Linked service description.
        :type azuredatabricks_description: str
        :param azuredatabricks_parameters: Parameters for linked service.
        :type azuredatabricks_parameters: dict[str, ~azure.mgmt.datafactory.models.ParameterSpecification]
        :param azuredatabricks_annotations: List of tags that can be used for describing the linked
         service.
        :type azuredatabricks_annotations: list[object]
        :param azuredatabricks_existing_cluster_id: The id of an existing interactive cluster that will
         be used for all runs of this activity. Type: string (or Expression with resultType string).
        :type azuredatabricks_existing_cluster_id: object
        :param azuredatabricks_instance_pool_id: The id of an existing instance pool that will be used
         for all runs of this activity. Type: string (or Expression with resultType string).
        :type azuredatabricks_instance_pool_id: object
        :param azuredatabricks_new_cluster_version: If not using an existing interactive cluster, this
         specifies the Spark version of a new job cluster or instance pool nodes created for each run of
         this activity. Required if instancePoolId is specified. Type: string (or Expression with
         resultType string).
        :type azuredatabricks_new_cluster_version: object
        :param azuredatabricks_new_cluster_num_of_worker: If not using an existing interactive cluster,
         this specifies the number of worker nodes to use for the new job cluster or instance pool. For
         new job clusters, this a string-formatted Int32, like '1' means numOfWorker is 1 or '1:10'
         means auto-scale from 1 (min) to 10 (max). For instance pools, this is a string-formatted
         Int32, and can only specify a fixed number of worker nodes, such as '2'. Required if
         newClusterVersion is specified. Type: string (or Expression with resultType string).
        :type azuredatabricks_new_cluster_num_of_worker: object
        :param azuredatabricks_new_cluster_node_type: The node type of the new job cluster. This
         property is required if newClusterVersion is specified and instancePoolId is not specified. If
         instancePoolId is specified, this property is ignored. Type: string (or Expression with
         resultType string).
        :type azuredatabricks_new_cluster_node_type: object
        :param azuredatabricks_new_cluster_spark_conf: A set of optional, user-specified Spark
         configuration key-value pairs.
        :type azuredatabricks_new_cluster_spark_conf: dict[str, object]
        :param azuredatabricks_new_cluster_spark_env_vars: A set of optional, user-specified Spark
         environment variables key-value pairs.
        :type azuredatabricks_new_cluster_spark_env_vars: dict[str, object]
        :param azuredatabricks_new_cluster_custom_tags: Additional tags for cluster resources. This
         property is ignored in instance pool configurations.
        :type azuredatabricks_new_cluster_custom_tags: dict[str, object]
        :param azuredatabricks_new_cluster_driver_node_type: The driver node type for the new job
         cluster. This property is ignored in instance pool configurations. Type: string (or Expression
         with resultType string).
        :type azuredatabricks_new_cluster_driver_node_type: object
        :param azuredatabricks_new_cluster_init_scripts: User-defined initialization scripts for the
         new cluster. Type: array of strings (or Expression with resultType array of strings).
        :type azuredatabricks_new_cluster_init_scripts: object
        :param azuredatabricks_new_cluster_enable_elastic_disk: Enable the elastic disk on the new
         cluster. This property is now ignored, and takes the default elastic disk behavior in
         Databricks (elastic disks are always enabled). Type: boolean (or Expression with resultType
         boolean).
        :type azuredatabricks_new_cluster_enable_elastic_disk: object
        :param azuredatabricks_encrypted_credential: The encrypted credential used for authentication.
         Credentials are encrypted using the integration runtime credential manager. Type: string (or
         Expression with resultType string).
        :type azuredatabricks_encrypted_credential: object
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: LinkedServiceResource or the result of cls(response)
        :rtype: ~azure.mgmt.datafactory.models.LinkedServiceResource
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.LinkedServiceResource"]
        error_map = kwargs.pop('error_map', {404: ResourceNotFoundError, 409: ResourceExistsError})

        _linked_service = models.LinkedServiceResource(properties=properties, type=azuredatabricks_type, connect_via=azuredatabricks_connect_via, description=azuredatabricks_description, parameters=azuredatabricks_parameters, annotations=azuredatabricks_annotations, domain=azuredatabricks_domain, access_token=azuredatabricks_access_token, existing_cluster_id=azuredatabricks_existing_cluster_id, instance_pool_id=azuredatabricks_instance_pool_id, new_cluster_version=azuredatabricks_new_cluster_version, new_cluster_num_of_worker=azuredatabricks_new_cluster_num_of_worker, new_cluster_node_type=azuredatabricks_new_cluster_node_type, new_cluster_spark_conf=azuredatabricks_new_cluster_spark_conf, new_cluster_spark_env_vars=azuredatabricks_new_cluster_spark_env_vars, new_cluster_custom_tags=azuredatabricks_new_cluster_custom_tags, new_cluster_driver_node_type=azuredatabricks_new_cluster_driver_node_type, new_cluster_init_scripts=azuredatabricks_new_cluster_init_scripts, new_cluster_enable_elastic_disk=azuredatabricks_new_cluster_enable_elastic_disk, encrypted_credential=azuredatabricks_encrypted_credential)
        api_version = "2018-06-01"
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.create_or_update_azuredatabricks.metadata['url']
        path_format_arguments = {
            'subscriptionId': self._serialize.url("self._config.subscription_id", self._config.subscription_id, 'str'),
            'resourceGroupName': self._serialize.url("resource_group_name", resource_group_name, 'str', max_length=90, min_length=1, pattern=r'^[-\w\._\(\)]+$'),
            'factoryName': self._serialize.url("factory_name", factory_name, 'str', max_length=63, min_length=3, pattern=r'^[A-Za-z0-9]+(?:-[A-Za-z0-9]+)*$'),
            'linkedServiceName': self._serialize.url("linked_service_name", linked_service_name, 'str', max_length=260, min_length=1, pattern=r'^[A-Za-z0-9_][^<>*#.%&:\\+?/]*$'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = 'application/json'

        # Construct and send request
        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_linked_service, 'LinkedServiceResource')
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = self._deserialize('LinkedServiceResource', pipeline_response)

        if cls:
          return cls(pipeline_response, deserialized, {})

        return deserialized
    create_or_update_azuredatabricks.metadata = {'url': '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataFactory/factories/{factoryName}/linkedservices/{linkedServiceName}'}

    def create_or_update_azurefilestorage(
        self,
        resource_group_name,  # type: str
        factory_name,  # type: str
        linked_service_name,  # type: str
        azurefilestorage_type,  # type: str
        azurefilestorage_host,  # type: object
        if_match=None,  # type: Optional[str]
        azurefilestorage_connect_via=None,  # type: Optional["models.IntegrationRuntimeReference"]
        azurefilestorage_description=None,  # type: Optional[str]
        azurefilestorage_parameters=None,  # type: Optional[Dict[str, "ParameterSpecification"]]
        azurefilestorage_annotations=None,  # type: Optional[List[object]]
        azurefilestorage_user_id=None,  # type: Optional[object]
        azurefilestorage_password=None,  # type: Optional["models.SecretBase"]
        azurefilestorage_encrypted_credential=None,  # type: Optional[object]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.LinkedServiceResource"
        """Creates or updates a linked service.

        :param resource_group_name: The resource group name.
        :type resource_group_name: str
        :param factory_name: The factory name.
        :type factory_name: str
        :param linked_service_name: The linked service name.
        :type linked_service_name: str
        :param azurefilestorage_type: Type of linked service.
        :type azurefilestorage_type: str
        :param azurefilestorage_host: Host name of the server. Type: string (or Expression with
         resultType string).
        :type azurefilestorage_host: object
        :param if_match: ETag of the linkedService entity.  Should only be specified for update, for
         which it should match existing entity or can be * for unconditional update.
        :type if_match: str
        :param azurefilestorage_connect_via: The integration runtime reference.
        :type azurefilestorage_connect_via: ~azure.mgmt.datafactory.models.IntegrationRuntimeReference
        :param azurefilestorage_description: Linked service description.
        :type azurefilestorage_description: str
        :param azurefilestorage_parameters: Parameters for linked service.
        :type azurefilestorage_parameters: dict[str, ~azure.mgmt.datafactory.models.ParameterSpecification]
        :param azurefilestorage_annotations: List of tags that can be used for describing the linked
         service.
        :type azurefilestorage_annotations: list[object]
        :param azurefilestorage_user_id: User ID to logon the server. Type: string (or Expression with
         resultType string).
        :type azurefilestorage_user_id: object
        :param azurefilestorage_password: Password to logon the server.
        :type azurefilestorage_password: ~azure.mgmt.datafactory.models.SecretBase
        :param azurefilestorage_encrypted_credential: The encrypted credential used for authentication.
         Credentials are encrypted using the integration runtime credential manager. Type: string (or
         Expression with resultType string).
        :type azurefilestorage_encrypted_credential: object
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: LinkedServiceResource or the result of cls(response)
        :rtype: ~azure.mgmt.datafactory.models.LinkedServiceResource
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.LinkedServiceResource"]
        error_map = kwargs.pop('error_map', {404: ResourceNotFoundError, 409: ResourceExistsError})

        _linked_service = models.LinkedServiceResource(properties=properties, type=azurefilestorage_type, connect_via=azurefilestorage_connect_via, description=azurefilestorage_description, parameters=azurefilestorage_parameters, annotations=azurefilestorage_annotations, host=azurefilestorage_host, user_id=azurefilestorage_user_id, password=azurefilestorage_password, encrypted_credential=azurefilestorage_encrypted_credential)
        api_version = "2018-06-01"
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.create_or_update_azurefilestorage.metadata['url']
        path_format_arguments = {
            'subscriptionId': self._serialize.url("self._config.subscription_id", self._config.subscription_id, 'str'),
            'resourceGroupName': self._serialize.url("resource_group_name", resource_group_name, 'str', max_length=90, min_length=1, pattern=r'^[-\w\._\(\)]+$'),
            'factoryName': self._serialize.url("factory_name", factory_name, 'str', max_length=63, min_length=3, pattern=r'^[A-Za-z0-9]+(?:-[A-Za-z0-9]+)*$'),
            'linkedServiceName': self._serialize.url("linked_service_name", linked_service_name, 'str', max_length=260, min_length=1, pattern=r'^[A-Za-z0-9_][^<>*#.%&:\\+?/]*$'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = 'application/json'

        # Construct and send request
        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_linked_service, 'LinkedServiceResource')
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = self._deserialize('LinkedServiceResource', pipeline_response)

        if cls:
          return cls(pipeline_response, deserialized, {})

        return deserialized
    create_or_update_azurefilestorage.metadata = {'url': '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataFactory/factories/{factoryName}/linkedservices/{linkedServiceName}'}

    def create_or_update_azurefunction(
        self,
        resource_group_name,  # type: str
        factory_name,  # type: str
        linked_service_name,  # type: str
        azurefunction_type,  # type: str
        azurefunction_function_app_url,  # type: object
        if_match=None,  # type: Optional[str]
        azurefunction_connect_via=None,  # type: Optional["models.IntegrationRuntimeReference"]
        azurefunction_description=None,  # type: Optional[str]
        azurefunction_parameters=None,  # type: Optional[Dict[str, "ParameterSpecification"]]
        azurefunction_annotations=None,  # type: Optional[List[object]]
        azurefunction_function_key=None,  # type: Optional["models.SecretBase"]
        azurefunction_encrypted_credential=None,  # type: Optional[object]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.LinkedServiceResource"
        """Creates or updates a linked service.

        :param resource_group_name: The resource group name.
        :type resource_group_name: str
        :param factory_name: The factory name.
        :type factory_name: str
        :param linked_service_name: The linked service name.
        :type linked_service_name: str
        :param azurefunction_type: Type of linked service.
        :type azurefunction_type: str
        :param azurefunction_function_app_url: The endpoint of the Azure Function App. URL will be in
         the format https://:code:`<accountName>`.azurewebsites.net.
        :type azurefunction_function_app_url: object
        :param if_match: ETag of the linkedService entity.  Should only be specified for update, for
         which it should match existing entity or can be * for unconditional update.
        :type if_match: str
        :param azurefunction_connect_via: The integration runtime reference.
        :type azurefunction_connect_via: ~azure.mgmt.datafactory.models.IntegrationRuntimeReference
        :param azurefunction_description: Linked service description.
        :type azurefunction_description: str
        :param azurefunction_parameters: Parameters for linked service.
        :type azurefunction_parameters: dict[str, ~azure.mgmt.datafactory.models.ParameterSpecification]
        :param azurefunction_annotations: List of tags that can be used for describing the linked
         service.
        :type azurefunction_annotations: list[object]
        :param azurefunction_function_key: Function or Host key for Azure Function App.
        :type azurefunction_function_key: ~azure.mgmt.datafactory.models.SecretBase
        :param azurefunction_encrypted_credential: The encrypted credential used for authentication.
         Credentials are encrypted using the integration runtime credential manager. Type: string (or
         Expression with resultType string).
        :type azurefunction_encrypted_credential: object
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: LinkedServiceResource or the result of cls(response)
        :rtype: ~azure.mgmt.datafactory.models.LinkedServiceResource
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.LinkedServiceResource"]
        error_map = kwargs.pop('error_map', {404: ResourceNotFoundError, 409: ResourceExistsError})

        _linked_service = models.LinkedServiceResource(properties=properties, type=azurefunction_type, connect_via=azurefunction_connect_via, description=azurefunction_description, parameters=azurefunction_parameters, annotations=azurefunction_annotations, function_app_url=azurefunction_function_app_url, function_key=azurefunction_function_key, encrypted_credential=azurefunction_encrypted_credential)
        api_version = "2018-06-01"
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.create_or_update_azurefunction.metadata['url']
        path_format_arguments = {
            'subscriptionId': self._serialize.url("self._config.subscription_id", self._config.subscription_id, 'str'),
            'resourceGroupName': self._serialize.url("resource_group_name", resource_group_name, 'str', max_length=90, min_length=1, pattern=r'^[-\w\._\(\)]+$'),
            'factoryName': self._serialize.url("factory_name", factory_name, 'str', max_length=63, min_length=3, pattern=r'^[A-Za-z0-9]+(?:-[A-Za-z0-9]+)*$'),
            'linkedServiceName': self._serialize.url("linked_service_name", linked_service_name, 'str', max_length=260, min_length=1, pattern=r'^[A-Za-z0-9_][^<>*#.%&:\\+?/]*$'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = 'application/json'

        # Construct and send request
        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_linked_service, 'LinkedServiceResource')
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = self._deserialize('LinkedServiceResource', pipeline_response)

        if cls:
          return cls(pipeline_response, deserialized, {})

        return deserialized
    create_or_update_azurefunction.metadata = {'url': '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataFactory/factories/{factoryName}/linkedservices/{linkedServiceName}'}

    def create_or_update_azurekeyvault(
        self,
        resource_group_name,  # type: str
        factory_name,  # type: str
        linked_service_name,  # type: str
        azurekeyvault_type,  # type: str
        azurekeyvault_base_url,  # type: object
        if_match=None,  # type: Optional[str]
        azurekeyvault_connect_via=None,  # type: Optional["models.IntegrationRuntimeReference"]
        azurekeyvault_description=None,  # type: Optional[str]
        azurekeyvault_parameters=None,  # type: Optional[Dict[str, "ParameterSpecification"]]
        azurekeyvault_annotations=None,  # type: Optional[List[object]]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.LinkedServiceResource"
        """Creates or updates a linked service.

        :param resource_group_name: The resource group name.
        :type resource_group_name: str
        :param factory_name: The factory name.
        :type factory_name: str
        :param linked_service_name: The linked service name.
        :type linked_service_name: str
        :param azurekeyvault_type: Type of linked service.
        :type azurekeyvault_type: str
        :param azurekeyvault_base_url: The base URL of the Azure Key Vault. e.g.
         https://myakv.vault.azure.net Type: string (or Expression with resultType string).
        :type azurekeyvault_base_url: object
        :param if_match: ETag of the linkedService entity.  Should only be specified for update, for
         which it should match existing entity or can be * for unconditional update.
        :type if_match: str
        :param azurekeyvault_connect_via: The integration runtime reference.
        :type azurekeyvault_connect_via: ~azure.mgmt.datafactory.models.IntegrationRuntimeReference
        :param azurekeyvault_description: Linked service description.
        :type azurekeyvault_description: str
        :param azurekeyvault_parameters: Parameters for linked service.
        :type azurekeyvault_parameters: dict[str, ~azure.mgmt.datafactory.models.ParameterSpecification]
        :param azurekeyvault_annotations: List of tags that can be used for describing the linked
         service.
        :type azurekeyvault_annotations: list[object]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: LinkedServiceResource or the result of cls(response)
        :rtype: ~azure.mgmt.datafactory.models.LinkedServiceResource
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.LinkedServiceResource"]
        error_map = kwargs.pop('error_map', {404: ResourceNotFoundError, 409: ResourceExistsError})

        _linked_service = models.LinkedServiceResource(properties=properties, type=azurekeyvault_type, connect_via=azurekeyvault_connect_via, description=azurekeyvault_description, parameters=azurekeyvault_parameters, annotations=azurekeyvault_annotations, base_url=azurekeyvault_base_url)
        api_version = "2018-06-01"
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.create_or_update_azurekeyvault.metadata['url']
        path_format_arguments = {
            'subscriptionId': self._serialize.url("self._config.subscription_id", self._config.subscription_id, 'str'),
            'resourceGroupName': self._serialize.url("resource_group_name", resource_group_name, 'str', max_length=90, min_length=1, pattern=r'^[-\w\._\(\)]+$'),
            'factoryName': self._serialize.url("factory_name", factory_name, 'str', max_length=63, min_length=3, pattern=r'^[A-Za-z0-9]+(?:-[A-Za-z0-9]+)*$'),
            'linkedServiceName': self._serialize.url("linked_service_name", linked_service_name, 'str', max_length=260, min_length=1, pattern=r'^[A-Za-z0-9_][^<>*#.%&:\\+?/]*$'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = 'application/json'

        # Construct and send request
        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_linked_service, 'LinkedServiceResource')
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = self._deserialize('LinkedServiceResource', pipeline_response)

        if cls:
          return cls(pipeline_response, deserialized, {})

        return deserialized
    create_or_update_azurekeyvault.metadata = {'url': '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataFactory/factories/{factoryName}/linkedservices/{linkedServiceName}'}

    def create_or_update_azureml(
        self,
        resource_group_name,  # type: str
        factory_name,  # type: str
        linked_service_name,  # type: str
        azureml_type,  # type: str
        azureml_ml_endpoint,  # type: object
        azureml_api_key,  # type: "models.SecretBase"
        if_match=None,  # type: Optional[str]
        azureml_connect_via=None,  # type: Optional["models.IntegrationRuntimeReference"]
        azureml_description=None,  # type: Optional[str]
        azureml_parameters=None,  # type: Optional[Dict[str, "ParameterSpecification"]]
        azureml_annotations=None,  # type: Optional[List[object]]
        azureml_update_resource_endpoint=None,  # type: Optional[object]
        azureml_service_principal_id=None,  # type: Optional[object]
        azureml_service_principal_key=None,  # type: Optional["models.SecretBase"]
        azureml_tenant=None,  # type: Optional[object]
        azureml_encrypted_credential=None,  # type: Optional[object]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.LinkedServiceResource"
        """Creates or updates a linked service.

        :param resource_group_name: The resource group name.
        :type resource_group_name: str
        :param factory_name: The factory name.
        :type factory_name: str
        :param linked_service_name: The linked service name.
        :type linked_service_name: str
        :param azureml_type: Type of linked service.
        :type azureml_type: str
        :param azureml_ml_endpoint: The Batch Execution REST URL for an Azure ML Studio Web Service
         endpoint. Type: string (or Expression with resultType string).
        :type azureml_ml_endpoint: object
        :param azureml_api_key: The API key for accessing the Azure ML model endpoint.
        :type azureml_api_key: ~azure.mgmt.datafactory.models.SecretBase
        :param if_match: ETag of the linkedService entity.  Should only be specified for update, for
         which it should match existing entity or can be * for unconditional update.
        :type if_match: str
        :param azureml_connect_via: The integration runtime reference.
        :type azureml_connect_via: ~azure.mgmt.datafactory.models.IntegrationRuntimeReference
        :param azureml_description: Linked service description.
        :type azureml_description: str
        :param azureml_parameters: Parameters for linked service.
        :type azureml_parameters: dict[str, ~azure.mgmt.datafactory.models.ParameterSpecification]
        :param azureml_annotations: List of tags that can be used for describing the linked service.
        :type azureml_annotations: list[object]
        :param azureml_update_resource_endpoint: The Update Resource REST URL for an Azure ML Studio
         Web Service endpoint. Type: string (or Expression with resultType string).
        :type azureml_update_resource_endpoint: object
        :param azureml_service_principal_id: The ID of the service principal used to authenticate
         against the ARM-based updateResourceEndpoint of an Azure ML Studio web service. Type: string
         (or Expression with resultType string).
        :type azureml_service_principal_id: object
        :param azureml_service_principal_key: The key of the service principal used to authenticate
         against the ARM-based updateResourceEndpoint of an Azure ML Studio web service.
        :type azureml_service_principal_key: ~azure.mgmt.datafactory.models.SecretBase
        :param azureml_tenant: The name or ID of the tenant to which the service principal belongs.
         Type: string (or Expression with resultType string).
        :type azureml_tenant: object
        :param azureml_encrypted_credential: The encrypted credential used for authentication.
         Credentials are encrypted using the integration runtime credential manager. Type: string (or
         Expression with resultType string).
        :type azureml_encrypted_credential: object
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: LinkedServiceResource or the result of cls(response)
        :rtype: ~azure.mgmt.datafactory.models.LinkedServiceResource
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.LinkedServiceResource"]
        error_map = kwargs.pop('error_map', {404: ResourceNotFoundError, 409: ResourceExistsError})

        _linked_service = models.LinkedServiceResource(properties=properties, type=azureml_type, connect_via=azureml_connect_via, description=azureml_description, parameters=azureml_parameters, annotations=azureml_annotations, ml_endpoint=azureml_ml_endpoint, api_key=azureml_api_key, update_resource_endpoint=azureml_update_resource_endpoint, service_principal_id=azureml_service_principal_id, service_principal_key=azureml_service_principal_key, tenant=azureml_tenant, encrypted_credential=azureml_encrypted_credential)
        api_version = "2018-06-01"
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.create_or_update_azureml.metadata['url']
        path_format_arguments = {
            'subscriptionId': self._serialize.url("self._config.subscription_id", self._config.subscription_id, 'str'),
            'resourceGroupName': self._serialize.url("resource_group_name", resource_group_name, 'str', max_length=90, min_length=1, pattern=r'^[-\w\._\(\)]+$'),
            'factoryName': self._serialize.url("factory_name", factory_name, 'str', max_length=63, min_length=3, pattern=r'^[A-Za-z0-9]+(?:-[A-Za-z0-9]+)*$'),
            'linkedServiceName': self._serialize.url("linked_service_name", linked_service_name, 'str', max_length=260, min_length=1, pattern=r'^[A-Za-z0-9_][^<>*#.%&:\\+?/]*$'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = 'application/json'

        # Construct and send request
        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_linked_service, 'LinkedServiceResource')
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = self._deserialize('LinkedServiceResource', pipeline_response)

        if cls:
          return cls(pipeline_response, deserialized, {})

        return deserialized
    create_or_update_azureml.metadata = {'url': '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataFactory/factories/{factoryName}/linkedservices/{linkedServiceName}'}

    def create_or_update_azuremlservice(
        self,
        resource_group_name,  # type: str
        factory_name,  # type: str
        linked_service_name,  # type: str
        azuremlservice_type,  # type: str
        azuremlservice_subscription_id,  # type: object
        azuremlservice_resource_group_name,  # type: object
        azuremlservice_ml_workspace_name,  # type: object
        if_match=None,  # type: Optional[str]
        azuremlservice_connect_via=None,  # type: Optional["models.IntegrationRuntimeReference"]
        azuremlservice_description=None,  # type: Optional[str]
        azuremlservice_parameters=None,  # type: Optional[Dict[str, "ParameterSpecification"]]
        azuremlservice_annotations=None,  # type: Optional[List[object]]
        azuremlservice_service_principal_id=None,  # type: Optional[object]
        azuremlservice_service_principal_key=None,  # type: Optional["models.SecretBase"]
        azuremlservice_tenant=None,  # type: Optional[object]
        azuremlservice_encrypted_credential=None,  # type: Optional[object]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.LinkedServiceResource"
        """Creates or updates a linked service.

        :param resource_group_name: The resource group name.
        :type resource_group_name: str
        :param factory_name: The factory name.
        :type factory_name: str
        :param linked_service_name: The linked service name.
        :type linked_service_name: str
        :param azuremlservice_type: Type of linked service.
        :type azuremlservice_type: str
        :param azuremlservice_subscription_id: Azure ML Service workspace subscription ID. Type: string
         (or Expression with resultType string).
        :type azuremlservice_subscription_id: object
        :param azuremlservice_resource_group_name: Azure ML Service workspace resource group name.
         Type: string (or Expression with resultType string).
        :type azuremlservice_resource_group_name: object
        :param azuremlservice_ml_workspace_name: Azure ML Service workspace name. Type: string (or
         Expression with resultType string).
        :type azuremlservice_ml_workspace_name: object
        :param if_match: ETag of the linkedService entity.  Should only be specified for update, for
         which it should match existing entity or can be * for unconditional update.
        :type if_match: str
        :param azuremlservice_connect_via: The integration runtime reference.
        :type azuremlservice_connect_via: ~azure.mgmt.datafactory.models.IntegrationRuntimeReference
        :param azuremlservice_description: Linked service description.
        :type azuremlservice_description: str
        :param azuremlservice_parameters: Parameters for linked service.
        :type azuremlservice_parameters: dict[str, ~azure.mgmt.datafactory.models.ParameterSpecification]
        :param azuremlservice_annotations: List of tags that can be used for describing the linked
         service.
        :type azuremlservice_annotations: list[object]
        :param azuremlservice_service_principal_id: The ID of the service principal used to
         authenticate against the endpoint of a published Azure ML Service pipeline. Type: string (or
         Expression with resultType string).
        :type azuremlservice_service_principal_id: object
        :param azuremlservice_service_principal_key: The key of the service principal used to
         authenticate against the endpoint of a published Azure ML Service pipeline.
        :type azuremlservice_service_principal_key: ~azure.mgmt.datafactory.models.SecretBase
        :param azuremlservice_tenant: The name or ID of the tenant to which the service principal
         belongs. Type: string (or Expression with resultType string).
        :type azuremlservice_tenant: object
        :param azuremlservice_encrypted_credential: The encrypted credential used for authentication.
         Credentials are encrypted using the integration runtime credential manager. Type: string (or
         Expression with resultType string).
        :type azuremlservice_encrypted_credential: object
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: LinkedServiceResource or the result of cls(response)
        :rtype: ~azure.mgmt.datafactory.models.LinkedServiceResource
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.LinkedServiceResource"]
        error_map = kwargs.pop('error_map', {404: ResourceNotFoundError, 409: ResourceExistsError})

        _linked_service = models.LinkedServiceResource(properties=properties, type=azuremlservice_type, connect_via=azuremlservice_connect_via, description=azuremlservice_description, parameters=azuremlservice_parameters, annotations=azuremlservice_annotations, subscription_id=azuremlservice_subscription_id, resource_group_name=azuremlservice_resource_group_name, ml_workspace_name=azuremlservice_ml_workspace_name, service_principal_id=azuremlservice_service_principal_id, service_principal_key=azuremlservice_service_principal_key, tenant=azuremlservice_tenant, encrypted_credential=azuremlservice_encrypted_credential)
        api_version = "2018-06-01"
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.create_or_update_azuremlservice.metadata['url']
        path_format_arguments = {
            'subscriptionId': self._serialize.url("self._config.subscription_id", self._config.subscription_id, 'str'),
            'resourceGroupName': self._serialize.url("resource_group_name", resource_group_name, 'str', max_length=90, min_length=1, pattern=r'^[-\w\._\(\)]+$'),
            'factoryName': self._serialize.url("factory_name", factory_name, 'str', max_length=63, min_length=3, pattern=r'^[A-Za-z0-9]+(?:-[A-Za-z0-9]+)*$'),
            'linkedServiceName': self._serialize.url("linked_service_name", linked_service_name, 'str', max_length=260, min_length=1, pattern=r'^[A-Za-z0-9_][^<>*#.%&:\\+?/]*$'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = 'application/json'

        # Construct and send request
        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_linked_service, 'LinkedServiceResource')
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = self._deserialize('LinkedServiceResource', pipeline_response)

        if cls:
          return cls(pipeline_response, deserialized, {})

        return deserialized
    create_or_update_azuremlservice.metadata = {'url': '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataFactory/factories/{factoryName}/linkedservices/{linkedServiceName}'}

    def create_or_update_azuremariadb(
        self,
        resource_group_name,  # type: str
        factory_name,  # type: str
        linked_service_name,  # type: str
        azuremariadb_type,  # type: str
        if_match=None,  # type: Optional[str]
        azuremariadb_connect_via=None,  # type: Optional["models.IntegrationRuntimeReference"]
        azuremariadb_description=None,  # type: Optional[str]
        azuremariadb_parameters=None,  # type: Optional[Dict[str, "ParameterSpecification"]]
        azuremariadb_annotations=None,  # type: Optional[List[object]]
        azuremariadb_connection_string=None,  # type: Optional[object]
        azuremariadb_pwd=None,  # type: Optional["models.AzureKeyVaultSecretReference"]
        azuremariadb_encrypted_credential=None,  # type: Optional[object]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.LinkedServiceResource"
        """Creates or updates a linked service.

        :param resource_group_name: The resource group name.
        :type resource_group_name: str
        :param factory_name: The factory name.
        :type factory_name: str
        :param linked_service_name: The linked service name.
        :type linked_service_name: str
        :param azuremariadb_type: Type of linked service.
        :type azuremariadb_type: str
        :param if_match: ETag of the linkedService entity.  Should only be specified for update, for
         which it should match existing entity or can be * for unconditional update.
        :type if_match: str
        :param azuremariadb_connect_via: The integration runtime reference.
        :type azuremariadb_connect_via: ~azure.mgmt.datafactory.models.IntegrationRuntimeReference
        :param azuremariadb_description: Linked service description.
        :type azuremariadb_description: str
        :param azuremariadb_parameters: Parameters for linked service.
        :type azuremariadb_parameters: dict[str, ~azure.mgmt.datafactory.models.ParameterSpecification]
        :param azuremariadb_annotations: List of tags that can be used for describing the linked
         service.
        :type azuremariadb_annotations: list[object]
        :param azuremariadb_connection_string: An ODBC connection string. Type: string, SecureString or
         AzureKeyVaultSecretReference.
        :type azuremariadb_connection_string: object
        :param azuremariadb_pwd: The Azure key vault secret reference of password in connection string.
        :type azuremariadb_pwd: ~azure.mgmt.datafactory.models.AzureKeyVaultSecretReference
        :param azuremariadb_encrypted_credential: The encrypted credential used for authentication.
         Credentials are encrypted using the integration runtime credential manager. Type: string (or
         Expression with resultType string).
        :type azuremariadb_encrypted_credential: object
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: LinkedServiceResource or the result of cls(response)
        :rtype: ~azure.mgmt.datafactory.models.LinkedServiceResource
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.LinkedServiceResource"]
        error_map = kwargs.pop('error_map', {404: ResourceNotFoundError, 409: ResourceExistsError})

        _linked_service = models.LinkedServiceResource(properties=properties, type=azuremariadb_type, connect_via=azuremariadb_connect_via, description=azuremariadb_description, parameters=azuremariadb_parameters, annotations=azuremariadb_annotations, connection_string=azuremariadb_connection_string, pwd=azuremariadb_pwd, encrypted_credential=azuremariadb_encrypted_credential)
        api_version = "2018-06-01"
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.create_or_update_azuremariadb.metadata['url']
        path_format_arguments = {
            'subscriptionId': self._serialize.url("self._config.subscription_id", self._config.subscription_id, 'str'),
            'resourceGroupName': self._serialize.url("resource_group_name", resource_group_name, 'str', max_length=90, min_length=1, pattern=r'^[-\w\._\(\)]+$'),
            'factoryName': self._serialize.url("factory_name", factory_name, 'str', max_length=63, min_length=3, pattern=r'^[A-Za-z0-9]+(?:-[A-Za-z0-9]+)*$'),
            'linkedServiceName': self._serialize.url("linked_service_name", linked_service_name, 'str', max_length=260, min_length=1, pattern=r'^[A-Za-z0-9_][^<>*#.%&:\\+?/]*$'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = 'application/json'

        # Construct and send request
        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_linked_service, 'LinkedServiceResource')
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = self._deserialize('LinkedServiceResource', pipeline_response)

        if cls:
          return cls(pipeline_response, deserialized, {})

        return deserialized
    create_or_update_azuremariadb.metadata = {'url': '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataFactory/factories/{factoryName}/linkedservices/{linkedServiceName}'}

    def create_or_update_azuremysql(
        self,
        resource_group_name,  # type: str
        factory_name,  # type: str
        linked_service_name,  # type: str
        azuremysql_type,  # type: str
        azuremysql_connection_string,  # type: object
        if_match=None,  # type: Optional[str]
        azuremysql_connect_via=None,  # type: Optional["models.IntegrationRuntimeReference"]
        azuremysql_description=None,  # type: Optional[str]
        azuremysql_parameters=None,  # type: Optional[Dict[str, "ParameterSpecification"]]
        azuremysql_annotations=None,  # type: Optional[List[object]]
        azuremysql_password=None,  # type: Optional["models.AzureKeyVaultSecretReference"]
        azuremysql_encrypted_credential=None,  # type: Optional[object]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.LinkedServiceResource"
        """Creates or updates a linked service.

        :param resource_group_name: The resource group name.
        :type resource_group_name: str
        :param factory_name: The factory name.
        :type factory_name: str
        :param linked_service_name: The linked service name.
        :type linked_service_name: str
        :param azuremysql_type: Type of linked service.
        :type azuremysql_type: str
        :param azuremysql_connection_string: The connection string. Type: string, SecureString or
         AzureKeyVaultSecretReference.
        :type azuremysql_connection_string: object
        :param if_match: ETag of the linkedService entity.  Should only be specified for update, for
         which it should match existing entity or can be * for unconditional update.
        :type if_match: str
        :param azuremysql_connect_via: The integration runtime reference.
        :type azuremysql_connect_via: ~azure.mgmt.datafactory.models.IntegrationRuntimeReference
        :param azuremysql_description: Linked service description.
        :type azuremysql_description: str
        :param azuremysql_parameters: Parameters for linked service.
        :type azuremysql_parameters: dict[str, ~azure.mgmt.datafactory.models.ParameterSpecification]
        :param azuremysql_annotations: List of tags that can be used for describing the linked service.
        :type azuremysql_annotations: list[object]
        :param azuremysql_password: The Azure key vault secret reference of password in connection
         string.
        :type azuremysql_password: ~azure.mgmt.datafactory.models.AzureKeyVaultSecretReference
        :param azuremysql_encrypted_credential: The encrypted credential used for authentication.
         Credentials are encrypted using the integration runtime credential manager. Type: string (or
         Expression with resultType string).
        :type azuremysql_encrypted_credential: object
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: LinkedServiceResource or the result of cls(response)
        :rtype: ~azure.mgmt.datafactory.models.LinkedServiceResource
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.LinkedServiceResource"]
        error_map = kwargs.pop('error_map', {404: ResourceNotFoundError, 409: ResourceExistsError})

        _linked_service = models.LinkedServiceResource(properties=properties, type=azuremysql_type, connect_via=azuremysql_connect_via, description=azuremysql_description, parameters=azuremysql_parameters, annotations=azuremysql_annotations, connection_string=azuremysql_connection_string, password=azuremysql_password, encrypted_credential=azuremysql_encrypted_credential)
        api_version = "2018-06-01"
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.create_or_update_azuremysql.metadata['url']
        path_format_arguments = {
            'subscriptionId': self._serialize.url("self._config.subscription_id", self._config.subscription_id, 'str'),
            'resourceGroupName': self._serialize.url("resource_group_name", resource_group_name, 'str', max_length=90, min_length=1, pattern=r'^[-\w\._\(\)]+$'),
            'factoryName': self._serialize.url("factory_name", factory_name, 'str', max_length=63, min_length=3, pattern=r'^[A-Za-z0-9]+(?:-[A-Za-z0-9]+)*$'),
            'linkedServiceName': self._serialize.url("linked_service_name", linked_service_name, 'str', max_length=260, min_length=1, pattern=r'^[A-Za-z0-9_][^<>*#.%&:\\+?/]*$'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = 'application/json'

        # Construct and send request
        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_linked_service, 'LinkedServiceResource')
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = self._deserialize('LinkedServiceResource', pipeline_response)

        if cls:
          return cls(pipeline_response, deserialized, {})

        return deserialized
    create_or_update_azuremysql.metadata = {'url': '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataFactory/factories/{factoryName}/linkedservices/{linkedServiceName}'}

    def create_or_update_azurepostgresql(
        self,
        resource_group_name,  # type: str
        factory_name,  # type: str
        linked_service_name,  # type: str
        azurepostgresql_type,  # type: str
        if_match=None,  # type: Optional[str]
        azurepostgresql_connect_via=None,  # type: Optional["models.IntegrationRuntimeReference"]
        azurepostgresql_description=None,  # type: Optional[str]
        azurepostgresql_parameters=None,  # type: Optional[Dict[str, "ParameterSpecification"]]
        azurepostgresql_annotations=None,  # type: Optional[List[object]]
        azurepostgresql_connection_string=None,  # type: Optional[object]
        azurepostgresql_password=None,  # type: Optional["models.AzureKeyVaultSecretReference"]
        azurepostgresql_encrypted_credential=None,  # type: Optional[object]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.LinkedServiceResource"
        """Creates or updates a linked service.

        :param resource_group_name: The resource group name.
        :type resource_group_name: str
        :param factory_name: The factory name.
        :type factory_name: str
        :param linked_service_name: The linked service name.
        :type linked_service_name: str
        :param azurepostgresql_type: Type of linked service.
        :type azurepostgresql_type: str
        :param if_match: ETag of the linkedService entity.  Should only be specified for update, for
         which it should match existing entity or can be * for unconditional update.
        :type if_match: str
        :param azurepostgresql_connect_via: The integration runtime reference.
        :type azurepostgresql_connect_via: ~azure.mgmt.datafactory.models.IntegrationRuntimeReference
        :param azurepostgresql_description: Linked service description.
        :type azurepostgresql_description: str
        :param azurepostgresql_parameters: Parameters for linked service.
        :type azurepostgresql_parameters: dict[str, ~azure.mgmt.datafactory.models.ParameterSpecification]
        :param azurepostgresql_annotations: List of tags that can be used for describing the linked
         service.
        :type azurepostgresql_annotations: list[object]
        :param azurepostgresql_connection_string: An ODBC connection string. Type: string, SecureString
         or AzureKeyVaultSecretReference.
        :type azurepostgresql_connection_string: object
        :param azurepostgresql_password: The Azure key vault secret reference of password in connection
         string.
        :type azurepostgresql_password: ~azure.mgmt.datafactory.models.AzureKeyVaultSecretReference
        :param azurepostgresql_encrypted_credential: The encrypted credential used for authentication.
         Credentials are encrypted using the integration runtime credential manager. Type: string (or
         Expression with resultType string).
        :type azurepostgresql_encrypted_credential: object
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: LinkedServiceResource or the result of cls(response)
        :rtype: ~azure.mgmt.datafactory.models.LinkedServiceResource
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.LinkedServiceResource"]
        error_map = kwargs.pop('error_map', {404: ResourceNotFoundError, 409: ResourceExistsError})

        _linked_service = models.LinkedServiceResource(properties=properties, type=azurepostgresql_type, connect_via=azurepostgresql_connect_via, description=azurepostgresql_description, parameters=azurepostgresql_parameters, annotations=azurepostgresql_annotations, connection_string=azurepostgresql_connection_string, password=azurepostgresql_password, encrypted_credential=azurepostgresql_encrypted_credential)
        api_version = "2018-06-01"
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.create_or_update_azurepostgresql.metadata['url']
        path_format_arguments = {
            'subscriptionId': self._serialize.url("self._config.subscription_id", self._config.subscription_id, 'str'),
            'resourceGroupName': self._serialize.url("resource_group_name", resource_group_name, 'str', max_length=90, min_length=1, pattern=r'^[-\w\._\(\)]+$'),
            'factoryName': self._serialize.url("factory_name", factory_name, 'str', max_length=63, min_length=3, pattern=r'^[A-Za-z0-9]+(?:-[A-Za-z0-9]+)*$'),
            'linkedServiceName': self._serialize.url("linked_service_name", linked_service_name, 'str', max_length=260, min_length=1, pattern=r'^[A-Za-z0-9_][^<>*#.%&:\\+?/]*$'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = 'application/json'

        # Construct and send request
        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_linked_service, 'LinkedServiceResource')
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = self._deserialize('LinkedServiceResource', pipeline_response)

        if cls:
          return cls(pipeline_response, deserialized, {})

        return deserialized
    create_or_update_azurepostgresql.metadata = {'url': '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataFactory/factories/{factoryName}/linkedservices/{linkedServiceName}'}

    def create_or_update_azuresearch(
        self,
        resource_group_name,  # type: str
        factory_name,  # type: str
        linked_service_name,  # type: str
        azuresearch_type,  # type: str
        azuresearch_url,  # type: object
        if_match=None,  # type: Optional[str]
        azuresearch_connect_via=None,  # type: Optional["models.IntegrationRuntimeReference"]
        azuresearch_description=None,  # type: Optional[str]
        azuresearch_parameters=None,  # type: Optional[Dict[str, "ParameterSpecification"]]
        azuresearch_annotations=None,  # type: Optional[List[object]]
        azuresearch_key=None,  # type: Optional["models.SecretBase"]
        azuresearch_encrypted_credential=None,  # type: Optional[object]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.LinkedServiceResource"
        """Creates or updates a linked service.

        :param resource_group_name: The resource group name.
        :type resource_group_name: str
        :param factory_name: The factory name.
        :type factory_name: str
        :param linked_service_name: The linked service name.
        :type linked_service_name: str
        :param azuresearch_type: Type of linked service.
        :type azuresearch_type: str
        :param azuresearch_url: URL for Azure Search service. Type: string (or Expression with
         resultType string).
        :type azuresearch_url: object
        :param if_match: ETag of the linkedService entity.  Should only be specified for update, for
         which it should match existing entity or can be * for unconditional update.
        :type if_match: str
        :param azuresearch_connect_via: The integration runtime reference.
        :type azuresearch_connect_via: ~azure.mgmt.datafactory.models.IntegrationRuntimeReference
        :param azuresearch_description: Linked service description.
        :type azuresearch_description: str
        :param azuresearch_parameters: Parameters for linked service.
        :type azuresearch_parameters: dict[str, ~azure.mgmt.datafactory.models.ParameterSpecification]
        :param azuresearch_annotations: List of tags that can be used for describing the linked
         service.
        :type azuresearch_annotations: list[object]
        :param azuresearch_key: Admin Key for Azure Search service.
        :type azuresearch_key: ~azure.mgmt.datafactory.models.SecretBase
        :param azuresearch_encrypted_credential: The encrypted credential used for authentication.
         Credentials are encrypted using the integration runtime credential manager. Type: string (or
         Expression with resultType string).
        :type azuresearch_encrypted_credential: object
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: LinkedServiceResource or the result of cls(response)
        :rtype: ~azure.mgmt.datafactory.models.LinkedServiceResource
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.LinkedServiceResource"]
        error_map = kwargs.pop('error_map', {404: ResourceNotFoundError, 409: ResourceExistsError})

        _linked_service = models.LinkedServiceResource(properties=properties, type=azuresearch_type, connect_via=azuresearch_connect_via, description=azuresearch_description, parameters=azuresearch_parameters, annotations=azuresearch_annotations, url=azuresearch_url, key=azuresearch_key, encrypted_credential=azuresearch_encrypted_credential)
        api_version = "2018-06-01"
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.create_or_update_azuresearch.metadata['url']
        path_format_arguments = {
            'subscriptionId': self._serialize.url("self._config.subscription_id", self._config.subscription_id, 'str'),
            'resourceGroupName': self._serialize.url("resource_group_name", resource_group_name, 'str', max_length=90, min_length=1, pattern=r'^[-\w\._\(\)]+$'),
            'factoryName': self._serialize.url("factory_name", factory_name, 'str', max_length=63, min_length=3, pattern=r'^[A-Za-z0-9]+(?:-[A-Za-z0-9]+)*$'),
            'linkedServiceName': self._serialize.url("linked_service_name", linked_service_name, 'str', max_length=260, min_length=1, pattern=r'^[A-Za-z0-9_][^<>*#.%&:\\+?/]*$'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = 'application/json'

        # Construct and send request
        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_linked_service, 'LinkedServiceResource')
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = self._deserialize('LinkedServiceResource', pipeline_response)

        if cls:
          return cls(pipeline_response, deserialized, {})

        return deserialized
    create_or_update_azuresearch.metadata = {'url': '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataFactory/factories/{factoryName}/linkedservices/{linkedServiceName}'}

    def create_or_update_azuresqldw(
        self,
        resource_group_name,  # type: str
        factory_name,  # type: str
        linked_service_name,  # type: str
        azuresqldw_type,  # type: str
        azuresqldw_connection_string,  # type: object
        if_match=None,  # type: Optional[str]
        azuresqldw_connect_via=None,  # type: Optional["models.IntegrationRuntimeReference"]
        azuresqldw_description=None,  # type: Optional[str]
        azuresqldw_parameters=None,  # type: Optional[Dict[str, "ParameterSpecification"]]
        azuresqldw_annotations=None,  # type: Optional[List[object]]
        azuresqldw_password=None,  # type: Optional["models.AzureKeyVaultSecretReference"]
        azuresqldw_service_principal_id=None,  # type: Optional[object]
        azuresqldw_service_principal_key=None,  # type: Optional["models.SecretBase"]
        azuresqldw_tenant=None,  # type: Optional[object]
        azuresqldw_encrypted_credential=None,  # type: Optional[object]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.LinkedServiceResource"
        """Creates or updates a linked service.

        :param resource_group_name: The resource group name.
        :type resource_group_name: str
        :param factory_name: The factory name.
        :type factory_name: str
        :param linked_service_name: The linked service name.
        :type linked_service_name: str
        :param azuresqldw_type: Type of linked service.
        :type azuresqldw_type: str
        :param azuresqldw_connection_string: The connection string. Type: string, SecureString or
         AzureKeyVaultSecretReference. Type: string, SecureString or AzureKeyVaultSecretReference.
        :type azuresqldw_connection_string: object
        :param if_match: ETag of the linkedService entity.  Should only be specified for update, for
         which it should match existing entity or can be * for unconditional update.
        :type if_match: str
        :param azuresqldw_connect_via: The integration runtime reference.
        :type azuresqldw_connect_via: ~azure.mgmt.datafactory.models.IntegrationRuntimeReference
        :param azuresqldw_description: Linked service description.
        :type azuresqldw_description: str
        :param azuresqldw_parameters: Parameters for linked service.
        :type azuresqldw_parameters: dict[str, ~azure.mgmt.datafactory.models.ParameterSpecification]
        :param azuresqldw_annotations: List of tags that can be used for describing the linked service.
        :type azuresqldw_annotations: list[object]
        :param azuresqldw_password: The Azure key vault secret reference of password in connection
         string.
        :type azuresqldw_password: ~azure.mgmt.datafactory.models.AzureKeyVaultSecretReference
        :param azuresqldw_service_principal_id: The ID of the service principal used to authenticate
         against Azure SQL Data Warehouse. Type: string (or Expression with resultType string).
        :type azuresqldw_service_principal_id: object
        :param azuresqldw_service_principal_key: The key of the service principal used to authenticate
         against Azure SQL Data Warehouse.
        :type azuresqldw_service_principal_key: ~azure.mgmt.datafactory.models.SecretBase
        :param azuresqldw_tenant: The name or ID of the tenant to which the service principal belongs.
         Type: string (or Expression with resultType string).
        :type azuresqldw_tenant: object
        :param azuresqldw_encrypted_credential: The encrypted credential used for authentication.
         Credentials are encrypted using the integration runtime credential manager. Type: string (or
         Expression with resultType string).
        :type azuresqldw_encrypted_credential: object
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: LinkedServiceResource or the result of cls(response)
        :rtype: ~azure.mgmt.datafactory.models.LinkedServiceResource
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.LinkedServiceResource"]
        error_map = kwargs.pop('error_map', {404: ResourceNotFoundError, 409: ResourceExistsError})

        _linked_service = models.LinkedServiceResource(properties=properties, type=azuresqldw_type, connect_via=azuresqldw_connect_via, description=azuresqldw_description, parameters=azuresqldw_parameters, annotations=azuresqldw_annotations, connection_string=azuresqldw_connection_string, password=azuresqldw_password, service_principal_id=azuresqldw_service_principal_id, service_principal_key=azuresqldw_service_principal_key, tenant=azuresqldw_tenant, encrypted_credential=azuresqldw_encrypted_credential)
        api_version = "2018-06-01"
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.create_or_update_azuresqldw.metadata['url']
        path_format_arguments = {
            'subscriptionId': self._serialize.url("self._config.subscription_id", self._config.subscription_id, 'str'),
            'resourceGroupName': self._serialize.url("resource_group_name", resource_group_name, 'str', max_length=90, min_length=1, pattern=r'^[-\w\._\(\)]+$'),
            'factoryName': self._serialize.url("factory_name", factory_name, 'str', max_length=63, min_length=3, pattern=r'^[A-Za-z0-9]+(?:-[A-Za-z0-9]+)*$'),
            'linkedServiceName': self._serialize.url("linked_service_name", linked_service_name, 'str', max_length=260, min_length=1, pattern=r'^[A-Za-z0-9_][^<>*#.%&:\\+?/]*$'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = 'application/json'

        # Construct and send request
        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_linked_service, 'LinkedServiceResource')
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = self._deserialize('LinkedServiceResource', pipeline_response)

        if cls:
          return cls(pipeline_response, deserialized, {})

        return deserialized
    create_or_update_azuresqldw.metadata = {'url': '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataFactory/factories/{factoryName}/linkedservices/{linkedServiceName}'}

    def create_or_update_azuresqldatabase(
        self,
        resource_group_name,  # type: str
        factory_name,  # type: str
        linked_service_name,  # type: str
        azuresqldatabase_type,  # type: str
        azuresqldatabase_connection_string,  # type: object
        if_match=None,  # type: Optional[str]
        azuresqldatabase_connect_via=None,  # type: Optional["models.IntegrationRuntimeReference"]
        azuresqldatabase_description=None,  # type: Optional[str]
        azuresqldatabase_parameters=None,  # type: Optional[Dict[str, "ParameterSpecification"]]
        azuresqldatabase_annotations=None,  # type: Optional[List[object]]
        azuresqldatabase_password=None,  # type: Optional["models.AzureKeyVaultSecretReference"]
        azuresqldatabase_service_principal_id=None,  # type: Optional[object]
        azuresqldatabase_service_principal_key=None,  # type: Optional["models.SecretBase"]
        azuresqldatabase_tenant=None,  # type: Optional[object]
        azuresqldatabase_encrypted_credential=None,  # type: Optional[object]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.LinkedServiceResource"
        """Creates or updates a linked service.

        :param resource_group_name: The resource group name.
        :type resource_group_name: str
        :param factory_name: The factory name.
        :type factory_name: str
        :param linked_service_name: The linked service name.
        :type linked_service_name: str
        :param azuresqldatabase_type: Type of linked service.
        :type azuresqldatabase_type: str
        :param azuresqldatabase_connection_string: The connection string. Type: string, SecureString or
         AzureKeyVaultSecretReference.
        :type azuresqldatabase_connection_string: object
        :param if_match: ETag of the linkedService entity.  Should only be specified for update, for
         which it should match existing entity or can be * for unconditional update.
        :type if_match: str
        :param azuresqldatabase_connect_via: The integration runtime reference.
        :type azuresqldatabase_connect_via: ~azure.mgmt.datafactory.models.IntegrationRuntimeReference
        :param azuresqldatabase_description: Linked service description.
        :type azuresqldatabase_description: str
        :param azuresqldatabase_parameters: Parameters for linked service.
        :type azuresqldatabase_parameters: dict[str, ~azure.mgmt.datafactory.models.ParameterSpecification]
        :param azuresqldatabase_annotations: List of tags that can be used for describing the linked
         service.
        :type azuresqldatabase_annotations: list[object]
        :param azuresqldatabase_password: The Azure key vault secret reference of password in
         connection string.
        :type azuresqldatabase_password: ~azure.mgmt.datafactory.models.AzureKeyVaultSecretReference
        :param azuresqldatabase_service_principal_id: The ID of the service principal used to
         authenticate against Azure SQL Database. Type: string (or Expression with resultType string).
        :type azuresqldatabase_service_principal_id: object
        :param azuresqldatabase_service_principal_key: The key of the service principal used to
         authenticate against Azure SQL Database.
        :type azuresqldatabase_service_principal_key: ~azure.mgmt.datafactory.models.SecretBase
        :param azuresqldatabase_tenant: The name or ID of the tenant to which the service principal
         belongs. Type: string (or Expression with resultType string).
        :type azuresqldatabase_tenant: object
        :param azuresqldatabase_encrypted_credential: The encrypted credential used for authentication.
         Credentials are encrypted using the integration runtime credential manager. Type: string (or
         Expression with resultType string).
        :type azuresqldatabase_encrypted_credential: object
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: LinkedServiceResource or the result of cls(response)
        :rtype: ~azure.mgmt.datafactory.models.LinkedServiceResource
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.LinkedServiceResource"]
        error_map = kwargs.pop('error_map', {404: ResourceNotFoundError, 409: ResourceExistsError})

        _linked_service = models.LinkedServiceResource(properties=properties, type=azuresqldatabase_type, connect_via=azuresqldatabase_connect_via, description=azuresqldatabase_description, parameters=azuresqldatabase_parameters, annotations=azuresqldatabase_annotations, connection_string=azuresqldatabase_connection_string, password=azuresqldatabase_password, service_principal_id=azuresqldatabase_service_principal_id, service_principal_key=azuresqldatabase_service_principal_key, tenant=azuresqldatabase_tenant, encrypted_credential=azuresqldatabase_encrypted_credential)
        api_version = "2018-06-01"
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.create_or_update_azuresqldatabase.metadata['url']
        path_format_arguments = {
            'subscriptionId': self._serialize.url("self._config.subscription_id", self._config.subscription_id, 'str'),
            'resourceGroupName': self._serialize.url("resource_group_name", resource_group_name, 'str', max_length=90, min_length=1, pattern=r'^[-\w\._\(\)]+$'),
            'factoryName': self._serialize.url("factory_name", factory_name, 'str', max_length=63, min_length=3, pattern=r'^[A-Za-z0-9]+(?:-[A-Za-z0-9]+)*$'),
            'linkedServiceName': self._serialize.url("linked_service_name", linked_service_name, 'str', max_length=260, min_length=1, pattern=r'^[A-Za-z0-9_][^<>*#.%&:\\+?/]*$'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = 'application/json'

        # Construct and send request
        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_linked_service, 'LinkedServiceResource')
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = self._deserialize('LinkedServiceResource', pipeline_response)

        if cls:
          return cls(pipeline_response, deserialized, {})

        return deserialized
    create_or_update_azuresqldatabase.metadata = {'url': '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataFactory/factories/{factoryName}/linkedservices/{linkedServiceName}'}

    def create_or_update_azuresqlmi(
        self,
        resource_group_name,  # type: str
        factory_name,  # type: str
        linked_service_name,  # type: str
        azuresqlmi_type,  # type: str
        azuresqlmi_connection_string,  # type: object
        if_match=None,  # type: Optional[str]
        azuresqlmi_connect_via=None,  # type: Optional["models.IntegrationRuntimeReference"]
        azuresqlmi_description=None,  # type: Optional[str]
        azuresqlmi_parameters=None,  # type: Optional[Dict[str, "ParameterSpecification"]]
        azuresqlmi_annotations=None,  # type: Optional[List[object]]
        azuresqlmi_password=None,  # type: Optional["models.AzureKeyVaultSecretReference"]
        azuresqlmi_service_principal_id=None,  # type: Optional[object]
        azuresqlmi_service_principal_key=None,  # type: Optional["models.SecretBase"]
        azuresqlmi_tenant=None,  # type: Optional[object]
        azuresqlmi_encrypted_credential=None,  # type: Optional[object]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.LinkedServiceResource"
        """Creates or updates a linked service.

        :param resource_group_name: The resource group name.
        :type resource_group_name: str
        :param factory_name: The factory name.
        :type factory_name: str
        :param linked_service_name: The linked service name.
        :type linked_service_name: str
        :param azuresqlmi_type: Type of linked service.
        :type azuresqlmi_type: str
        :param azuresqlmi_connection_string: The connection string. Type: string, SecureString or
         AzureKeyVaultSecretReference.
        :type azuresqlmi_connection_string: object
        :param if_match: ETag of the linkedService entity.  Should only be specified for update, for
         which it should match existing entity or can be * for unconditional update.
        :type if_match: str
        :param azuresqlmi_connect_via: The integration runtime reference.
        :type azuresqlmi_connect_via: ~azure.mgmt.datafactory.models.IntegrationRuntimeReference
        :param azuresqlmi_description: Linked service description.
        :type azuresqlmi_description: str
        :param azuresqlmi_parameters: Parameters for linked service.
        :type azuresqlmi_parameters: dict[str, ~azure.mgmt.datafactory.models.ParameterSpecification]
        :param azuresqlmi_annotations: List of tags that can be used for describing the linked service.
        :type azuresqlmi_annotations: list[object]
        :param azuresqlmi_password: The Azure key vault secret reference of password in connection
         string.
        :type azuresqlmi_password: ~azure.mgmt.datafactory.models.AzureKeyVaultSecretReference
        :param azuresqlmi_service_principal_id: The ID of the service principal used to authenticate
         against Azure SQL Managed Instance. Type: string (or Expression with resultType string).
        :type azuresqlmi_service_principal_id: object
        :param azuresqlmi_service_principal_key: The key of the service principal used to authenticate
         against Azure SQL Managed Instance.
        :type azuresqlmi_service_principal_key: ~azure.mgmt.datafactory.models.SecretBase
        :param azuresqlmi_tenant: The name or ID of the tenant to which the service principal belongs.
         Type: string (or Expression with resultType string).
        :type azuresqlmi_tenant: object
        :param azuresqlmi_encrypted_credential: The encrypted credential used for authentication.
         Credentials are encrypted using the integration runtime credential manager. Type: string (or
         Expression with resultType string).
        :type azuresqlmi_encrypted_credential: object
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: LinkedServiceResource or the result of cls(response)
        :rtype: ~azure.mgmt.datafactory.models.LinkedServiceResource
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.LinkedServiceResource"]
        error_map = kwargs.pop('error_map', {404: ResourceNotFoundError, 409: ResourceExistsError})

        _linked_service = models.LinkedServiceResource(properties=properties, type=azuresqlmi_type, connect_via=azuresqlmi_connect_via, description=azuresqlmi_description, parameters=azuresqlmi_parameters, annotations=azuresqlmi_annotations, connection_string=azuresqlmi_connection_string, password=azuresqlmi_password, service_principal_id=azuresqlmi_service_principal_id, service_principal_key=azuresqlmi_service_principal_key, tenant=azuresqlmi_tenant, encrypted_credential=azuresqlmi_encrypted_credential)
        api_version = "2018-06-01"
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.create_or_update_azuresqlmi.metadata['url']
        path_format_arguments = {
            'subscriptionId': self._serialize.url("self._config.subscription_id", self._config.subscription_id, 'str'),
            'resourceGroupName': self._serialize.url("resource_group_name", resource_group_name, 'str', max_length=90, min_length=1, pattern=r'^[-\w\._\(\)]+$'),
            'factoryName': self._serialize.url("factory_name", factory_name, 'str', max_length=63, min_length=3, pattern=r'^[A-Za-z0-9]+(?:-[A-Za-z0-9]+)*$'),
            'linkedServiceName': self._serialize.url("linked_service_name", linked_service_name, 'str', max_length=260, min_length=1, pattern=r'^[A-Za-z0-9_][^<>*#.%&:\\+?/]*$'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = 'application/json'

        # Construct and send request
        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_linked_service, 'LinkedServiceResource')
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = self._deserialize('LinkedServiceResource', pipeline_response)

        if cls:
          return cls(pipeline_response, deserialized, {})

        return deserialized
    create_or_update_azuresqlmi.metadata = {'url': '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataFactory/factories/{factoryName}/linkedservices/{linkedServiceName}'}

    def create_or_update_azurestorage(
        self,
        resource_group_name,  # type: str
        factory_name,  # type: str
        linked_service_name,  # type: str
        azurestorage_type,  # type: str
        if_match=None,  # type: Optional[str]
        azurestorage_connect_via=None,  # type: Optional["models.IntegrationRuntimeReference"]
        azurestorage_description=None,  # type: Optional[str]
        azurestorage_parameters=None,  # type: Optional[Dict[str, "ParameterSpecification"]]
        azurestorage_annotations=None,  # type: Optional[List[object]]
        azurestorage_connection_string=None,  # type: Optional[object]
        azurestorage_account_key=None,  # type: Optional["models.AzureKeyVaultSecretReference"]
        azurestorage_sas_uri=None,  # type: Optional[object]
        azurestorage_sas_token=None,  # type: Optional["models.AzureKeyVaultSecretReference"]
        azurestorage_encrypted_credential=None,  # type: Optional[str]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.LinkedServiceResource"
        """Creates or updates a linked service.

        :param resource_group_name: The resource group name.
        :type resource_group_name: str
        :param factory_name: The factory name.
        :type factory_name: str
        :param linked_service_name: The linked service name.
        :type linked_service_name: str
        :param azurestorage_type: Type of linked service.
        :type azurestorage_type: str
        :param if_match: ETag of the linkedService entity.  Should only be specified for update, for
         which it should match existing entity or can be * for unconditional update.
        :type if_match: str
        :param azurestorage_connect_via: The integration runtime reference.
        :type azurestorage_connect_via: ~azure.mgmt.datafactory.models.IntegrationRuntimeReference
        :param azurestorage_description: Linked service description.
        :type azurestorage_description: str
        :param azurestorage_parameters: Parameters for linked service.
        :type azurestorage_parameters: dict[str, ~azure.mgmt.datafactory.models.ParameterSpecification]
        :param azurestorage_annotations: List of tags that can be used for describing the linked
         service.
        :type azurestorage_annotations: list[object]
        :param azurestorage_connection_string: The connection string. It is mutually exclusive with
         sasUri property. Type: string, SecureString or AzureKeyVaultSecretReference.
        :type azurestorage_connection_string: object
        :param azurestorage_account_key: The Azure key vault secret reference of accountKey in
         connection string.
        :type azurestorage_account_key: ~azure.mgmt.datafactory.models.AzureKeyVaultSecretReference
        :param azurestorage_sas_uri: SAS URI of the Azure Storage resource. It is mutually exclusive
         with connectionString property. Type: string, SecureString or AzureKeyVaultSecretReference.
        :type azurestorage_sas_uri: object
        :param azurestorage_sas_token: The Azure key vault secret reference of sasToken in sas uri.
        :type azurestorage_sas_token: ~azure.mgmt.datafactory.models.AzureKeyVaultSecretReference
        :param azurestorage_encrypted_credential: The encrypted credential used for authentication.
         Credentials are encrypted using the integration runtime credential manager. Type: string (or
         Expression with resultType string).
        :type azurestorage_encrypted_credential: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: LinkedServiceResource or the result of cls(response)
        :rtype: ~azure.mgmt.datafactory.models.LinkedServiceResource
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.LinkedServiceResource"]
        error_map = kwargs.pop('error_map', {404: ResourceNotFoundError, 409: ResourceExistsError})

        _linked_service = models.LinkedServiceResource(properties=properties, type=azurestorage_type, connect_via=azurestorage_connect_via, description=azurestorage_description, parameters=azurestorage_parameters, annotations=azurestorage_annotations, connection_string=azurestorage_connection_string, account_key=azurestorage_account_key, sas_uri=azurestorage_sas_uri, sas_token=azurestorage_sas_token, encrypted_credential=azurestorage_encrypted_credential)
        api_version = "2018-06-01"
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.create_or_update_azurestorage.metadata['url']
        path_format_arguments = {
            'subscriptionId': self._serialize.url("self._config.subscription_id", self._config.subscription_id, 'str'),
            'resourceGroupName': self._serialize.url("resource_group_name", resource_group_name, 'str', max_length=90, min_length=1, pattern=r'^[-\w\._\(\)]+$'),
            'factoryName': self._serialize.url("factory_name", factory_name, 'str', max_length=63, min_length=3, pattern=r'^[A-Za-z0-9]+(?:-[A-Za-z0-9]+)*$'),
            'linkedServiceName': self._serialize.url("linked_service_name", linked_service_name, 'str', max_length=260, min_length=1, pattern=r'^[A-Za-z0-9_][^<>*#.%&:\\+?/]*$'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = 'application/json'

        # Construct and send request
        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_linked_service, 'LinkedServiceResource')
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = self._deserialize('LinkedServiceResource', pipeline_response)

        if cls:
          return cls(pipeline_response, deserialized, {})

        return deserialized
    create_or_update_azurestorage.metadata = {'url': '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataFactory/factories/{factoryName}/linkedservices/{linkedServiceName}'}

    def create_or_update_azuretablestorage(
        self,
        resource_group_name,  # type: str
        factory_name,  # type: str
        linked_service_name,  # type: str
        azuretablestorage_type,  # type: str
        if_match=None,  # type: Optional[str]
        azuretablestorage_connect_via=None,  # type: Optional["models.IntegrationRuntimeReference"]
        azuretablestorage_description=None,  # type: Optional[str]
        azuretablestorage_parameters=None,  # type: Optional[Dict[str, "ParameterSpecification"]]
        azuretablestorage_annotations=None,  # type: Optional[List[object]]
        azuretablestorage_connection_string=None,  # type: Optional[object]
        azuretablestorage_account_key=None,  # type: Optional["models.AzureKeyVaultSecretReference"]
        azuretablestorage_sas_uri=None,  # type: Optional[object]
        azuretablestorage_sas_token=None,  # type: Optional["models.AzureKeyVaultSecretReference"]
        azuretablestorage_encrypted_credential=None,  # type: Optional[str]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.LinkedServiceResource"
        """Creates or updates a linked service.

        :param resource_group_name: The resource group name.
        :type resource_group_name: str
        :param factory_name: The factory name.
        :type factory_name: str
        :param linked_service_name: The linked service name.
        :type linked_service_name: str
        :param azuretablestorage_type: Type of linked service.
        :type azuretablestorage_type: str
        :param if_match: ETag of the linkedService entity.  Should only be specified for update, for
         which it should match existing entity or can be * for unconditional update.
        :type if_match: str
        :param azuretablestorage_connect_via: The integration runtime reference.
        :type azuretablestorage_connect_via: ~azure.mgmt.datafactory.models.IntegrationRuntimeReference
        :param azuretablestorage_description: Linked service description.
        :type azuretablestorage_description: str
        :param azuretablestorage_parameters: Parameters for linked service.
        :type azuretablestorage_parameters: dict[str, ~azure.mgmt.datafactory.models.ParameterSpecification]
        :param azuretablestorage_annotations: List of tags that can be used for describing the linked
         service.
        :type azuretablestorage_annotations: list[object]
        :param azuretablestorage_connection_string: The connection string. It is mutually exclusive
         with sasUri property. Type: string, SecureString or AzureKeyVaultSecretReference.
        :type azuretablestorage_connection_string: object
        :param azuretablestorage_account_key: The Azure key vault secret reference of accountKey in
         connection string.
        :type azuretablestorage_account_key: ~azure.mgmt.datafactory.models.AzureKeyVaultSecretReference
        :param azuretablestorage_sas_uri: SAS URI of the Azure Storage resource. It is mutually
         exclusive with connectionString property. Type: string, SecureString or
         AzureKeyVaultSecretReference.
        :type azuretablestorage_sas_uri: object
        :param azuretablestorage_sas_token: The Azure key vault secret reference of sasToken in sas
         uri.
        :type azuretablestorage_sas_token: ~azure.mgmt.datafactory.models.AzureKeyVaultSecretReference
        :param azuretablestorage_encrypted_credential: The encrypted credential used for
         authentication. Credentials are encrypted using the integration runtime credential manager.
         Type: string (or Expression with resultType string).
        :type azuretablestorage_encrypted_credential: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: LinkedServiceResource or the result of cls(response)
        :rtype: ~azure.mgmt.datafactory.models.LinkedServiceResource
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.LinkedServiceResource"]
        error_map = kwargs.pop('error_map', {404: ResourceNotFoundError, 409: ResourceExistsError})

        _linked_service = models.LinkedServiceResource(properties=properties, type=azuretablestorage_type, connect_via=azuretablestorage_connect_via, description=azuretablestorage_description, parameters=azuretablestorage_parameters, annotations=azuretablestorage_annotations, connection_string=azuretablestorage_connection_string, account_key=azuretablestorage_account_key, sas_uri=azuretablestorage_sas_uri, sas_token=azuretablestorage_sas_token, encrypted_credential=azuretablestorage_encrypted_credential)
        api_version = "2018-06-01"
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.create_or_update_azuretablestorage.metadata['url']
        path_format_arguments = {
            'subscriptionId': self._serialize.url("self._config.subscription_id", self._config.subscription_id, 'str'),
            'resourceGroupName': self._serialize.url("resource_group_name", resource_group_name, 'str', max_length=90, min_length=1, pattern=r'^[-\w\._\(\)]+$'),
            'factoryName': self._serialize.url("factory_name", factory_name, 'str', max_length=63, min_length=3, pattern=r'^[A-Za-z0-9]+(?:-[A-Za-z0-9]+)*$'),
            'linkedServiceName': self._serialize.url("linked_service_name", linked_service_name, 'str', max_length=260, min_length=1, pattern=r'^[A-Za-z0-9_][^<>*#.%&:\\+?/]*$'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = 'application/json'

        # Construct and send request
        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_linked_service, 'LinkedServiceResource')
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = self._deserialize('LinkedServiceResource', pipeline_response)

        if cls:
          return cls(pipeline_response, deserialized, {})

        return deserialized
    create_or_update_azuretablestorage.metadata = {'url': '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataFactory/factories/{factoryName}/linkedservices/{linkedServiceName}'}

    def create_or_update_cassandra(
        self,
        resource_group_name,  # type: str
        factory_name,  # type: str
        linked_service_name,  # type: str
        cassandra_type,  # type: str
        cassandra_host,  # type: object
        if_match=None,  # type: Optional[str]
        cassandra_connect_via=None,  # type: Optional["models.IntegrationRuntimeReference"]
        cassandra_description=None,  # type: Optional[str]
        cassandra_parameters=None,  # type: Optional[Dict[str, "ParameterSpecification"]]
        cassandra_annotations=None,  # type: Optional[List[object]]
        cassandra_authentication_type=None,  # type: Optional[object]
        cassandra_port=None,  # type: Optional[object]
        cassandra_username=None,  # type: Optional[object]
        cassandra_password=None,  # type: Optional["models.SecretBase"]
        cassandra_encrypted_credential=None,  # type: Optional[object]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.LinkedServiceResource"
        """Creates or updates a linked service.

        :param resource_group_name: The resource group name.
        :type resource_group_name: str
        :param factory_name: The factory name.
        :type factory_name: str
        :param linked_service_name: The linked service name.
        :type linked_service_name: str
        :param cassandra_type: Type of linked service.
        :type cassandra_type: str
        :param cassandra_host: Host name for connection. Type: string (or Expression with resultType
         string).
        :type cassandra_host: object
        :param if_match: ETag of the linkedService entity.  Should only be specified for update, for
         which it should match existing entity or can be * for unconditional update.
        :type if_match: str
        :param cassandra_connect_via: The integration runtime reference.
        :type cassandra_connect_via: ~azure.mgmt.datafactory.models.IntegrationRuntimeReference
        :param cassandra_description: Linked service description.
        :type cassandra_description: str
        :param cassandra_parameters: Parameters for linked service.
        :type cassandra_parameters: dict[str, ~azure.mgmt.datafactory.models.ParameterSpecification]
        :param cassandra_annotations: List of tags that can be used for describing the linked service.
        :type cassandra_annotations: list[object]
        :param cassandra_authentication_type: AuthenticationType to be used for connection. Type:
         string (or Expression with resultType string).
        :type cassandra_authentication_type: object
        :param cassandra_port: The port for the connection. Type: integer (or Expression with
         resultType integer).
        :type cassandra_port: object
        :param cassandra_username: Username for authentication. Type: string (or Expression with
         resultType string).
        :type cassandra_username: object
        :param cassandra_password: Password for authentication.
        :type cassandra_password: ~azure.mgmt.datafactory.models.SecretBase
        :param cassandra_encrypted_credential: The encrypted credential used for authentication.
         Credentials are encrypted using the integration runtime credential manager. Type: string (or
         Expression with resultType string).
        :type cassandra_encrypted_credential: object
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: LinkedServiceResource or the result of cls(response)
        :rtype: ~azure.mgmt.datafactory.models.LinkedServiceResource
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.LinkedServiceResource"]
        error_map = kwargs.pop('error_map', {404: ResourceNotFoundError, 409: ResourceExistsError})

        _linked_service = models.LinkedServiceResource(properties=properties, type=cassandra_type, connect_via=cassandra_connect_via, description=cassandra_description, parameters=cassandra_parameters, annotations=cassandra_annotations, host=cassandra_host, authentication_type=cassandra_authentication_type, port=cassandra_port, username=cassandra_username, password=cassandra_password, encrypted_credential=cassandra_encrypted_credential)
        api_version = "2018-06-01"
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.create_or_update_cassandra.metadata['url']
        path_format_arguments = {
            'subscriptionId': self._serialize.url("self._config.subscription_id", self._config.subscription_id, 'str'),
            'resourceGroupName': self._serialize.url("resource_group_name", resource_group_name, 'str', max_length=90, min_length=1, pattern=r'^[-\w\._\(\)]+$'),
            'factoryName': self._serialize.url("factory_name", factory_name, 'str', max_length=63, min_length=3, pattern=r'^[A-Za-z0-9]+(?:-[A-Za-z0-9]+)*$'),
            'linkedServiceName': self._serialize.url("linked_service_name", linked_service_name, 'str', max_length=260, min_length=1, pattern=r'^[A-Za-z0-9_][^<>*#.%&:\\+?/]*$'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = 'application/json'

        # Construct and send request
        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_linked_service, 'LinkedServiceResource')
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = self._deserialize('LinkedServiceResource', pipeline_response)

        if cls:
          return cls(pipeline_response, deserialized, {})

        return deserialized
    create_or_update_cassandra.metadata = {'url': '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataFactory/factories/{factoryName}/linkedservices/{linkedServiceName}'}

    def create_or_update_commondataserviceforapps(
        self,
        resource_group_name,  # type: str
        factory_name,  # type: str
        linked_service_name,  # type: str
        commondataserviceforapps_type,  # type: str
        commondataserviceforapps_deployment_type,  # type: Union[str, "models.DynamicsDeploymentType"]
        commondataserviceforapps_authentication_type,  # type: Union[str, "models.DynamicsAuthenticationType"]
        if_match=None,  # type: Optional[str]
        commondataserviceforapps_connect_via=None,  # type: Optional["models.IntegrationRuntimeReference"]
        commondataserviceforapps_description=None,  # type: Optional[str]
        commondataserviceforapps_parameters=None,  # type: Optional[Dict[str, "ParameterSpecification"]]
        commondataserviceforapps_annotations=None,  # type: Optional[List[object]]
        commondataserviceforapps_host_name=None,  # type: Optional[object]
        commondataserviceforapps_port=None,  # type: Optional[object]
        commondataserviceforapps_service_uri=None,  # type: Optional[object]
        commondataserviceforapps_organization_name=None,  # type: Optional[object]
        commondataserviceforapps_username=None,  # type: Optional[object]
        commondataserviceforapps_password=None,  # type: Optional["models.SecretBase"]
        commondataserviceforapps_service_principal_id=None,  # type: Optional[object]
        commondataserviceforapps_service_principal_credential_type=None,  # type: Optional[Union[str, "models.DynamicsServicePrincipalCredentialType"]]
        commondataserviceforapps_service_principal_credential=None,  # type: Optional["models.SecretBase"]
        commondataserviceforapps_encrypted_credential=None,  # type: Optional[object]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.LinkedServiceResource"
        """Creates or updates a linked service.

        :param resource_group_name: The resource group name.
        :type resource_group_name: str
        :param factory_name: The factory name.
        :type factory_name: str
        :param linked_service_name: The linked service name.
        :type linked_service_name: str
        :param commondataserviceforapps_type: Type of linked service.
        :type commondataserviceforapps_type: str
        :param commondataserviceforapps_deployment_type: The deployment type of the Common Data Service
         for Apps instance. 'Online' for Common Data Service for Apps Online and 'OnPremisesWithIfd' for
         Common Data Service for Apps on-premises with Ifd. Type: string (or Expression with resultType
         string).
        :type commondataserviceforapps_deployment_type: str or ~azure.mgmt.datafactory.models.DynamicsDeploymentType
        :param commondataserviceforapps_authentication_type: The authentication type to connect to
         Common Data Service for Apps server. 'Office365' for online scenario, 'Ifd' for on-premises
         with Ifd scenario. 'AADServicePrincipal' for Server-To-Server authentication in online
         scenario. Type: string (or Expression with resultType string).
        :type commondataserviceforapps_authentication_type: str or ~azure.mgmt.datafactory.models.DynamicsAuthenticationType
        :param if_match: ETag of the linkedService entity.  Should only be specified for update, for
         which it should match existing entity or can be * for unconditional update.
        :type if_match: str
        :param commondataserviceforapps_connect_via: The integration runtime reference.
        :type commondataserviceforapps_connect_via: ~azure.mgmt.datafactory.models.IntegrationRuntimeReference
        :param commondataserviceforapps_description: Linked service description.
        :type commondataserviceforapps_description: str
        :param commondataserviceforapps_parameters: Parameters for linked service.
        :type commondataserviceforapps_parameters: dict[str, ~azure.mgmt.datafactory.models.ParameterSpecification]
        :param commondataserviceforapps_annotations: List of tags that can be used for describing the
         linked service.
        :type commondataserviceforapps_annotations: list[object]
        :param commondataserviceforapps_host_name: The host name of the on-premises Common Data Service
         for Apps server. The property is required for on-prem and not allowed for online. Type: string
         (or Expression with resultType string).
        :type commondataserviceforapps_host_name: object
        :param commondataserviceforapps_port: The port of on-premises Common Data Service for Apps
         server. The property is required for on-prem and not allowed for online. Default is 443. Type:
         integer (or Expression with resultType integer), minimum: 0.
        :type commondataserviceforapps_port: object
        :param commondataserviceforapps_service_uri: The URL to the Microsoft Common Data Service for
         Apps server. The property is required for on-line and not allowed for on-prem. Type: string (or
         Expression with resultType string).
        :type commondataserviceforapps_service_uri: object
        :param commondataserviceforapps_organization_name: The organization name of the Common Data
         Service for Apps instance. The property is required for on-prem and required for online when
         there are more than one Common Data Service for Apps instances associated with the user. Type:
         string (or Expression with resultType string).
        :type commondataserviceforapps_organization_name: object
        :param commondataserviceforapps_username: User name to access the Common Data Service for Apps
         instance. Type: string (or Expression with resultType string).
        :type commondataserviceforapps_username: object
        :param commondataserviceforapps_password: Password to access the Common Data Service for Apps
         instance.
        :type commondataserviceforapps_password: ~azure.mgmt.datafactory.models.SecretBase
        :param commondataserviceforapps_service_principal_id: The client ID of the application in Azure
         Active Directory used for Server-To-Server authentication. Type: string (or Expression with
         resultType string).
        :type commondataserviceforapps_service_principal_id: object
        :param commondataserviceforapps_service_principal_credential_type: The service principal
         credential type to use in Server-To-Server authentication. 'ServicePrincipalKey' for
         key/secret, 'ServicePrincipalCert' for certificate. Type: string (or Expression with resultType
         string).
        :type commondataserviceforapps_service_principal_credential_type: str or ~azure.mgmt.datafactory.models.DynamicsServicePrincipalCredentialType
        :param commondataserviceforapps_service_principal_credential: The credential of the service
         principal object in Azure Active Directory. If servicePrincipalCredentialType is
         'ServicePrincipalKey', servicePrincipalCredential can be SecureString or
         AzureKeyVaultSecretReference. If servicePrincipalCredentialType is 'ServicePrincipalCert',
         servicePrincipalCredential can only be AzureKeyVaultSecretReference.
        :type commondataserviceforapps_service_principal_credential: ~azure.mgmt.datafactory.models.SecretBase
        :param commondataserviceforapps_encrypted_credential: The encrypted credential used for
         authentication. Credentials are encrypted using the integration runtime credential manager.
         Type: string (or Expression with resultType string).
        :type commondataserviceforapps_encrypted_credential: object
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: LinkedServiceResource or the result of cls(response)
        :rtype: ~azure.mgmt.datafactory.models.LinkedServiceResource
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.LinkedServiceResource"]
        error_map = kwargs.pop('error_map', {404: ResourceNotFoundError, 409: ResourceExistsError})

        _linked_service = models.LinkedServiceResource(properties=properties, type=commondataserviceforapps_type, connect_via=commondataserviceforapps_connect_via, description=commondataserviceforapps_description, parameters=commondataserviceforapps_parameters, annotations=commondataserviceforapps_annotations, deployment_type=commondataserviceforapps_deployment_type, host_name=commondataserviceforapps_host_name, port=commondataserviceforapps_port, service_uri=commondataserviceforapps_service_uri, organization_name=commondataserviceforapps_organization_name, authentication_type=commondataserviceforapps_authentication_type, username=commondataserviceforapps_username, password=commondataserviceforapps_password, service_principal_id=commondataserviceforapps_service_principal_id, service_principal_credential_type=commondataserviceforapps_service_principal_credential_type, service_principal_credential=commondataserviceforapps_service_principal_credential, encrypted_credential=commondataserviceforapps_encrypted_credential)
        api_version = "2018-06-01"
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.create_or_update_commondataserviceforapps.metadata['url']
        path_format_arguments = {
            'subscriptionId': self._serialize.url("self._config.subscription_id", self._config.subscription_id, 'str'),
            'resourceGroupName': self._serialize.url("resource_group_name", resource_group_name, 'str', max_length=90, min_length=1, pattern=r'^[-\w\._\(\)]+$'),
            'factoryName': self._serialize.url("factory_name", factory_name, 'str', max_length=63, min_length=3, pattern=r'^[A-Za-z0-9]+(?:-[A-Za-z0-9]+)*$'),
            'linkedServiceName': self._serialize.url("linked_service_name", linked_service_name, 'str', max_length=260, min_length=1, pattern=r'^[A-Za-z0-9_][^<>*#.%&:\\+?/]*$'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = 'application/json'

        # Construct and send request
        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_linked_service, 'LinkedServiceResource')
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = self._deserialize('LinkedServiceResource', pipeline_response)

        if cls:
          return cls(pipeline_response, deserialized, {})

        return deserialized
    create_or_update_commondataserviceforapps.metadata = {'url': '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataFactory/factories/{factoryName}/linkedservices/{linkedServiceName}'}

    def create_or_update_concur(
        self,
        resource_group_name,  # type: str
        factory_name,  # type: str
        linked_service_name,  # type: str
        concur_type,  # type: str
        concur_client_id,  # type: object
        concur_username,  # type: object
        if_match=None,  # type: Optional[str]
        concur_connect_via=None,  # type: Optional["models.IntegrationRuntimeReference"]
        concur_description=None,  # type: Optional[str]
        concur_parameters=None,  # type: Optional[Dict[str, "ParameterSpecification"]]
        concur_annotations=None,  # type: Optional[List[object]]
        concur_password=None,  # type: Optional["models.SecretBase"]
        concur_use_encrypted_endpoints=None,  # type: Optional[object]
        concur_use_host_verification=None,  # type: Optional[object]
        concur_use_peer_verification=None,  # type: Optional[object]
        concur_encrypted_credential=None,  # type: Optional[object]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.LinkedServiceResource"
        """Creates or updates a linked service.

        :param resource_group_name: The resource group name.
        :type resource_group_name: str
        :param factory_name: The factory name.
        :type factory_name: str
        :param linked_service_name: The linked service name.
        :type linked_service_name: str
        :param concur_type: Type of linked service.
        :type concur_type: str
        :param concur_client_id: Application client_id supplied by Concur App Management.
        :type concur_client_id: object
        :param concur_username: The user name that you use to access Concur Service.
        :type concur_username: object
        :param if_match: ETag of the linkedService entity.  Should only be specified for update, for
         which it should match existing entity or can be * for unconditional update.
        :type if_match: str
        :param concur_connect_via: The integration runtime reference.
        :type concur_connect_via: ~azure.mgmt.datafactory.models.IntegrationRuntimeReference
        :param concur_description: Linked service description.
        :type concur_description: str
        :param concur_parameters: Parameters for linked service.
        :type concur_parameters: dict[str, ~azure.mgmt.datafactory.models.ParameterSpecification]
        :param concur_annotations: List of tags that can be used for describing the linked service.
        :type concur_annotations: list[object]
        :param concur_password: The password corresponding to the user name that you provided in the
         username field.
        :type concur_password: ~azure.mgmt.datafactory.models.SecretBase
        :param concur_use_encrypted_endpoints: Specifies whether the data source endpoints are
         encrypted using HTTPS. The default value is true.
        :type concur_use_encrypted_endpoints: object
        :param concur_use_host_verification: Specifies whether to require the host name in the server's
         certificate to match the host name of the server when connecting over SSL. The default value is
         true.
        :type concur_use_host_verification: object
        :param concur_use_peer_verification: Specifies whether to verify the identity of the server
         when connecting over SSL. The default value is true.
        :type concur_use_peer_verification: object
        :param concur_encrypted_credential: The encrypted credential used for authentication.
         Credentials are encrypted using the integration runtime credential manager. Type: string (or
         Expression with resultType string).
        :type concur_encrypted_credential: object
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: LinkedServiceResource or the result of cls(response)
        :rtype: ~azure.mgmt.datafactory.models.LinkedServiceResource
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.LinkedServiceResource"]
        error_map = kwargs.pop('error_map', {404: ResourceNotFoundError, 409: ResourceExistsError})

        _linked_service = models.LinkedServiceResource(properties=properties, type=concur_type, connect_via=concur_connect_via, description=concur_description, parameters=concur_parameters, annotations=concur_annotations, client_id=concur_client_id, username=concur_username, password=concur_password, use_encrypted_endpoints=concur_use_encrypted_endpoints, use_host_verification=concur_use_host_verification, use_peer_verification=concur_use_peer_verification, encrypted_credential=concur_encrypted_credential)
        api_version = "2018-06-01"
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.create_or_update_concur.metadata['url']
        path_format_arguments = {
            'subscriptionId': self._serialize.url("self._config.subscription_id", self._config.subscription_id, 'str'),
            'resourceGroupName': self._serialize.url("resource_group_name", resource_group_name, 'str', max_length=90, min_length=1, pattern=r'^[-\w\._\(\)]+$'),
            'factoryName': self._serialize.url("factory_name", factory_name, 'str', max_length=63, min_length=3, pattern=r'^[A-Za-z0-9]+(?:-[A-Za-z0-9]+)*$'),
            'linkedServiceName': self._serialize.url("linked_service_name", linked_service_name, 'str', max_length=260, min_length=1, pattern=r'^[A-Za-z0-9_][^<>*#.%&:\\+?/]*$'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = 'application/json'

        # Construct and send request
        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_linked_service, 'LinkedServiceResource')
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = self._deserialize('LinkedServiceResource', pipeline_response)

        if cls:
          return cls(pipeline_response, deserialized, {})

        return deserialized
    create_or_update_concur.metadata = {'url': '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataFactory/factories/{factoryName}/linkedservices/{linkedServiceName}'}

    def create_or_update_cosmosdb(
        self,
        resource_group_name,  # type: str
        factory_name,  # type: str
        linked_service_name,  # type: str
        cosmosdb_type,  # type: str
        if_match=None,  # type: Optional[str]
        cosmosdb_connect_via=None,  # type: Optional["models.IntegrationRuntimeReference"]
        cosmosdb_description=None,  # type: Optional[str]
        cosmosdb_parameters=None,  # type: Optional[Dict[str, "ParameterSpecification"]]
        cosmosdb_annotations=None,  # type: Optional[List[object]]
        cosmosdb_connection_string=None,  # type: Optional[object]
        cosmosdb_account_endpoint=None,  # type: Optional[object]
        cosmosdb_database=None,  # type: Optional[object]
        cosmosdb_account_key=None,  # type: Optional["models.SecretBase"]
        cosmosdb_encrypted_credential=None,  # type: Optional[object]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.LinkedServiceResource"
        """Creates or updates a linked service.

        :param resource_group_name: The resource group name.
        :type resource_group_name: str
        :param factory_name: The factory name.
        :type factory_name: str
        :param linked_service_name: The linked service name.
        :type linked_service_name: str
        :param cosmosdb_type: Type of linked service.
        :type cosmosdb_type: str
        :param if_match: ETag of the linkedService entity.  Should only be specified for update, for
         which it should match existing entity or can be * for unconditional update.
        :type if_match: str
        :param cosmosdb_connect_via: The integration runtime reference.
        :type cosmosdb_connect_via: ~azure.mgmt.datafactory.models.IntegrationRuntimeReference
        :param cosmosdb_description: Linked service description.
        :type cosmosdb_description: str
        :param cosmosdb_parameters: Parameters for linked service.
        :type cosmosdb_parameters: dict[str, ~azure.mgmt.datafactory.models.ParameterSpecification]
        :param cosmosdb_annotations: List of tags that can be used for describing the linked service.
        :type cosmosdb_annotations: list[object]
        :param cosmosdb_connection_string: The connection string. Type: string, SecureString or
         AzureKeyVaultSecretReference.
        :type cosmosdb_connection_string: object
        :param cosmosdb_account_endpoint: The endpoint of the Azure CosmosDB account. Type: string (or
         Expression with resultType string).
        :type cosmosdb_account_endpoint: object
        :param cosmosdb_database: The name of the database. Type: string (or Expression with resultType
         string).
        :type cosmosdb_database: object
        :param cosmosdb_account_key: The account key of the Azure CosmosDB account. Type: SecureString
         or AzureKeyVaultSecretReference.
        :type cosmosdb_account_key: ~azure.mgmt.datafactory.models.SecretBase
        :param cosmosdb_encrypted_credential: The encrypted credential used for authentication.
         Credentials are encrypted using the integration runtime credential manager. Type: string (or
         Expression with resultType string).
        :type cosmosdb_encrypted_credential: object
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: LinkedServiceResource or the result of cls(response)
        :rtype: ~azure.mgmt.datafactory.models.LinkedServiceResource
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.LinkedServiceResource"]
        error_map = kwargs.pop('error_map', {404: ResourceNotFoundError, 409: ResourceExistsError})

        _linked_service = models.LinkedServiceResource(properties=properties, type=cosmosdb_type, connect_via=cosmosdb_connect_via, description=cosmosdb_description, parameters=cosmosdb_parameters, annotations=cosmosdb_annotations, connection_string=cosmosdb_connection_string, account_endpoint=cosmosdb_account_endpoint, database=cosmosdb_database, account_key=cosmosdb_account_key, encrypted_credential=cosmosdb_encrypted_credential)
        api_version = "2018-06-01"
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.create_or_update_cosmosdb.metadata['url']
        path_format_arguments = {
            'subscriptionId': self._serialize.url("self._config.subscription_id", self._config.subscription_id, 'str'),
            'resourceGroupName': self._serialize.url("resource_group_name", resource_group_name, 'str', max_length=90, min_length=1, pattern=r'^[-\w\._\(\)]+$'),
            'factoryName': self._serialize.url("factory_name", factory_name, 'str', max_length=63, min_length=3, pattern=r'^[A-Za-z0-9]+(?:-[A-Za-z0-9]+)*$'),
            'linkedServiceName': self._serialize.url("linked_service_name", linked_service_name, 'str', max_length=260, min_length=1, pattern=r'^[A-Za-z0-9_][^<>*#.%&:\\+?/]*$'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = 'application/json'

        # Construct and send request
        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_linked_service, 'LinkedServiceResource')
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = self._deserialize('LinkedServiceResource', pipeline_response)

        if cls:
          return cls(pipeline_response, deserialized, {})

        return deserialized
    create_or_update_cosmosdb.metadata = {'url': '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataFactory/factories/{factoryName}/linkedservices/{linkedServiceName}'}

    def create_or_update_cosmosdbmongodbapi(
        self,
        resource_group_name,  # type: str
        factory_name,  # type: str
        linked_service_name,  # type: str
        cosmosdbmongodbapi_type,  # type: str
        cosmosdbmongodbapi_connection_string,  # type: object
        cosmosdbmongodbapi_database,  # type: object
        if_match=None,  # type: Optional[str]
        cosmosdbmongodbapi_connect_via=None,  # type: Optional["models.IntegrationRuntimeReference"]
        cosmosdbmongodbapi_description=None,  # type: Optional[str]
        cosmosdbmongodbapi_parameters=None,  # type: Optional[Dict[str, "ParameterSpecification"]]
        cosmosdbmongodbapi_annotations=None,  # type: Optional[List[object]]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.LinkedServiceResource"
        """Creates or updates a linked service.

        :param resource_group_name: The resource group name.
        :type resource_group_name: str
        :param factory_name: The factory name.
        :type factory_name: str
        :param linked_service_name: The linked service name.
        :type linked_service_name: str
        :param cosmosdbmongodbapi_type: Type of linked service.
        :type cosmosdbmongodbapi_type: str
        :param cosmosdbmongodbapi_connection_string: The CosmosDB (MongoDB API) connection string.
         Type: string, SecureString or AzureKeyVaultSecretReference. Type: string, SecureString or
         AzureKeyVaultSecretReference.
        :type cosmosdbmongodbapi_connection_string: object
        :param cosmosdbmongodbapi_database: The name of the CosmosDB (MongoDB API) database that you
         want to access. Type: string (or Expression with resultType string).
        :type cosmosdbmongodbapi_database: object
        :param if_match: ETag of the linkedService entity.  Should only be specified for update, for
         which it should match existing entity or can be * for unconditional update.
        :type if_match: str
        :param cosmosdbmongodbapi_connect_via: The integration runtime reference.
        :type cosmosdbmongodbapi_connect_via: ~azure.mgmt.datafactory.models.IntegrationRuntimeReference
        :param cosmosdbmongodbapi_description: Linked service description.
        :type cosmosdbmongodbapi_description: str
        :param cosmosdbmongodbapi_parameters: Parameters for linked service.
        :type cosmosdbmongodbapi_parameters: dict[str, ~azure.mgmt.datafactory.models.ParameterSpecification]
        :param cosmosdbmongodbapi_annotations: List of tags that can be used for describing the linked
         service.
        :type cosmosdbmongodbapi_annotations: list[object]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: LinkedServiceResource or the result of cls(response)
        :rtype: ~azure.mgmt.datafactory.models.LinkedServiceResource
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.LinkedServiceResource"]
        error_map = kwargs.pop('error_map', {404: ResourceNotFoundError, 409: ResourceExistsError})

        _linked_service = models.LinkedServiceResource(properties=properties, type=cosmosdbmongodbapi_type, connect_via=cosmosdbmongodbapi_connect_via, description=cosmosdbmongodbapi_description, parameters=cosmosdbmongodbapi_parameters, annotations=cosmosdbmongodbapi_annotations, connection_string=cosmosdbmongodbapi_connection_string, database=cosmosdbmongodbapi_database)
        api_version = "2018-06-01"
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.create_or_update_cosmosdbmongodbapi.metadata['url']
        path_format_arguments = {
            'subscriptionId': self._serialize.url("self._config.subscription_id", self._config.subscription_id, 'str'),
            'resourceGroupName': self._serialize.url("resource_group_name", resource_group_name, 'str', max_length=90, min_length=1, pattern=r'^[-\w\._\(\)]+$'),
            'factoryName': self._serialize.url("factory_name", factory_name, 'str', max_length=63, min_length=3, pattern=r'^[A-Za-z0-9]+(?:-[A-Za-z0-9]+)*$'),
            'linkedServiceName': self._serialize.url("linked_service_name", linked_service_name, 'str', max_length=260, min_length=1, pattern=r'^[A-Za-z0-9_][^<>*#.%&:\\+?/]*$'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = 'application/json'

        # Construct and send request
        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_linked_service, 'LinkedServiceResource')
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = self._deserialize('LinkedServiceResource', pipeline_response)

        if cls:
          return cls(pipeline_response, deserialized, {})

        return deserialized
    create_or_update_cosmosdbmongodbapi.metadata = {'url': '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataFactory/factories/{factoryName}/linkedservices/{linkedServiceName}'}

    def create_or_update_couchbase(
        self,
        resource_group_name,  # type: str
        factory_name,  # type: str
        linked_service_name,  # type: str
        couchbase_type,  # type: str
        if_match=None,  # type: Optional[str]
        couchbase_connect_via=None,  # type: Optional["models.IntegrationRuntimeReference"]
        couchbase_description=None,  # type: Optional[str]
        couchbase_parameters=None,  # type: Optional[Dict[str, "ParameterSpecification"]]
        couchbase_annotations=None,  # type: Optional[List[object]]
        couchbase_connection_string=None,  # type: Optional[object]
        couchbase_cred_string=None,  # type: Optional["models.AzureKeyVaultSecretReference"]
        couchbase_encrypted_credential=None,  # type: Optional[object]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.LinkedServiceResource"
        """Creates or updates a linked service.

        :param resource_group_name: The resource group name.
        :type resource_group_name: str
        :param factory_name: The factory name.
        :type factory_name: str
        :param linked_service_name: The linked service name.
        :type linked_service_name: str
        :param couchbase_type: Type of linked service.
        :type couchbase_type: str
        :param if_match: ETag of the linkedService entity.  Should only be specified for update, for
         which it should match existing entity or can be * for unconditional update.
        :type if_match: str
        :param couchbase_connect_via: The integration runtime reference.
        :type couchbase_connect_via: ~azure.mgmt.datafactory.models.IntegrationRuntimeReference
        :param couchbase_description: Linked service description.
        :type couchbase_description: str
        :param couchbase_parameters: Parameters for linked service.
        :type couchbase_parameters: dict[str, ~azure.mgmt.datafactory.models.ParameterSpecification]
        :param couchbase_annotations: List of tags that can be used for describing the linked service.
        :type couchbase_annotations: list[object]
        :param couchbase_connection_string: An ODBC connection string. Type: string, SecureString or
         AzureKeyVaultSecretReference.
        :type couchbase_connection_string: object
        :param couchbase_cred_string: The Azure key vault secret reference of credString in connection
         string.
        :type couchbase_cred_string: ~azure.mgmt.datafactory.models.AzureKeyVaultSecretReference
        :param couchbase_encrypted_credential: The encrypted credential used for authentication.
         Credentials are encrypted using the integration runtime credential manager. Type: string (or
         Expression with resultType string).
        :type couchbase_encrypted_credential: object
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: LinkedServiceResource or the result of cls(response)
        :rtype: ~azure.mgmt.datafactory.models.LinkedServiceResource
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.LinkedServiceResource"]
        error_map = kwargs.pop('error_map', {404: ResourceNotFoundError, 409: ResourceExistsError})

        _linked_service = models.LinkedServiceResource(properties=properties, type=couchbase_type, connect_via=couchbase_connect_via, description=couchbase_description, parameters=couchbase_parameters, annotations=couchbase_annotations, connection_string=couchbase_connection_string, cred_string=couchbase_cred_string, encrypted_credential=couchbase_encrypted_credential)
        api_version = "2018-06-01"
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.create_or_update_couchbase.metadata['url']
        path_format_arguments = {
            'subscriptionId': self._serialize.url("self._config.subscription_id", self._config.subscription_id, 'str'),
            'resourceGroupName': self._serialize.url("resource_group_name", resource_group_name, 'str', max_length=90, min_length=1, pattern=r'^[-\w\._\(\)]+$'),
            'factoryName': self._serialize.url("factory_name", factory_name, 'str', max_length=63, min_length=3, pattern=r'^[A-Za-z0-9]+(?:-[A-Za-z0-9]+)*$'),
            'linkedServiceName': self._serialize.url("linked_service_name", linked_service_name, 'str', max_length=260, min_length=1, pattern=r'^[A-Za-z0-9_][^<>*#.%&:\\+?/]*$'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = 'application/json'

        # Construct and send request
        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_linked_service, 'LinkedServiceResource')
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = self._deserialize('LinkedServiceResource', pipeline_response)

        if cls:
          return cls(pipeline_response, deserialized, {})

        return deserialized
    create_or_update_couchbase.metadata = {'url': '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataFactory/factories/{factoryName}/linkedservices/{linkedServiceName}'}

    def create_or_update_customdatasource(
        self,
        resource_group_name,  # type: str
        factory_name,  # type: str
        linked_service_name,  # type: str
        customdatasource_type,  # type: str
        customdatasource_type_properties,  # type: object
        if_match=None,  # type: Optional[str]
        customdatasource_connect_via=None,  # type: Optional["models.IntegrationRuntimeReference"]
        customdatasource_description=None,  # type: Optional[str]
        customdatasource_parameters=None,  # type: Optional[Dict[str, "ParameterSpecification"]]
        customdatasource_annotations=None,  # type: Optional[List[object]]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.LinkedServiceResource"
        """Creates or updates a linked service.

        :param resource_group_name: The resource group name.
        :type resource_group_name: str
        :param factory_name: The factory name.
        :type factory_name: str
        :param linked_service_name: The linked service name.
        :type linked_service_name: str
        :param customdatasource_type: Type of linked service.
        :type customdatasource_type: str
        :param customdatasource_type_properties: Custom linked service properties.
        :type customdatasource_type_properties: object
        :param if_match: ETag of the linkedService entity.  Should only be specified for update, for
         which it should match existing entity or can be * for unconditional update.
        :type if_match: str
        :param customdatasource_connect_via: The integration runtime reference.
        :type customdatasource_connect_via: ~azure.mgmt.datafactory.models.IntegrationRuntimeReference
        :param customdatasource_description: Linked service description.
        :type customdatasource_description: str
        :param customdatasource_parameters: Parameters for linked service.
        :type customdatasource_parameters: dict[str, ~azure.mgmt.datafactory.models.ParameterSpecification]
        :param customdatasource_annotations: List of tags that can be used for describing the linked
         service.
        :type customdatasource_annotations: list[object]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: LinkedServiceResource or the result of cls(response)
        :rtype: ~azure.mgmt.datafactory.models.LinkedServiceResource
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.LinkedServiceResource"]
        error_map = kwargs.pop('error_map', {404: ResourceNotFoundError, 409: ResourceExistsError})

        _linked_service = models.LinkedServiceResource(properties=properties, type=customdatasource_type, connect_via=customdatasource_connect_via, description=customdatasource_description, parameters=customdatasource_parameters, annotations=customdatasource_annotations, type_properties=customdatasource_type_properties)
        api_version = "2018-06-01"
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.create_or_update_customdatasource.metadata['url']
        path_format_arguments = {
            'subscriptionId': self._serialize.url("self._config.subscription_id", self._config.subscription_id, 'str'),
            'resourceGroupName': self._serialize.url("resource_group_name", resource_group_name, 'str', max_length=90, min_length=1, pattern=r'^[-\w\._\(\)]+$'),
            'factoryName': self._serialize.url("factory_name", factory_name, 'str', max_length=63, min_length=3, pattern=r'^[A-Za-z0-9]+(?:-[A-Za-z0-9]+)*$'),
            'linkedServiceName': self._serialize.url("linked_service_name", linked_service_name, 'str', max_length=260, min_length=1, pattern=r'^[A-Za-z0-9_][^<>*#.%&:\\+?/]*$'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = 'application/json'

        # Construct and send request
        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_linked_service, 'LinkedServiceResource')
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = self._deserialize('LinkedServiceResource', pipeline_response)

        if cls:
          return cls(pipeline_response, deserialized, {})

        return deserialized
    create_or_update_customdatasource.metadata = {'url': '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataFactory/factories/{factoryName}/linkedservices/{linkedServiceName}'}

    def create_or_update_db2(
        self,
        resource_group_name,  # type: str
        factory_name,  # type: str
        linked_service_name,  # type: str
        db2_type,  # type: str
        if_match=None,  # type: Optional[str]
        db2_connect_via=None,  # type: Optional["models.IntegrationRuntimeReference"]
        db2_description=None,  # type: Optional[str]
        db2_parameters=None,  # type: Optional[Dict[str, "ParameterSpecification"]]
        db2_annotations=None,  # type: Optional[List[object]]
        db2_connection_string=None,  # type: Optional[object]
        db2_server=None,  # type: Optional[object]
        db2_database=None,  # type: Optional[object]
        db2_username=None,  # type: Optional[object]
        db2_password=None,  # type: Optional["models.SecretBase"]
        db2_package_collection=None,  # type: Optional[object]
        db2_certificate_common_name=None,  # type: Optional[object]
        db2_encrypted_credential=None,  # type: Optional[object]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.LinkedServiceResource"
        """Creates or updates a linked service.

        :param resource_group_name: The resource group name.
        :type resource_group_name: str
        :param factory_name: The factory name.
        :type factory_name: str
        :param linked_service_name: The linked service name.
        :type linked_service_name: str
        :param db2_type: Type of linked service.
        :type db2_type: str
        :param if_match: ETag of the linkedService entity.  Should only be specified for update, for
         which it should match existing entity or can be * for unconditional update.
        :type if_match: str
        :param db2_connect_via: The integration runtime reference.
        :type db2_connect_via: ~azure.mgmt.datafactory.models.IntegrationRuntimeReference
        :param db2_description: Linked service description.
        :type db2_description: str
        :param db2_parameters: Parameters for linked service.
        :type db2_parameters: dict[str, ~azure.mgmt.datafactory.models.ParameterSpecification]
        :param db2_annotations: List of tags that can be used for describing the linked service.
        :type db2_annotations: list[object]
        :param db2_connection_string: The connection string. It is mutually exclusive with server,
         database, authenticationType, userName, packageCollection and certificateCommonName property.
         Type: string, SecureString or AzureKeyVaultSecretReference.
        :type db2_connection_string: object
        :param db2_server: Server name for connection. It is mutually exclusive with connectionString
         property. Type: string (or Expression with resultType string).
        :type db2_server: object
        :param db2_database: Database name for connection. It is mutually exclusive with
         connectionString property. Type: string (or Expression with resultType string).
        :type db2_database: object
        :param db2_username: Username for authentication. It is mutually exclusive with
         connectionString property. Type: string (or Expression with resultType string).
        :type db2_username: object
        :param db2_password: Password for authentication.
        :type db2_password: ~azure.mgmt.datafactory.models.SecretBase
        :param db2_package_collection: Under where packages are created when querying database. It is
         mutually exclusive with connectionString property. Type: string (or Expression with resultType
         string).
        :type db2_package_collection: object
        :param db2_certificate_common_name: Certificate Common Name when TLS is enabled. It is mutually
         exclusive with connectionString property. Type: string (or Expression with resultType string).
        :type db2_certificate_common_name: object
        :param db2_encrypted_credential: The encrypted credential used for authentication. Credentials
         are encrypted using the integration runtime credential manager. It is mutually exclusive with
         connectionString property. Type: string (or Expression with resultType string).
        :type db2_encrypted_credential: object
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: LinkedServiceResource or the result of cls(response)
        :rtype: ~azure.mgmt.datafactory.models.LinkedServiceResource
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.LinkedServiceResource"]
        error_map = kwargs.pop('error_map', {404: ResourceNotFoundError, 409: ResourceExistsError})

        _linked_service = models.LinkedServiceResource(properties=properties, type=db2_type, connect_via=db2_connect_via, description=db2_description, parameters=db2_parameters, annotations=db2_annotations, connection_string=db2_connection_string, server=db2_server, database=db2_database, username=db2_username, password=db2_password, package_collection=db2_package_collection, certificate_common_name=db2_certificate_common_name, encrypted_credential=db2_encrypted_credential)
        api_version = "2018-06-01"
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.create_or_update_db2.metadata['url']
        path_format_arguments = {
            'subscriptionId': self._serialize.url("self._config.subscription_id", self._config.subscription_id, 'str'),
            'resourceGroupName': self._serialize.url("resource_group_name", resource_group_name, 'str', max_length=90, min_length=1, pattern=r'^[-\w\._\(\)]+$'),
            'factoryName': self._serialize.url("factory_name", factory_name, 'str', max_length=63, min_length=3, pattern=r'^[A-Za-z0-9]+(?:-[A-Za-z0-9]+)*$'),
            'linkedServiceName': self._serialize.url("linked_service_name", linked_service_name, 'str', max_length=260, min_length=1, pattern=r'^[A-Za-z0-9_][^<>*#.%&:\\+?/]*$'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = 'application/json'

        # Construct and send request
        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_linked_service, 'LinkedServiceResource')
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = self._deserialize('LinkedServiceResource', pipeline_response)

        if cls:
          return cls(pipeline_response, deserialized, {})

        return deserialized
    create_or_update_db2.metadata = {'url': '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataFactory/factories/{factoryName}/linkedservices/{linkedServiceName}'}

    def create_or_update_drill(
        self,
        resource_group_name,  # type: str
        factory_name,  # type: str
        linked_service_name,  # type: str
        drill_type,  # type: str
        if_match=None,  # type: Optional[str]
        drill_connect_via=None,  # type: Optional["models.IntegrationRuntimeReference"]
        drill_description=None,  # type: Optional[str]
        drill_parameters=None,  # type: Optional[Dict[str, "ParameterSpecification"]]
        drill_annotations=None,  # type: Optional[List[object]]
        drill_connection_string=None,  # type: Optional[object]
        drill_pwd=None,  # type: Optional["models.AzureKeyVaultSecretReference"]
        drill_encrypted_credential=None,  # type: Optional[object]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.LinkedServiceResource"
        """Creates or updates a linked service.

        :param resource_group_name: The resource group name.
        :type resource_group_name: str
        :param factory_name: The factory name.
        :type factory_name: str
        :param linked_service_name: The linked service name.
        :type linked_service_name: str
        :param drill_type: Type of linked service.
        :type drill_type: str
        :param if_match: ETag of the linkedService entity.  Should only be specified for update, for
         which it should match existing entity or can be * for unconditional update.
        :type if_match: str
        :param drill_connect_via: The integration runtime reference.
        :type drill_connect_via: ~azure.mgmt.datafactory.models.IntegrationRuntimeReference
        :param drill_description: Linked service description.
        :type drill_description: str
        :param drill_parameters: Parameters for linked service.
        :type drill_parameters: dict[str, ~azure.mgmt.datafactory.models.ParameterSpecification]
        :param drill_annotations: List of tags that can be used for describing the linked service.
        :type drill_annotations: list[object]
        :param drill_connection_string: An ODBC connection string. Type: string, SecureString or
         AzureKeyVaultSecretReference.
        :type drill_connection_string: object
        :param drill_pwd: The Azure key vault secret reference of password in connection string.
        :type drill_pwd: ~azure.mgmt.datafactory.models.AzureKeyVaultSecretReference
        :param drill_encrypted_credential: The encrypted credential used for authentication.
         Credentials are encrypted using the integration runtime credential manager. Type: string (or
         Expression with resultType string).
        :type drill_encrypted_credential: object
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: LinkedServiceResource or the result of cls(response)
        :rtype: ~azure.mgmt.datafactory.models.LinkedServiceResource
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.LinkedServiceResource"]
        error_map = kwargs.pop('error_map', {404: ResourceNotFoundError, 409: ResourceExistsError})

        _linked_service = models.LinkedServiceResource(properties=properties, type=drill_type, connect_via=drill_connect_via, description=drill_description, parameters=drill_parameters, annotations=drill_annotations, connection_string=drill_connection_string, pwd=drill_pwd, encrypted_credential=drill_encrypted_credential)
        api_version = "2018-06-01"
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.create_or_update_drill.metadata['url']
        path_format_arguments = {
            'subscriptionId': self._serialize.url("self._config.subscription_id", self._config.subscription_id, 'str'),
            'resourceGroupName': self._serialize.url("resource_group_name", resource_group_name, 'str', max_length=90, min_length=1, pattern=r'^[-\w\._\(\)]+$'),
            'factoryName': self._serialize.url("factory_name", factory_name, 'str', max_length=63, min_length=3, pattern=r'^[A-Za-z0-9]+(?:-[A-Za-z0-9]+)*$'),
            'linkedServiceName': self._serialize.url("linked_service_name", linked_service_name, 'str', max_length=260, min_length=1, pattern=r'^[A-Za-z0-9_][^<>*#.%&:\\+?/]*$'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = 'application/json'

        # Construct and send request
        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_linked_service, 'LinkedServiceResource')
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = self._deserialize('LinkedServiceResource', pipeline_response)

        if cls:
          return cls(pipeline_response, deserialized, {})

        return deserialized
    create_or_update_drill.metadata = {'url': '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataFactory/factories/{factoryName}/linkedservices/{linkedServiceName}'}

    def create_or_update_dynamics(
        self,
        resource_group_name,  # type: str
        factory_name,  # type: str
        linked_service_name,  # type: str
        dynamics_type,  # type: str
        dynamics_deployment_type,  # type: Union[str, "models.DynamicsDeploymentType"]
        dynamics_authentication_type,  # type: Union[str, "models.DynamicsAuthenticationType"]
        if_match=None,  # type: Optional[str]
        dynamics_connect_via=None,  # type: Optional["models.IntegrationRuntimeReference"]
        dynamics_description=None,  # type: Optional[str]
        dynamics_parameters=None,  # type: Optional[Dict[str, "ParameterSpecification"]]
        dynamics_annotations=None,  # type: Optional[List[object]]
        dynamics_host_name=None,  # type: Optional[object]
        dynamics_port=None,  # type: Optional[object]
        dynamics_service_uri=None,  # type: Optional[object]
        dynamics_organization_name=None,  # type: Optional[object]
        dynamics_username=None,  # type: Optional[object]
        dynamics_password=None,  # type: Optional["models.SecretBase"]
        dynamics_service_principal_id=None,  # type: Optional[object]
        dynamics_service_principal_credential_type=None,  # type: Optional[Union[str, "models.DynamicsServicePrincipalCredentialType"]]
        dynamics_service_principal_credential=None,  # type: Optional["models.SecretBase"]
        dynamics_encrypted_credential=None,  # type: Optional[object]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.LinkedServiceResource"
        """Creates or updates a linked service.

        :param resource_group_name: The resource group name.
        :type resource_group_name: str
        :param factory_name: The factory name.
        :type factory_name: str
        :param linked_service_name: The linked service name.
        :type linked_service_name: str
        :param dynamics_type: Type of linked service.
        :type dynamics_type: str
        :param dynamics_deployment_type: The deployment type of the Dynamics instance. 'Online' for
         Dynamics Online and 'OnPremisesWithIfd' for Dynamics on-premises with Ifd. Type: string (or
         Expression with resultType string).
        :type dynamics_deployment_type: str or ~azure.mgmt.datafactory.models.DynamicsDeploymentType
        :param dynamics_authentication_type: The authentication type to connect to Dynamics server.
         'Office365' for online scenario, 'Ifd' for on-premises with Ifd scenario, 'AADServicePrincipal'
         for Server-To-Server authentication in online scenario. Type: string (or Expression with
         resultType string).
        :type dynamics_authentication_type: str or ~azure.mgmt.datafactory.models.DynamicsAuthenticationType
        :param if_match: ETag of the linkedService entity.  Should only be specified for update, for
         which it should match existing entity or can be * for unconditional update.
        :type if_match: str
        :param dynamics_connect_via: The integration runtime reference.
        :type dynamics_connect_via: ~azure.mgmt.datafactory.models.IntegrationRuntimeReference
        :param dynamics_description: Linked service description.
        :type dynamics_description: str
        :param dynamics_parameters: Parameters for linked service.
        :type dynamics_parameters: dict[str, ~azure.mgmt.datafactory.models.ParameterSpecification]
        :param dynamics_annotations: List of tags that can be used for describing the linked service.
        :type dynamics_annotations: list[object]
        :param dynamics_host_name: The host name of the on-premises Dynamics server. The property is
         required for on-prem and not allowed for online. Type: string (or Expression with resultType
         string).
        :type dynamics_host_name: object
        :param dynamics_port: The port of on-premises Dynamics server. The property is required for on-
         prem and not allowed for online. Default is 443. Type: integer (or Expression with resultType
         integer), minimum: 0.
        :type dynamics_port: object
        :param dynamics_service_uri: The URL to the Microsoft Dynamics server. The property is required
         for on-line and not allowed for on-prem. Type: string (or Expression with resultType string).
        :type dynamics_service_uri: object
        :param dynamics_organization_name: The organization name of the Dynamics instance. The property
         is required for on-prem and required for online when there are more than one Dynamics instances
         associated with the user. Type: string (or Expression with resultType string).
        :type dynamics_organization_name: object
        :param dynamics_username: User name to access the Dynamics instance. Type: string (or
         Expression with resultType string).
        :type dynamics_username: object
        :param dynamics_password: Password to access the Dynamics instance.
        :type dynamics_password: ~azure.mgmt.datafactory.models.SecretBase
        :param dynamics_service_principal_id: The client ID of the application in Azure Active
         Directory used for Server-To-Server authentication. Type: string (or Expression with resultType
         string).
        :type dynamics_service_principal_id: object
        :param dynamics_service_principal_credential_type: The service principal credential type to use
         in Server-To-Server authentication. 'ServicePrincipalKey' for key/secret,
         'ServicePrincipalCert' for certificate. Type: string (or Expression with resultType string).
        :type dynamics_service_principal_credential_type: str or ~azure.mgmt.datafactory.models.DynamicsServicePrincipalCredentialType
        :param dynamics_service_principal_credential: The credential of the service principal object in
         Azure Active Directory. If servicePrincipalCredentialType is 'ServicePrincipalKey',
         servicePrincipalCredential can be SecureString or AzureKeyVaultSecretReference. If
         servicePrincipalCredentialType is 'ServicePrincipalCert', servicePrincipalCredential can only
         be AzureKeyVaultSecretReference.
        :type dynamics_service_principal_credential: ~azure.mgmt.datafactory.models.SecretBase
        :param dynamics_encrypted_credential: The encrypted credential used for authentication.
         Credentials are encrypted using the integration runtime credential manager. Type: string (or
         Expression with resultType string).
        :type dynamics_encrypted_credential: object
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: LinkedServiceResource or the result of cls(response)
        :rtype: ~azure.mgmt.datafactory.models.LinkedServiceResource
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.LinkedServiceResource"]
        error_map = kwargs.pop('error_map', {404: ResourceNotFoundError, 409: ResourceExistsError})

        _linked_service = models.LinkedServiceResource(properties=properties, type=dynamics_type, connect_via=dynamics_connect_via, description=dynamics_description, parameters=dynamics_parameters, annotations=dynamics_annotations, deployment_type=dynamics_deployment_type, host_name=dynamics_host_name, port=dynamics_port, service_uri=dynamics_service_uri, organization_name=dynamics_organization_name, authentication_type=dynamics_authentication_type, username=dynamics_username, password=dynamics_password, service_principal_id=dynamics_service_principal_id, service_principal_credential_type=dynamics_service_principal_credential_type, service_principal_credential=dynamics_service_principal_credential, encrypted_credential=dynamics_encrypted_credential)
        api_version = "2018-06-01"
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.create_or_update_dynamics.metadata['url']
        path_format_arguments = {
            'subscriptionId': self._serialize.url("self._config.subscription_id", self._config.subscription_id, 'str'),
            'resourceGroupName': self._serialize.url("resource_group_name", resource_group_name, 'str', max_length=90, min_length=1, pattern=r'^[-\w\._\(\)]+$'),
            'factoryName': self._serialize.url("factory_name", factory_name, 'str', max_length=63, min_length=3, pattern=r'^[A-Za-z0-9]+(?:-[A-Za-z0-9]+)*$'),
            'linkedServiceName': self._serialize.url("linked_service_name", linked_service_name, 'str', max_length=260, min_length=1, pattern=r'^[A-Za-z0-9_][^<>*#.%&:\\+?/]*$'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = 'application/json'

        # Construct and send request
        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_linked_service, 'LinkedServiceResource')
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = self._deserialize('LinkedServiceResource', pipeline_response)

        if cls:
          return cls(pipeline_response, deserialized, {})

        return deserialized
    create_or_update_dynamics.metadata = {'url': '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataFactory/factories/{factoryName}/linkedservices/{linkedServiceName}'}

    def create_or_update_dynamicsax(
        self,
        resource_group_name,  # type: str
        factory_name,  # type: str
        linked_service_name,  # type: str
        dynamicsax_type,  # type: str
        dynamicsax_url,  # type: object
        dynamicsax_service_principal_id,  # type: object
        dynamicsax_service_principal_key,  # type: "models.SecretBase"
        dynamicsax_tenant,  # type: object
        dynamicsax_aad_resource_id,  # type: object
        if_match=None,  # type: Optional[str]
        dynamicsax_connect_via=None,  # type: Optional["models.IntegrationRuntimeReference"]
        dynamicsax_description=None,  # type: Optional[str]
        dynamicsax_parameters=None,  # type: Optional[Dict[str, "ParameterSpecification"]]
        dynamicsax_annotations=None,  # type: Optional[List[object]]
        dynamicsax_encrypted_credential=None,  # type: Optional[object]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.LinkedServiceResource"
        """Creates or updates a linked service.

        :param resource_group_name: The resource group name.
        :type resource_group_name: str
        :param factory_name: The factory name.
        :type factory_name: str
        :param linked_service_name: The linked service name.
        :type linked_service_name: str
        :param dynamicsax_type: Type of linked service.
        :type dynamicsax_type: str
        :param dynamicsax_url: The Dynamics AX (or Dynamics 365 Finance and Operations) instance OData
         endpoint.
        :type dynamicsax_url: object
        :param dynamicsax_service_principal_id: Specify the application's client ID. Type: string (or
         Expression with resultType string).
        :type dynamicsax_service_principal_id: object
        :param dynamicsax_service_principal_key: Specify the application's key. Mark this field as a
         SecureString to store it securely in Data Factory, or reference a secret stored in Azure Key
         Vault. Type: string (or Expression with resultType string).
        :type dynamicsax_service_principal_key: ~azure.mgmt.datafactory.models.SecretBase
        :param dynamicsax_tenant: Specify the tenant information (domain name or tenant ID) under which
         your application resides. Retrieve it by hovering the mouse in the top-right corner of the
         Azure portal. Type: string (or Expression with resultType string).
        :type dynamicsax_tenant: object
        :param dynamicsax_aad_resource_id: Specify the resource you are requesting authorization. Type:
         string (or Expression with resultType string).
        :type dynamicsax_aad_resource_id: object
        :param if_match: ETag of the linkedService entity.  Should only be specified for update, for
         which it should match existing entity or can be * for unconditional update.
        :type if_match: str
        :param dynamicsax_connect_via: The integration runtime reference.
        :type dynamicsax_connect_via: ~azure.mgmt.datafactory.models.IntegrationRuntimeReference
        :param dynamicsax_description: Linked service description.
        :type dynamicsax_description: str
        :param dynamicsax_parameters: Parameters for linked service.
        :type dynamicsax_parameters: dict[str, ~azure.mgmt.datafactory.models.ParameterSpecification]
        :param dynamicsax_annotations: List of tags that can be used for describing the linked service.
        :type dynamicsax_annotations: list[object]
        :param dynamicsax_encrypted_credential: The encrypted credential used for authentication.
         Credentials are encrypted using the integration runtime credential manager. Type: string (or
         Expression with resultType string).
        :type dynamicsax_encrypted_credential: object
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: LinkedServiceResource or the result of cls(response)
        :rtype: ~azure.mgmt.datafactory.models.LinkedServiceResource
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.LinkedServiceResource"]
        error_map = kwargs.pop('error_map', {404: ResourceNotFoundError, 409: ResourceExistsError})

        _linked_service = models.LinkedServiceResource(properties=properties, type=dynamicsax_type, connect_via=dynamicsax_connect_via, description=dynamicsax_description, parameters=dynamicsax_parameters, annotations=dynamicsax_annotations, url=dynamicsax_url, service_principal_id=dynamicsax_service_principal_id, service_principal_key=dynamicsax_service_principal_key, tenant=dynamicsax_tenant, aad_resource_id=dynamicsax_aad_resource_id, encrypted_credential=dynamicsax_encrypted_credential)
        api_version = "2018-06-01"
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.create_or_update_dynamicsax.metadata['url']
        path_format_arguments = {
            'subscriptionId': self._serialize.url("self._config.subscription_id", self._config.subscription_id, 'str'),
            'resourceGroupName': self._serialize.url("resource_group_name", resource_group_name, 'str', max_length=90, min_length=1, pattern=r'^[-\w\._\(\)]+$'),
            'factoryName': self._serialize.url("factory_name", factory_name, 'str', max_length=63, min_length=3, pattern=r'^[A-Za-z0-9]+(?:-[A-Za-z0-9]+)*$'),
            'linkedServiceName': self._serialize.url("linked_service_name", linked_service_name, 'str', max_length=260, min_length=1, pattern=r'^[A-Za-z0-9_][^<>*#.%&:\\+?/]*$'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = 'application/json'

        # Construct and send request
        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_linked_service, 'LinkedServiceResource')
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = self._deserialize('LinkedServiceResource', pipeline_response)

        if cls:
          return cls(pipeline_response, deserialized, {})

        return deserialized
    create_or_update_dynamicsax.metadata = {'url': '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataFactory/factories/{factoryName}/linkedservices/{linkedServiceName}'}

    def create_or_update_dynamicscrm(
        self,
        resource_group_name,  # type: str
        factory_name,  # type: str
        linked_service_name,  # type: str
        dynamicscrm_type,  # type: str
        dynamicscrm_deployment_type,  # type: Union[str, "models.DynamicsDeploymentType"]
        dynamicscrm_authentication_type,  # type: Union[str, "models.DynamicsAuthenticationType"]
        if_match=None,  # type: Optional[str]
        dynamicscrm_connect_via=None,  # type: Optional["models.IntegrationRuntimeReference"]
        dynamicscrm_description=None,  # type: Optional[str]
        dynamicscrm_parameters=None,  # type: Optional[Dict[str, "ParameterSpecification"]]
        dynamicscrm_annotations=None,  # type: Optional[List[object]]
        dynamicscrm_host_name=None,  # type: Optional[object]
        dynamicscrm_port=None,  # type: Optional[object]
        dynamicscrm_service_uri=None,  # type: Optional[object]
        dynamicscrm_organization_name=None,  # type: Optional[object]
        dynamicscrm_username=None,  # type: Optional[object]
        dynamicscrm_password=None,  # type: Optional["models.SecretBase"]
        dynamicscrm_service_principal_id=None,  # type: Optional[object]
        dynamicscrm_service_principal_credential_type=None,  # type: Optional[Union[str, "models.DynamicsServicePrincipalCredentialType"]]
        dynamicscrm_service_principal_credential=None,  # type: Optional["models.SecretBase"]
        dynamicscrm_encrypted_credential=None,  # type: Optional[object]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.LinkedServiceResource"
        """Creates or updates a linked service.

        :param resource_group_name: The resource group name.
        :type resource_group_name: str
        :param factory_name: The factory name.
        :type factory_name: str
        :param linked_service_name: The linked service name.
        :type linked_service_name: str
        :param dynamicscrm_type: Type of linked service.
        :type dynamicscrm_type: str
        :param dynamicscrm_deployment_type: The deployment type of the Dynamics CRM instance. 'Online'
         for Dynamics CRM Online and 'OnPremisesWithIfd' for Dynamics CRM on-premises with Ifd. Type:
         string (or Expression with resultType string).
        :type dynamicscrm_deployment_type: str or ~azure.mgmt.datafactory.models.DynamicsDeploymentType
        :param dynamicscrm_authentication_type: The authentication type to connect to Dynamics CRM
         server. 'Office365' for online scenario, 'Ifd' for on-premises with Ifd scenario,
         'AADServicePrincipal' for Server-To-Server authentication in online scenario. Type: string (or
         Expression with resultType string).
        :type dynamicscrm_authentication_type: str or ~azure.mgmt.datafactory.models.DynamicsAuthenticationType
        :param if_match: ETag of the linkedService entity.  Should only be specified for update, for
         which it should match existing entity or can be * for unconditional update.
        :type if_match: str
        :param dynamicscrm_connect_via: The integration runtime reference.
        :type dynamicscrm_connect_via: ~azure.mgmt.datafactory.models.IntegrationRuntimeReference
        :param dynamicscrm_description: Linked service description.
        :type dynamicscrm_description: str
        :param dynamicscrm_parameters: Parameters for linked service.
        :type dynamicscrm_parameters: dict[str, ~azure.mgmt.datafactory.models.ParameterSpecification]
        :param dynamicscrm_annotations: List of tags that can be used for describing the linked
         service.
        :type dynamicscrm_annotations: list[object]
        :param dynamicscrm_host_name: The host name of the on-premises Dynamics CRM server. The
         property is required for on-prem and not allowed for online. Type: string (or Expression with
         resultType string).
        :type dynamicscrm_host_name: object
        :param dynamicscrm_port: The port of on-premises Dynamics CRM server. The property is required
         for on-prem and not allowed for online. Default is 443. Type: integer (or Expression with
         resultType integer), minimum: 0.
        :type dynamicscrm_port: object
        :param dynamicscrm_service_uri: The URL to the Microsoft Dynamics CRM server. The property is
         required for on-line and not allowed for on-prem. Type: string (or Expression with resultType
         string).
        :type dynamicscrm_service_uri: object
        :param dynamicscrm_organization_name: The organization name of the Dynamics CRM instance. The
         property is required for on-prem and required for online when there are more than one Dynamics
         CRM instances associated with the user. Type: string (or Expression with resultType string).
        :type dynamicscrm_organization_name: object
        :param dynamicscrm_username: User name to access the Dynamics CRM instance. Type: string (or
         Expression with resultType string).
        :type dynamicscrm_username: object
        :param dynamicscrm_password: Password to access the Dynamics CRM instance.
        :type dynamicscrm_password: ~azure.mgmt.datafactory.models.SecretBase
        :param dynamicscrm_service_principal_id: The client ID of the application in Azure Active
         Directory used for Server-To-Server authentication. Type: string (or Expression with resultType
         string).
        :type dynamicscrm_service_principal_id: object
        :param dynamicscrm_service_principal_credential_type: The service principal credential type to
         use in Server-To-Server authentication. 'ServicePrincipalKey' for key/secret,
         'ServicePrincipalCert' for certificate. Type: string (or Expression with resultType string).
        :type dynamicscrm_service_principal_credential_type: str or ~azure.mgmt.datafactory.models.DynamicsServicePrincipalCredentialType
        :param dynamicscrm_service_principal_credential: The credential of the service principal object
         in Azure Active Directory. If servicePrincipalCredentialType is 'ServicePrincipalKey',
         servicePrincipalCredential can be SecureString or AzureKeyVaultSecretReference. If
         servicePrincipalCredentialType is 'ServicePrincipalCert', servicePrincipalCredential can only
         be AzureKeyVaultSecretReference.
        :type dynamicscrm_service_principal_credential: ~azure.mgmt.datafactory.models.SecretBase
        :param dynamicscrm_encrypted_credential: The encrypted credential used for authentication.
         Credentials are encrypted using the integration runtime credential manager. Type: string (or
         Expression with resultType string).
        :type dynamicscrm_encrypted_credential: object
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: LinkedServiceResource or the result of cls(response)
        :rtype: ~azure.mgmt.datafactory.models.LinkedServiceResource
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.LinkedServiceResource"]
        error_map = kwargs.pop('error_map', {404: ResourceNotFoundError, 409: ResourceExistsError})

        _linked_service = models.LinkedServiceResource(properties=properties, type=dynamicscrm_type, connect_via=dynamicscrm_connect_via, description=dynamicscrm_description, parameters=dynamicscrm_parameters, annotations=dynamicscrm_annotations, deployment_type=dynamicscrm_deployment_type, host_name=dynamicscrm_host_name, port=dynamicscrm_port, service_uri=dynamicscrm_service_uri, organization_name=dynamicscrm_organization_name, authentication_type=dynamicscrm_authentication_type, username=dynamicscrm_username, password=dynamicscrm_password, service_principal_id=dynamicscrm_service_principal_id, service_principal_credential_type=dynamicscrm_service_principal_credential_type, service_principal_credential=dynamicscrm_service_principal_credential, encrypted_credential=dynamicscrm_encrypted_credential)
        api_version = "2018-06-01"
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.create_or_update_dynamicscrm.metadata['url']
        path_format_arguments = {
            'subscriptionId': self._serialize.url("self._config.subscription_id", self._config.subscription_id, 'str'),
            'resourceGroupName': self._serialize.url("resource_group_name", resource_group_name, 'str', max_length=90, min_length=1, pattern=r'^[-\w\._\(\)]+$'),
            'factoryName': self._serialize.url("factory_name", factory_name, 'str', max_length=63, min_length=3, pattern=r'^[A-Za-z0-9]+(?:-[A-Za-z0-9]+)*$'),
            'linkedServiceName': self._serialize.url("linked_service_name", linked_service_name, 'str', max_length=260, min_length=1, pattern=r'^[A-Za-z0-9_][^<>*#.%&:\\+?/]*$'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = 'application/json'

        # Construct and send request
        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_linked_service, 'LinkedServiceResource')
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = self._deserialize('LinkedServiceResource', pipeline_response)

        if cls:
          return cls(pipeline_response, deserialized, {})

        return deserialized
    create_or_update_dynamicscrm.metadata = {'url': '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataFactory/factories/{factoryName}/linkedservices/{linkedServiceName}'}

    def create_or_update_eloqua(
        self,
        resource_group_name,  # type: str
        factory_name,  # type: str
        linked_service_name,  # type: str
        eloqua_type,  # type: str
        eloqua_endpoint,  # type: object
        eloqua_username,  # type: object
        if_match=None,  # type: Optional[str]
        eloqua_connect_via=None,  # type: Optional["models.IntegrationRuntimeReference"]
        eloqua_description=None,  # type: Optional[str]
        eloqua_parameters=None,  # type: Optional[Dict[str, "ParameterSpecification"]]
        eloqua_annotations=None,  # type: Optional[List[object]]
        eloqua_password=None,  # type: Optional["models.SecretBase"]
        eloqua_use_encrypted_endpoints=None,  # type: Optional[object]
        eloqua_use_host_verification=None,  # type: Optional[object]
        eloqua_use_peer_verification=None,  # type: Optional[object]
        eloqua_encrypted_credential=None,  # type: Optional[object]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.LinkedServiceResource"
        """Creates or updates a linked service.

        :param resource_group_name: The resource group name.
        :type resource_group_name: str
        :param factory_name: The factory name.
        :type factory_name: str
        :param linked_service_name: The linked service name.
        :type linked_service_name: str
        :param eloqua_type: Type of linked service.
        :type eloqua_type: str
        :param eloqua_endpoint: The endpoint of the Eloqua server. (i.e. eloqua.example.com).
        :type eloqua_endpoint: object
        :param eloqua_username: The site name and user name of your Eloqua account in the form:
         sitename/username. (i.e. Eloqua/Alice).
        :type eloqua_username: object
        :param if_match: ETag of the linkedService entity.  Should only be specified for update, for
         which it should match existing entity or can be * for unconditional update.
        :type if_match: str
        :param eloqua_connect_via: The integration runtime reference.
        :type eloqua_connect_via: ~azure.mgmt.datafactory.models.IntegrationRuntimeReference
        :param eloqua_description: Linked service description.
        :type eloqua_description: str
        :param eloqua_parameters: Parameters for linked service.
        :type eloqua_parameters: dict[str, ~azure.mgmt.datafactory.models.ParameterSpecification]
        :param eloqua_annotations: List of tags that can be used for describing the linked service.
        :type eloqua_annotations: list[object]
        :param eloqua_password: The password corresponding to the user name.
        :type eloqua_password: ~azure.mgmt.datafactory.models.SecretBase
        :param eloqua_use_encrypted_endpoints: Specifies whether the data source endpoints are
         encrypted using HTTPS. The default value is true.
        :type eloqua_use_encrypted_endpoints: object
        :param eloqua_use_host_verification: Specifies whether to require the host name in the server's
         certificate to match the host name of the server when connecting over SSL. The default value is
         true.
        :type eloqua_use_host_verification: object
        :param eloqua_use_peer_verification: Specifies whether to verify the identity of the server
         when connecting over SSL. The default value is true.
        :type eloqua_use_peer_verification: object
        :param eloqua_encrypted_credential: The encrypted credential used for authentication.
         Credentials are encrypted using the integration runtime credential manager. Type: string (or
         Expression with resultType string).
        :type eloqua_encrypted_credential: object
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: LinkedServiceResource or the result of cls(response)
        :rtype: ~azure.mgmt.datafactory.models.LinkedServiceResource
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.LinkedServiceResource"]
        error_map = kwargs.pop('error_map', {404: ResourceNotFoundError, 409: ResourceExistsError})

        _linked_service = models.LinkedServiceResource(properties=properties, type=eloqua_type, connect_via=eloqua_connect_via, description=eloqua_description, parameters=eloqua_parameters, annotations=eloqua_annotations, endpoint=eloqua_endpoint, username=eloqua_username, password=eloqua_password, use_encrypted_endpoints=eloqua_use_encrypted_endpoints, use_host_verification=eloqua_use_host_verification, use_peer_verification=eloqua_use_peer_verification, encrypted_credential=eloqua_encrypted_credential)
        api_version = "2018-06-01"
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.create_or_update_eloqua.metadata['url']
        path_format_arguments = {
            'subscriptionId': self._serialize.url("self._config.subscription_id", self._config.subscription_id, 'str'),
            'resourceGroupName': self._serialize.url("resource_group_name", resource_group_name, 'str', max_length=90, min_length=1, pattern=r'^[-\w\._\(\)]+$'),
            'factoryName': self._serialize.url("factory_name", factory_name, 'str', max_length=63, min_length=3, pattern=r'^[A-Za-z0-9]+(?:-[A-Za-z0-9]+)*$'),
            'linkedServiceName': self._serialize.url("linked_service_name", linked_service_name, 'str', max_length=260, min_length=1, pattern=r'^[A-Za-z0-9_][^<>*#.%&:\\+?/]*$'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = 'application/json'

        # Construct and send request
        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_linked_service, 'LinkedServiceResource')
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = self._deserialize('LinkedServiceResource', pipeline_response)

        if cls:
          return cls(pipeline_response, deserialized, {})

        return deserialized
    create_or_update_eloqua.metadata = {'url': '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataFactory/factories/{factoryName}/linkedservices/{linkedServiceName}'}

    def create_or_update_fileserver(
        self,
        resource_group_name,  # type: str
        factory_name,  # type: str
        linked_service_name,  # type: str
        fileserver_type,  # type: str
        fileserver_host,  # type: object
        if_match=None,  # type: Optional[str]
        fileserver_connect_via=None,  # type: Optional["models.IntegrationRuntimeReference"]
        fileserver_description=None,  # type: Optional[str]
        fileserver_parameters=None,  # type: Optional[Dict[str, "ParameterSpecification"]]
        fileserver_annotations=None,  # type: Optional[List[object]]
        fileserver_user_id=None,  # type: Optional[object]
        fileserver_password=None,  # type: Optional["models.SecretBase"]
        fileserver_encrypted_credential=None,  # type: Optional[object]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.LinkedServiceResource"
        """Creates or updates a linked service.

        :param resource_group_name: The resource group name.
        :type resource_group_name: str
        :param factory_name: The factory name.
        :type factory_name: str
        :param linked_service_name: The linked service name.
        :type linked_service_name: str
        :param fileserver_type: Type of linked service.
        :type fileserver_type: str
        :param fileserver_host: Host name of the server. Type: string (or Expression with resultType
         string).
        :type fileserver_host: object
        :param if_match: ETag of the linkedService entity.  Should only be specified for update, for
         which it should match existing entity or can be * for unconditional update.
        :type if_match: str
        :param fileserver_connect_via: The integration runtime reference.
        :type fileserver_connect_via: ~azure.mgmt.datafactory.models.IntegrationRuntimeReference
        :param fileserver_description: Linked service description.
        :type fileserver_description: str
        :param fileserver_parameters: Parameters for linked service.
        :type fileserver_parameters: dict[str, ~azure.mgmt.datafactory.models.ParameterSpecification]
        :param fileserver_annotations: List of tags that can be used for describing the linked service.
        :type fileserver_annotations: list[object]
        :param fileserver_user_id: User ID to logon the server. Type: string (or Expression with
         resultType string).
        :type fileserver_user_id: object
        :param fileserver_password: Password to logon the server.
        :type fileserver_password: ~azure.mgmt.datafactory.models.SecretBase
        :param fileserver_encrypted_credential: The encrypted credential used for authentication.
         Credentials are encrypted using the integration runtime credential manager. Type: string (or
         Expression with resultType string).
        :type fileserver_encrypted_credential: object
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: LinkedServiceResource or the result of cls(response)
        :rtype: ~azure.mgmt.datafactory.models.LinkedServiceResource
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.LinkedServiceResource"]
        error_map = kwargs.pop('error_map', {404: ResourceNotFoundError, 409: ResourceExistsError})

        _linked_service = models.LinkedServiceResource(properties=properties, type=fileserver_type, connect_via=fileserver_connect_via, description=fileserver_description, parameters=fileserver_parameters, annotations=fileserver_annotations, host=fileserver_host, user_id=fileserver_user_id, password=fileserver_password, encrypted_credential=fileserver_encrypted_credential)
        api_version = "2018-06-01"
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.create_or_update_fileserver.metadata['url']
        path_format_arguments = {
            'subscriptionId': self._serialize.url("self._config.subscription_id", self._config.subscription_id, 'str'),
            'resourceGroupName': self._serialize.url("resource_group_name", resource_group_name, 'str', max_length=90, min_length=1, pattern=r'^[-\w\._\(\)]+$'),
            'factoryName': self._serialize.url("factory_name", factory_name, 'str', max_length=63, min_length=3, pattern=r'^[A-Za-z0-9]+(?:-[A-Za-z0-9]+)*$'),
            'linkedServiceName': self._serialize.url("linked_service_name", linked_service_name, 'str', max_length=260, min_length=1, pattern=r'^[A-Za-z0-9_][^<>*#.%&:\\+?/]*$'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = 'application/json'

        # Construct and send request
        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_linked_service, 'LinkedServiceResource')
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = self._deserialize('LinkedServiceResource', pipeline_response)

        if cls:
          return cls(pipeline_response, deserialized, {})

        return deserialized
    create_or_update_fileserver.metadata = {'url': '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataFactory/factories/{factoryName}/linkedservices/{linkedServiceName}'}

    def create_or_update_ftpserver(
        self,
        resource_group_name,  # type: str
        factory_name,  # type: str
        linked_service_name,  # type: str
        ftpserver_type,  # type: str
        ftpserver_host,  # type: object
        if_match=None,  # type: Optional[str]
        ftpserver_connect_via=None,  # type: Optional["models.IntegrationRuntimeReference"]
        ftpserver_description=None,  # type: Optional[str]
        ftpserver_parameters=None,  # type: Optional[Dict[str, "ParameterSpecification"]]
        ftpserver_annotations=None,  # type: Optional[List[object]]
        ftpserver_port=None,  # type: Optional[object]
        ftpserver_authentication_type=None,  # type: Optional[Union[str, "models.FtpAuthenticationType"]]
        ftpserver_user_name=None,  # type: Optional[object]
        ftpserver_password=None,  # type: Optional["models.SecretBase"]
        ftpserver_encrypted_credential=None,  # type: Optional[object]
        ftpserver_enable_ssl=None,  # type: Optional[object]
        ftpserver_enable_server_certificate_validation=None,  # type: Optional[object]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.LinkedServiceResource"
        """Creates or updates a linked service.

        :param resource_group_name: The resource group name.
        :type resource_group_name: str
        :param factory_name: The factory name.
        :type factory_name: str
        :param linked_service_name: The linked service name.
        :type linked_service_name: str
        :param ftpserver_type: Type of linked service.
        :type ftpserver_type: str
        :param ftpserver_host: Host name of the FTP server. Type: string (or Expression with resultType
         string).
        :type ftpserver_host: object
        :param if_match: ETag of the linkedService entity.  Should only be specified for update, for
         which it should match existing entity or can be * for unconditional update.
        :type if_match: str
        :param ftpserver_connect_via: The integration runtime reference.
        :type ftpserver_connect_via: ~azure.mgmt.datafactory.models.IntegrationRuntimeReference
        :param ftpserver_description: Linked service description.
        :type ftpserver_description: str
        :param ftpserver_parameters: Parameters for linked service.
        :type ftpserver_parameters: dict[str, ~azure.mgmt.datafactory.models.ParameterSpecification]
        :param ftpserver_annotations: List of tags that can be used for describing the linked service.
        :type ftpserver_annotations: list[object]
        :param ftpserver_port: The TCP port number that the FTP server uses to listen for client
         connections. Default value is 21. Type: integer (or Expression with resultType integer),
         minimum: 0.
        :type ftpserver_port: object
        :param ftpserver_authentication_type: The authentication type to be used to connect to the FTP
         server.
        :type ftpserver_authentication_type: str or ~azure.mgmt.datafactory.models.FtpAuthenticationType
        :param ftpserver_user_name: Username to logon the FTP server. Type: string (or Expression with
         resultType string).
        :type ftpserver_user_name: object
        :param ftpserver_password: Password to logon the FTP server.
        :type ftpserver_password: ~azure.mgmt.datafactory.models.SecretBase
        :param ftpserver_encrypted_credential: The encrypted credential used for authentication.
         Credentials are encrypted using the integration runtime credential manager. Type: string (or
         Expression with resultType string).
        :type ftpserver_encrypted_credential: object
        :param ftpserver_enable_ssl: If true, connect to the FTP server over SSL/TLS channel. Default
         value is true. Type: boolean (or Expression with resultType boolean).
        :type ftpserver_enable_ssl: object
        :param ftpserver_enable_server_certificate_validation: If true, validate the FTP server SSL
         certificate when connect over SSL/TLS channel. Default value is true. Type: boolean (or
         Expression with resultType boolean).
        :type ftpserver_enable_server_certificate_validation: object
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: LinkedServiceResource or the result of cls(response)
        :rtype: ~azure.mgmt.datafactory.models.LinkedServiceResource
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.LinkedServiceResource"]
        error_map = kwargs.pop('error_map', {404: ResourceNotFoundError, 409: ResourceExistsError})

        _linked_service = models.LinkedServiceResource(properties=properties, type=ftpserver_type, connect_via=ftpserver_connect_via, description=ftpserver_description, parameters=ftpserver_parameters, annotations=ftpserver_annotations, host=ftpserver_host, port=ftpserver_port, authentication_type=ftpserver_authentication_type, user_name=ftpserver_user_name, password=ftpserver_password, encrypted_credential=ftpserver_encrypted_credential, enable_ssl=ftpserver_enable_ssl, enable_server_certificate_validation=ftpserver_enable_server_certificate_validation)
        api_version = "2018-06-01"
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.create_or_update_ftpserver.metadata['url']
        path_format_arguments = {
            'subscriptionId': self._serialize.url("self._config.subscription_id", self._config.subscription_id, 'str'),
            'resourceGroupName': self._serialize.url("resource_group_name", resource_group_name, 'str', max_length=90, min_length=1, pattern=r'^[-\w\._\(\)]+$'),
            'factoryName': self._serialize.url("factory_name", factory_name, 'str', max_length=63, min_length=3, pattern=r'^[A-Za-z0-9]+(?:-[A-Za-z0-9]+)*$'),
            'linkedServiceName': self._serialize.url("linked_service_name", linked_service_name, 'str', max_length=260, min_length=1, pattern=r'^[A-Za-z0-9_][^<>*#.%&:\\+?/]*$'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = 'application/json'

        # Construct and send request
        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_linked_service, 'LinkedServiceResource')
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = self._deserialize('LinkedServiceResource', pipeline_response)

        if cls:
          return cls(pipeline_response, deserialized, {})

        return deserialized
    create_or_update_ftpserver.metadata = {'url': '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataFactory/factories/{factoryName}/linkedservices/{linkedServiceName}'}

    def create_or_update_googleadwords(
        self,
        resource_group_name,  # type: str
        factory_name,  # type: str
        linked_service_name,  # type: str
        googleadwords_type,  # type: str
        googleadwords_client_customer_id,  # type: object
        googleadwords_developer_token,  # type: "models.SecretBase"
        googleadwords_authentication_type,  # type: Union[str, "models.GoogleAdWordsAuthenticationType"]
        if_match=None,  # type: Optional[str]
        googleadwords_connect_via=None,  # type: Optional["models.IntegrationRuntimeReference"]
        googleadwords_description=None,  # type: Optional[str]
        googleadwords_parameters=None,  # type: Optional[Dict[str, "ParameterSpecification"]]
        googleadwords_annotations=None,  # type: Optional[List[object]]
        googleadwords_refresh_token=None,  # type: Optional["models.SecretBase"]
        googleadwords_client_id=None,  # type: Optional[object]
        googleadwords_client_secret=None,  # type: Optional["models.SecretBase"]
        googleadwords_email=None,  # type: Optional[object]
        googleadwords_key_file_path=None,  # type: Optional[object]
        googleadwords_trusted_cert_path=None,  # type: Optional[object]
        googleadwords_use_system_trust_store=None,  # type: Optional[object]
        googleadwords_encrypted_credential=None,  # type: Optional[object]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.LinkedServiceResource"
        """Creates or updates a linked service.

        :param resource_group_name: The resource group name.
        :type resource_group_name: str
        :param factory_name: The factory name.
        :type factory_name: str
        :param linked_service_name: The linked service name.
        :type linked_service_name: str
        :param googleadwords_type: Type of linked service.
        :type googleadwords_type: str
        :param googleadwords_client_customer_id: The Client customer ID of the AdWords account that you
         want to fetch report data for.
        :type googleadwords_client_customer_id: object
        :param googleadwords_developer_token: The developer token associated with the manager account
         that you use to grant access to the AdWords API.
        :type googleadwords_developer_token: ~azure.mgmt.datafactory.models.SecretBase
        :param googleadwords_authentication_type: The OAuth 2.0 authentication mechanism used for
         authentication. ServiceAuthentication can only be used on self-hosted IR.
        :type googleadwords_authentication_type: str or ~azure.mgmt.datafactory.models.GoogleAdWordsAuthenticationType
        :param if_match: ETag of the linkedService entity.  Should only be specified for update, for
         which it should match existing entity or can be * for unconditional update.
        :type if_match: str
        :param googleadwords_connect_via: The integration runtime reference.
        :type googleadwords_connect_via: ~azure.mgmt.datafactory.models.IntegrationRuntimeReference
        :param googleadwords_description: Linked service description.
        :type googleadwords_description: str
        :param googleadwords_parameters: Parameters for linked service.
        :type googleadwords_parameters: dict[str, ~azure.mgmt.datafactory.models.ParameterSpecification]
        :param googleadwords_annotations: List of tags that can be used for describing the linked
         service.
        :type googleadwords_annotations: list[object]
        :param googleadwords_refresh_token: The refresh token obtained from Google for authorizing
         access to AdWords for UserAuthentication.
        :type googleadwords_refresh_token: ~azure.mgmt.datafactory.models.SecretBase
        :param googleadwords_client_id: The client id of the google application used to acquire the
         refresh token. Type: string (or Expression with resultType string).
        :type googleadwords_client_id: object
        :param googleadwords_client_secret: The client secret of the google application used to acquire
         the refresh token.
        :type googleadwords_client_secret: ~azure.mgmt.datafactory.models.SecretBase
        :param googleadwords_email: The service account email ID that is used for ServiceAuthentication
         and can only be used on self-hosted IR.
        :type googleadwords_email: object
        :param googleadwords_key_file_path: The full path to the .p12 key file that is used to
         authenticate the service account email address and can only be used on self-hosted IR.
        :type googleadwords_key_file_path: object
        :param googleadwords_trusted_cert_path: The full path of the .pem file containing trusted CA
         certificates for verifying the server when connecting over SSL. This property can only be set
         when using SSL on self-hosted IR. The default value is the cacerts.pem file installed with the
         IR.
        :type googleadwords_trusted_cert_path: object
        :param googleadwords_use_system_trust_store: Specifies whether to use a CA certificate from the
         system trust store or from a specified PEM file. The default value is false.
        :type googleadwords_use_system_trust_store: object
        :param googleadwords_encrypted_credential: The encrypted credential used for authentication.
         Credentials are encrypted using the integration runtime credential manager. Type: string (or
         Expression with resultType string).
        :type googleadwords_encrypted_credential: object
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: LinkedServiceResource or the result of cls(response)
        :rtype: ~azure.mgmt.datafactory.models.LinkedServiceResource
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.LinkedServiceResource"]
        error_map = kwargs.pop('error_map', {404: ResourceNotFoundError, 409: ResourceExistsError})

        _linked_service = models.LinkedServiceResource(properties=properties, type=googleadwords_type, connect_via=googleadwords_connect_via, description=googleadwords_description, parameters=googleadwords_parameters, annotations=googleadwords_annotations, client_customer_id=googleadwords_client_customer_id, developer_token=googleadwords_developer_token, authentication_type=googleadwords_authentication_type, refresh_token=googleadwords_refresh_token, client_id=googleadwords_client_id, client_secret=googleadwords_client_secret, email=googleadwords_email, key_file_path=googleadwords_key_file_path, trusted_cert_path=googleadwords_trusted_cert_path, use_system_trust_store=googleadwords_use_system_trust_store, encrypted_credential=googleadwords_encrypted_credential)
        api_version = "2018-06-01"
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.create_or_update_googleadwords.metadata['url']
        path_format_arguments = {
            'subscriptionId': self._serialize.url("self._config.subscription_id", self._config.subscription_id, 'str'),
            'resourceGroupName': self._serialize.url("resource_group_name", resource_group_name, 'str', max_length=90, min_length=1, pattern=r'^[-\w\._\(\)]+$'),
            'factoryName': self._serialize.url("factory_name", factory_name, 'str', max_length=63, min_length=3, pattern=r'^[A-Za-z0-9]+(?:-[A-Za-z0-9]+)*$'),
            'linkedServiceName': self._serialize.url("linked_service_name", linked_service_name, 'str', max_length=260, min_length=1, pattern=r'^[A-Za-z0-9_][^<>*#.%&:\\+?/]*$'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = 'application/json'

        # Construct and send request
        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_linked_service, 'LinkedServiceResource')
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = self._deserialize('LinkedServiceResource', pipeline_response)

        if cls:
          return cls(pipeline_response, deserialized, {})

        return deserialized
    create_or_update_googleadwords.metadata = {'url': '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataFactory/factories/{factoryName}/linkedservices/{linkedServiceName}'}

    def create_or_update_googlebigquery(
        self,
        resource_group_name,  # type: str
        factory_name,  # type: str
        linked_service_name,  # type: str
        googlebigquery_type,  # type: str
        googlebigquery_project,  # type: object
        googlebigquery_authentication_type,  # type: Union[str, "models.GoogleBigQueryAuthenticationType"]
        if_match=None,  # type: Optional[str]
        googlebigquery_connect_via=None,  # type: Optional["models.IntegrationRuntimeReference"]
        googlebigquery_description=None,  # type: Optional[str]
        googlebigquery_parameters=None,  # type: Optional[Dict[str, "ParameterSpecification"]]
        googlebigquery_annotations=None,  # type: Optional[List[object]]
        googlebigquery_additional_projects=None,  # type: Optional[object]
        googlebigquery_request_google_drive_scope=None,  # type: Optional[object]
        googlebigquery_refresh_token=None,  # type: Optional["models.SecretBase"]
        googlebigquery_client_id=None,  # type: Optional[object]
        googlebigquery_client_secret=None,  # type: Optional["models.SecretBase"]
        googlebigquery_email=None,  # type: Optional[object]
        googlebigquery_key_file_path=None,  # type: Optional[object]
        googlebigquery_trusted_cert_path=None,  # type: Optional[object]
        googlebigquery_use_system_trust_store=None,  # type: Optional[object]
        googlebigquery_encrypted_credential=None,  # type: Optional[object]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.LinkedServiceResource"
        """Creates or updates a linked service.

        :param resource_group_name: The resource group name.
        :type resource_group_name: str
        :param factory_name: The factory name.
        :type factory_name: str
        :param linked_service_name: The linked service name.
        :type linked_service_name: str
        :param googlebigquery_type: Type of linked service.
        :type googlebigquery_type: str
        :param googlebigquery_project: The default BigQuery project to query against.
        :type googlebigquery_project: object
        :param googlebigquery_authentication_type: The OAuth 2.0 authentication mechanism used for
         authentication. ServiceAuthentication can only be used on self-hosted IR.
        :type googlebigquery_authentication_type: str or ~azure.mgmt.datafactory.models.GoogleBigQueryAuthenticationType
        :param if_match: ETag of the linkedService entity.  Should only be specified for update, for
         which it should match existing entity or can be * for unconditional update.
        :type if_match: str
        :param googlebigquery_connect_via: The integration runtime reference.
        :type googlebigquery_connect_via: ~azure.mgmt.datafactory.models.IntegrationRuntimeReference
        :param googlebigquery_description: Linked service description.
        :type googlebigquery_description: str
        :param googlebigquery_parameters: Parameters for linked service.
        :type googlebigquery_parameters: dict[str, ~azure.mgmt.datafactory.models.ParameterSpecification]
        :param googlebigquery_annotations: List of tags that can be used for describing the linked
         service.
        :type googlebigquery_annotations: list[object]
        :param googlebigquery_additional_projects: A comma-separated list of public BigQuery projects
         to access.
        :type googlebigquery_additional_projects: object
        :param googlebigquery_request_google_drive_scope: Whether to request access to Google Drive.
         Allowing Google Drive access enables support for federated tables that combine BigQuery data
         with data from Google Drive. The default value is false.
        :type googlebigquery_request_google_drive_scope: object
        :param googlebigquery_refresh_token: The refresh token obtained from Google for authorizing
         access to BigQuery for UserAuthentication.
        :type googlebigquery_refresh_token: ~azure.mgmt.datafactory.models.SecretBase
        :param googlebigquery_client_id: The client id of the google application used to acquire the
         refresh token. Type: string (or Expression with resultType string).
        :type googlebigquery_client_id: object
        :param googlebigquery_client_secret: The client secret of the google application used to
         acquire the refresh token.
        :type googlebigquery_client_secret: ~azure.mgmt.datafactory.models.SecretBase
        :param googlebigquery_email: The service account email ID that is used for
         ServiceAuthentication and can only be used on self-hosted IR.
        :type googlebigquery_email: object
        :param googlebigquery_key_file_path: The full path to the .p12 key file that is used to
         authenticate the service account email address and can only be used on self-hosted IR.
        :type googlebigquery_key_file_path: object
        :param googlebigquery_trusted_cert_path: The full path of the .pem file containing trusted CA
         certificates for verifying the server when connecting over SSL. This property can only be set
         when using SSL on self-hosted IR. The default value is the cacerts.pem file installed with the
         IR.
        :type googlebigquery_trusted_cert_path: object
        :param googlebigquery_use_system_trust_store: Specifies whether to use a CA certificate from
         the system trust store or from a specified PEM file. The default value is false.
        :type googlebigquery_use_system_trust_store: object
        :param googlebigquery_encrypted_credential: The encrypted credential used for authentication.
         Credentials are encrypted using the integration runtime credential manager. Type: string (or
         Expression with resultType string).
        :type googlebigquery_encrypted_credential: object
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: LinkedServiceResource or the result of cls(response)
        :rtype: ~azure.mgmt.datafactory.models.LinkedServiceResource
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.LinkedServiceResource"]
        error_map = kwargs.pop('error_map', {404: ResourceNotFoundError, 409: ResourceExistsError})

        _linked_service = models.LinkedServiceResource(properties=properties, type=googlebigquery_type, connect_via=googlebigquery_connect_via, description=googlebigquery_description, parameters=googlebigquery_parameters, annotations=googlebigquery_annotations, project=googlebigquery_project, additional_projects=googlebigquery_additional_projects, request_google_drive_scope=googlebigquery_request_google_drive_scope, authentication_type=googlebigquery_authentication_type, refresh_token=googlebigquery_refresh_token, client_id=googlebigquery_client_id, client_secret=googlebigquery_client_secret, email=googlebigquery_email, key_file_path=googlebigquery_key_file_path, trusted_cert_path=googlebigquery_trusted_cert_path, use_system_trust_store=googlebigquery_use_system_trust_store, encrypted_credential=googlebigquery_encrypted_credential)
        api_version = "2018-06-01"
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.create_or_update_googlebigquery.metadata['url']
        path_format_arguments = {
            'subscriptionId': self._serialize.url("self._config.subscription_id", self._config.subscription_id, 'str'),
            'resourceGroupName': self._serialize.url("resource_group_name", resource_group_name, 'str', max_length=90, min_length=1, pattern=r'^[-\w\._\(\)]+$'),
            'factoryName': self._serialize.url("factory_name", factory_name, 'str', max_length=63, min_length=3, pattern=r'^[A-Za-z0-9]+(?:-[A-Za-z0-9]+)*$'),
            'linkedServiceName': self._serialize.url("linked_service_name", linked_service_name, 'str', max_length=260, min_length=1, pattern=r'^[A-Za-z0-9_][^<>*#.%&:\\+?/]*$'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = 'application/json'

        # Construct and send request
        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_linked_service, 'LinkedServiceResource')
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = self._deserialize('LinkedServiceResource', pipeline_response)

        if cls:
          return cls(pipeline_response, deserialized, {})

        return deserialized
    create_or_update_googlebigquery.metadata = {'url': '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataFactory/factories/{factoryName}/linkedservices/{linkedServiceName}'}

    def create_or_update_googlecloudstorage(
        self,
        resource_group_name,  # type: str
        factory_name,  # type: str
        linked_service_name,  # type: str
        googlecloudstorage_type,  # type: str
        if_match=None,  # type: Optional[str]
        googlecloudstorage_connect_via=None,  # type: Optional["models.IntegrationRuntimeReference"]
        googlecloudstorage_description=None,  # type: Optional[str]
        googlecloudstorage_parameters=None,  # type: Optional[Dict[str, "ParameterSpecification"]]
        googlecloudstorage_annotations=None,  # type: Optional[List[object]]
        googlecloudstorage_access_key_id=None,  # type: Optional[object]
        googlecloudstorage_secret_access_key=None,  # type: Optional["models.SecretBase"]
        googlecloudstorage_service_url=None,  # type: Optional[object]
        googlecloudstorage_encrypted_credential=None,  # type: Optional[object]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.LinkedServiceResource"
        """Creates or updates a linked service.

        :param resource_group_name: The resource group name.
        :type resource_group_name: str
        :param factory_name: The factory name.
        :type factory_name: str
        :param linked_service_name: The linked service name.
        :type linked_service_name: str
        :param googlecloudstorage_type: Type of linked service.
        :type googlecloudstorage_type: str
        :param if_match: ETag of the linkedService entity.  Should only be specified for update, for
         which it should match existing entity or can be * for unconditional update.
        :type if_match: str
        :param googlecloudstorage_connect_via: The integration runtime reference.
        :type googlecloudstorage_connect_via: ~azure.mgmt.datafactory.models.IntegrationRuntimeReference
        :param googlecloudstorage_description: Linked service description.
        :type googlecloudstorage_description: str
        :param googlecloudstorage_parameters: Parameters for linked service.
        :type googlecloudstorage_parameters: dict[str, ~azure.mgmt.datafactory.models.ParameterSpecification]
        :param googlecloudstorage_annotations: List of tags that can be used for describing the linked
         service.
        :type googlecloudstorage_annotations: list[object]
        :param googlecloudstorage_access_key_id: The access key identifier of the Google Cloud Storage
         Identity and Access Management (IAM) user. Type: string (or Expression with resultType string).
        :type googlecloudstorage_access_key_id: object
        :param googlecloudstorage_secret_access_key: The secret access key of the Google Cloud Storage
         Identity and Access Management (IAM) user.
        :type googlecloudstorage_secret_access_key: ~azure.mgmt.datafactory.models.SecretBase
        :param googlecloudstorage_service_url: This value specifies the endpoint to access with the
         Google Cloud Storage Connector. This is an optional property; change it only if you want to try
         a different service endpoint or want to switch between https and http. Type: string (or
         Expression with resultType string).
        :type googlecloudstorage_service_url: object
        :param googlecloudstorage_encrypted_credential: The encrypted credential used for
         authentication. Credentials are encrypted using the integration runtime credential manager.
         Type: string (or Expression with resultType string).
        :type googlecloudstorage_encrypted_credential: object
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: LinkedServiceResource or the result of cls(response)
        :rtype: ~azure.mgmt.datafactory.models.LinkedServiceResource
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.LinkedServiceResource"]
        error_map = kwargs.pop('error_map', {404: ResourceNotFoundError, 409: ResourceExistsError})

        _linked_service = models.LinkedServiceResource(properties=properties, type=googlecloudstorage_type, connect_via=googlecloudstorage_connect_via, description=googlecloudstorage_description, parameters=googlecloudstorage_parameters, annotations=googlecloudstorage_annotations, access_key_id=googlecloudstorage_access_key_id, secret_access_key=googlecloudstorage_secret_access_key, service_url=googlecloudstorage_service_url, encrypted_credential=googlecloudstorage_encrypted_credential)
        api_version = "2018-06-01"
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.create_or_update_googlecloudstorage.metadata['url']
        path_format_arguments = {
            'subscriptionId': self._serialize.url("self._config.subscription_id", self._config.subscription_id, 'str'),
            'resourceGroupName': self._serialize.url("resource_group_name", resource_group_name, 'str', max_length=90, min_length=1, pattern=r'^[-\w\._\(\)]+$'),
            'factoryName': self._serialize.url("factory_name", factory_name, 'str', max_length=63, min_length=3, pattern=r'^[A-Za-z0-9]+(?:-[A-Za-z0-9]+)*$'),
            'linkedServiceName': self._serialize.url("linked_service_name", linked_service_name, 'str', max_length=260, min_length=1, pattern=r'^[A-Za-z0-9_][^<>*#.%&:\\+?/]*$'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = 'application/json'

        # Construct and send request
        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_linked_service, 'LinkedServiceResource')
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = self._deserialize('LinkedServiceResource', pipeline_response)

        if cls:
          return cls(pipeline_response, deserialized, {})

        return deserialized
    create_or_update_googlecloudstorage.metadata = {'url': '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataFactory/factories/{factoryName}/linkedservices/{linkedServiceName}'}

    def create_or_update_greenplum(
        self,
        resource_group_name,  # type: str
        factory_name,  # type: str
        linked_service_name,  # type: str
        greenplum_type,  # type: str
        if_match=None,  # type: Optional[str]
        greenplum_connect_via=None,  # type: Optional["models.IntegrationRuntimeReference"]
        greenplum_description=None,  # type: Optional[str]
        greenplum_parameters=None,  # type: Optional[Dict[str, "ParameterSpecification"]]
        greenplum_annotations=None,  # type: Optional[List[object]]
        greenplum_connection_string=None,  # type: Optional[object]
        greenplum_pwd=None,  # type: Optional["models.AzureKeyVaultSecretReference"]
        greenplum_encrypted_credential=None,  # type: Optional[object]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.LinkedServiceResource"
        """Creates or updates a linked service.

        :param resource_group_name: The resource group name.
        :type resource_group_name: str
        :param factory_name: The factory name.
        :type factory_name: str
        :param linked_service_name: The linked service name.
        :type linked_service_name: str
        :param greenplum_type: Type of linked service.
        :type greenplum_type: str
        :param if_match: ETag of the linkedService entity.  Should only be specified for update, for
         which it should match existing entity or can be * for unconditional update.
        :type if_match: str
        :param greenplum_connect_via: The integration runtime reference.
        :type greenplum_connect_via: ~azure.mgmt.datafactory.models.IntegrationRuntimeReference
        :param greenplum_description: Linked service description.
        :type greenplum_description: str
        :param greenplum_parameters: Parameters for linked service.
        :type greenplum_parameters: dict[str, ~azure.mgmt.datafactory.models.ParameterSpecification]
        :param greenplum_annotations: List of tags that can be used for describing the linked service.
        :type greenplum_annotations: list[object]
        :param greenplum_connection_string: An ODBC connection string. Type: string, SecureString or
         AzureKeyVaultSecretReference.
        :type greenplum_connection_string: object
        :param greenplum_pwd: The Azure key vault secret reference of password in connection string.
        :type greenplum_pwd: ~azure.mgmt.datafactory.models.AzureKeyVaultSecretReference
        :param greenplum_encrypted_credential: The encrypted credential used for authentication.
         Credentials are encrypted using the integration runtime credential manager. Type: string (or
         Expression with resultType string).
        :type greenplum_encrypted_credential: object
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: LinkedServiceResource or the result of cls(response)
        :rtype: ~azure.mgmt.datafactory.models.LinkedServiceResource
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.LinkedServiceResource"]
        error_map = kwargs.pop('error_map', {404: ResourceNotFoundError, 409: ResourceExistsError})

        _linked_service = models.LinkedServiceResource(properties=properties, type=greenplum_type, connect_via=greenplum_connect_via, description=greenplum_description, parameters=greenplum_parameters, annotations=greenplum_annotations, connection_string=greenplum_connection_string, pwd=greenplum_pwd, encrypted_credential=greenplum_encrypted_credential)
        api_version = "2018-06-01"
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.create_or_update_greenplum.metadata['url']
        path_format_arguments = {
            'subscriptionId': self._serialize.url("self._config.subscription_id", self._config.subscription_id, 'str'),
            'resourceGroupName': self._serialize.url("resource_group_name", resource_group_name, 'str', max_length=90, min_length=1, pattern=r'^[-\w\._\(\)]+$'),
            'factoryName': self._serialize.url("factory_name", factory_name, 'str', max_length=63, min_length=3, pattern=r'^[A-Za-z0-9]+(?:-[A-Za-z0-9]+)*$'),
            'linkedServiceName': self._serialize.url("linked_service_name", linked_service_name, 'str', max_length=260, min_length=1, pattern=r'^[A-Za-z0-9_][^<>*#.%&:\\+?/]*$'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = 'application/json'

        # Construct and send request
        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_linked_service, 'LinkedServiceResource')
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = self._deserialize('LinkedServiceResource', pipeline_response)

        if cls:
          return cls(pipeline_response, deserialized, {})

        return deserialized
    create_or_update_greenplum.metadata = {'url': '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataFactory/factories/{factoryName}/linkedservices/{linkedServiceName}'}

    def create_or_update_hbase(
        self,
        resource_group_name,  # type: str
        factory_name,  # type: str
        linked_service_name,  # type: str
        hbase_type,  # type: str
        hbase_host,  # type: object
        hbase_authentication_type,  # type: Union[str, "models.HBaseAuthenticationType"]
        if_match=None,  # type: Optional[str]
        hbase_connect_via=None,  # type: Optional["models.IntegrationRuntimeReference"]
        hbase_description=None,  # type: Optional[str]
        hbase_parameters=None,  # type: Optional[Dict[str, "ParameterSpecification"]]
        hbase_annotations=None,  # type: Optional[List[object]]
        hbase_port=None,  # type: Optional[object]
        hbase_http_path=None,  # type: Optional[object]
        hbase_username=None,  # type: Optional[object]
        hbase_password=None,  # type: Optional["models.SecretBase"]
        hbase_enable_ssl=None,  # type: Optional[object]
        hbase_trusted_cert_path=None,  # type: Optional[object]
        hbase_allow_host_name_cn_mismatch=None,  # type: Optional[object]
        hbase_allow_self_signed_server_cert=None,  # type: Optional[object]
        hbase_encrypted_credential=None,  # type: Optional[object]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.LinkedServiceResource"
        """Creates or updates a linked service.

        :param resource_group_name: The resource group name.
        :type resource_group_name: str
        :param factory_name: The factory name.
        :type factory_name: str
        :param linked_service_name: The linked service name.
        :type linked_service_name: str
        :param hbase_type: Type of linked service.
        :type hbase_type: str
        :param hbase_host: The IP address or host name of the HBase server. (i.e. 192.168.222.160).
        :type hbase_host: object
        :param hbase_authentication_type: The authentication mechanism to use to connect to the HBase
         server.
        :type hbase_authentication_type: str or ~azure.mgmt.datafactory.models.HBaseAuthenticationType
        :param if_match: ETag of the linkedService entity.  Should only be specified for update, for
         which it should match existing entity or can be * for unconditional update.
        :type if_match: str
        :param hbase_connect_via: The integration runtime reference.
        :type hbase_connect_via: ~azure.mgmt.datafactory.models.IntegrationRuntimeReference
        :param hbase_description: Linked service description.
        :type hbase_description: str
        :param hbase_parameters: Parameters for linked service.
        :type hbase_parameters: dict[str, ~azure.mgmt.datafactory.models.ParameterSpecification]
        :param hbase_annotations: List of tags that can be used for describing the linked service.
        :type hbase_annotations: list[object]
        :param hbase_port: The TCP port that the HBase instance uses to listen for client connections.
         The default value is 9090.
        :type hbase_port: object
        :param hbase_http_path: The partial URL corresponding to the HBase server. (i.e.
         /gateway/sandbox/hbase/version).
        :type hbase_http_path: object
        :param hbase_username: The user name used to connect to the HBase instance.
        :type hbase_username: object
        :param hbase_password: The password corresponding to the user name.
        :type hbase_password: ~azure.mgmt.datafactory.models.SecretBase
        :param hbase_enable_ssl: Specifies whether the connections to the server are encrypted using
         SSL. The default value is false.
        :type hbase_enable_ssl: object
        :param hbase_trusted_cert_path: The full path of the .pem file containing trusted CA
         certificates for verifying the server when connecting over SSL. This property can only be set
         when using SSL on self-hosted IR. The default value is the cacerts.pem file installed with the
         IR.
        :type hbase_trusted_cert_path: object
        :param hbase_allow_host_name_cn_mismatch: Specifies whether to require a CA-issued SSL
         certificate name to match the host name of the server when connecting over SSL. The default
         value is false.
        :type hbase_allow_host_name_cn_mismatch: object
        :param hbase_allow_self_signed_server_cert: Specifies whether to allow self-signed certificates
         from the server. The default value is false.
        :type hbase_allow_self_signed_server_cert: object
        :param hbase_encrypted_credential: The encrypted credential used for authentication.
         Credentials are encrypted using the integration runtime credential manager. Type: string (or
         Expression with resultType string).
        :type hbase_encrypted_credential: object
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: LinkedServiceResource or the result of cls(response)
        :rtype: ~azure.mgmt.datafactory.models.LinkedServiceResource
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.LinkedServiceResource"]
        error_map = kwargs.pop('error_map', {404: ResourceNotFoundError, 409: ResourceExistsError})

        _linked_service = models.LinkedServiceResource(properties=properties, type=hbase_type, connect_via=hbase_connect_via, description=hbase_description, parameters=hbase_parameters, annotations=hbase_annotations, host=hbase_host, port=hbase_port, http_path=hbase_http_path, authentication_type=hbase_authentication_type, username=hbase_username, password=hbase_password, enable_ssl=hbase_enable_ssl, trusted_cert_path=hbase_trusted_cert_path, allow_host_name_cn_mismatch=hbase_allow_host_name_cn_mismatch, allow_self_signed_server_cert=hbase_allow_self_signed_server_cert, encrypted_credential=hbase_encrypted_credential)
        api_version = "2018-06-01"
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.create_or_update_hbase.metadata['url']
        path_format_arguments = {
            'subscriptionId': self._serialize.url("self._config.subscription_id", self._config.subscription_id, 'str'),
            'resourceGroupName': self._serialize.url("resource_group_name", resource_group_name, 'str', max_length=90, min_length=1, pattern=r'^[-\w\._\(\)]+$'),
            'factoryName': self._serialize.url("factory_name", factory_name, 'str', max_length=63, min_length=3, pattern=r'^[A-Za-z0-9]+(?:-[A-Za-z0-9]+)*$'),
            'linkedServiceName': self._serialize.url("linked_service_name", linked_service_name, 'str', max_length=260, min_length=1, pattern=r'^[A-Za-z0-9_][^<>*#.%&:\\+?/]*$'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = 'application/json'

        # Construct and send request
        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_linked_service, 'LinkedServiceResource')
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = self._deserialize('LinkedServiceResource', pipeline_response)

        if cls:
          return cls(pipeline_response, deserialized, {})

        return deserialized
    create_or_update_hbase.metadata = {'url': '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataFactory/factories/{factoryName}/linkedservices/{linkedServiceName}'}

    def create_or_update_hdinsight(
        self,
        resource_group_name,  # type: str
        factory_name,  # type: str
        linked_service_name,  # type: str
        hdinsight_type,  # type: str
        hdinsight_cluster_uri,  # type: object
        if_match=None,  # type: Optional[str]
        hdinsight_connect_via=None,  # type: Optional["models.IntegrationRuntimeReference"]
        hdinsight_description=None,  # type: Optional[str]
        hdinsight_parameters=None,  # type: Optional[Dict[str, "ParameterSpecification"]]
        hdinsight_annotations=None,  # type: Optional[List[object]]
        hdinsight_user_name=None,  # type: Optional[object]
        hdinsight_password=None,  # type: Optional["models.SecretBase"]
        hdinsight_linked_service_name=None,  # type: Optional["models.LinkedServiceReference"]
        hdinsight_hcatalog_linked_service_name=None,  # type: Optional["models.LinkedServiceReference"]
        hdinsight_encrypted_credential=None,  # type: Optional[object]
        hdinsight_is_esp_enabled=None,  # type: Optional[object]
        hdinsight_file_system=None,  # type: Optional[object]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.LinkedServiceResource"
        """Creates or updates a linked service.

        :param resource_group_name: The resource group name.
        :type resource_group_name: str
        :param factory_name: The factory name.
        :type factory_name: str
        :param linked_service_name: The linked service name.
        :type linked_service_name: str
        :param hdinsight_type: Type of linked service.
        :type hdinsight_type: str
        :param hdinsight_cluster_uri: HDInsight cluster URI. Type: string (or Expression with
         resultType string).
        :type hdinsight_cluster_uri: object
        :param if_match: ETag of the linkedService entity.  Should only be specified for update, for
         which it should match existing entity or can be * for unconditional update.
        :type if_match: str
        :param hdinsight_connect_via: The integration runtime reference.
        :type hdinsight_connect_via: ~azure.mgmt.datafactory.models.IntegrationRuntimeReference
        :param hdinsight_description: Linked service description.
        :type hdinsight_description: str
        :param hdinsight_parameters: Parameters for linked service.
        :type hdinsight_parameters: dict[str, ~azure.mgmt.datafactory.models.ParameterSpecification]
        :param hdinsight_annotations: List of tags that can be used for describing the linked service.
        :type hdinsight_annotations: list[object]
        :param hdinsight_user_name: HDInsight cluster user name. Type: string (or Expression with
         resultType string).
        :type hdinsight_user_name: object
        :param hdinsight_password: HDInsight cluster password.
        :type hdinsight_password: ~azure.mgmt.datafactory.models.SecretBase
        :param hdinsight_linked_service_name: The Azure Storage linked service reference.
        :type hdinsight_linked_service_name: ~azure.mgmt.datafactory.models.LinkedServiceReference
        :param hdinsight_hcatalog_linked_service_name: A reference to the Azure SQL linked service that
         points to the HCatalog database.
        :type hdinsight_hcatalog_linked_service_name: ~azure.mgmt.datafactory.models.LinkedServiceReference
        :param hdinsight_encrypted_credential: The encrypted credential used for authentication.
         Credentials are encrypted using the integration runtime credential manager. Type: string (or
         Expression with resultType string).
        :type hdinsight_encrypted_credential: object
        :param hdinsight_is_esp_enabled: Specify if the HDInsight is created with ESP (Enterprise
         Security Package). Type: Boolean.
        :type hdinsight_is_esp_enabled: object
        :param hdinsight_file_system: Specify the FileSystem if the main storage for the HDInsight is
         ADLS Gen2. Type: string (or Expression with resultType string).
        :type hdinsight_file_system: object
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: LinkedServiceResource or the result of cls(response)
        :rtype: ~azure.mgmt.datafactory.models.LinkedServiceResource
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.LinkedServiceResource"]
        error_map = kwargs.pop('error_map', {404: ResourceNotFoundError, 409: ResourceExistsError})

        _linked_service = models.LinkedServiceResource(properties=properties, type=hdinsight_type, connect_via=hdinsight_connect_via, description=hdinsight_description, parameters=hdinsight_parameters, annotations=hdinsight_annotations, cluster_uri=hdinsight_cluster_uri, user_name=hdinsight_user_name, password=hdinsight_password, linked_service_name=hdinsight_linked_service_name, hcatalog_linked_service_name=hdinsight_hcatalog_linked_service_name, encrypted_credential=hdinsight_encrypted_credential, is_esp_enabled=hdinsight_is_esp_enabled, file_system=hdinsight_file_system)
        api_version = "2018-06-01"
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.create_or_update_hdinsight.metadata['url']
        path_format_arguments = {
            'subscriptionId': self._serialize.url("self._config.subscription_id", self._config.subscription_id, 'str'),
            'resourceGroupName': self._serialize.url("resource_group_name", resource_group_name, 'str', max_length=90, min_length=1, pattern=r'^[-\w\._\(\)]+$'),
            'factoryName': self._serialize.url("factory_name", factory_name, 'str', max_length=63, min_length=3, pattern=r'^[A-Za-z0-9]+(?:-[A-Za-z0-9]+)*$'),
            'linkedServiceName': self._serialize.url("linked_service_name", linked_service_name, 'str', max_length=260, min_length=1, pattern=r'^[A-Za-z0-9_][^<>*#.%&:\\+?/]*$'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = 'application/json'

        # Construct and send request
        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_linked_service, 'LinkedServiceResource')
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = self._deserialize('LinkedServiceResource', pipeline_response)

        if cls:
          return cls(pipeline_response, deserialized, {})

        return deserialized
    create_or_update_hdinsight.metadata = {'url': '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataFactory/factories/{factoryName}/linkedservices/{linkedServiceName}'}

    def create_or_update_hdinsightondemand(
        self,
        resource_group_name,  # type: str
        factory_name,  # type: str
        linked_service_name,  # type: str
        hdinsightondemand_type,  # type: str
        hdinsightondemand_cluster_size,  # type: object
        hdinsightondemand_time_to_live,  # type: object
        hdinsightondemand_version,  # type: object
        hdinsightondemand_linked_service_name,  # type: "models.LinkedServiceReference"
        hdinsightondemand_host_subscription_id,  # type: object
        hdinsightondemand_tenant,  # type: object
        hdinsightondemand_cluster_resource_group,  # type: object
        if_match=None,  # type: Optional[str]
        hdinsightondemand_connect_via=None,  # type: Optional["models.IntegrationRuntimeReference"]
        hdinsightondemand_description=None,  # type: Optional[str]
        hdinsightondemand_parameters=None,  # type: Optional[Dict[str, "ParameterSpecification"]]
        hdinsightondemand_annotations=None,  # type: Optional[List[object]]
        hdinsightondemand_service_principal_id=None,  # type: Optional[object]
        hdinsightondemand_service_principal_key=None,  # type: Optional["models.SecretBase"]
        hdinsightondemand_cluster_name_prefix=None,  # type: Optional[object]
        hdinsightondemand_cluster_user_name=None,  # type: Optional[object]
        hdinsightondemand_cluster_password=None,  # type: Optional["models.SecretBase"]
        hdinsightondemand_cluster_ssh_user_name=None,  # type: Optional[object]
        hdinsightondemand_cluster_ssh_password=None,  # type: Optional["models.SecretBase"]
        hdinsightondemand_additional_linked_service_names=None,  # type: Optional[List["LinkedServiceReference"]]
        hdinsightondemand_hcatalog_linked_service_name=None,  # type: Optional["models.LinkedServiceReference"]
        hdinsightondemand_cluster_type=None,  # type: Optional[object]
        hdinsightondemand_spark_version=None,  # type: Optional[object]
        hdinsightondemand_core_configuration=None,  # type: Optional[object]
        hdinsightondemand_h_base_configuration=None,  # type: Optional[object]
        hdinsightondemand_hdfs_configuration=None,  # type: Optional[object]
        hdinsightondemand_hive_configuration=None,  # type: Optional[object]
        hdinsightondemand_map_reduce_configuration=None,  # type: Optional[object]
        hdinsightondemand_oozie_configuration=None,  # type: Optional[object]
        hdinsightondemand_storm_configuration=None,  # type: Optional[object]
        hdinsightondemand_yarn_configuration=None,  # type: Optional[object]
        hdinsightondemand_encrypted_credential=None,  # type: Optional[object]
        hdinsightondemand_head_node_size=None,  # type: Optional[object]
        hdinsightondemand_data_node_size=None,  # type: Optional[object]
        hdinsightondemand_zookeeper_node_size=None,  # type: Optional[object]
        hdinsightondemand_script_actions=None,  # type: Optional[List["ScriptAction"]]
        hdinsightondemand_virtual_network_id=None,  # type: Optional[object]
        hdinsightondemand_subnet_name=None,  # type: Optional[object]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.LinkedServiceResource"
        """Creates or updates a linked service.

        :param resource_group_name: The resource group name.
        :type resource_group_name: str
        :param factory_name: The factory name.
        :type factory_name: str
        :param linked_service_name: The linked service name.
        :type linked_service_name: str
        :param hdinsightondemand_type: Type of linked service.
        :type hdinsightondemand_type: str
        :param hdinsightondemand_cluster_size: Number of worker/data nodes in the cluster. Suggestion
         value: 4. Type: string (or Expression with resultType string).
        :type hdinsightondemand_cluster_size: object
        :param hdinsightondemand_time_to_live: The allowed idle time for the on-demand HDInsight
         cluster. Specifies how long the on-demand HDInsight cluster stays alive after completion of an
         activity run if there are no other active jobs in the cluster. The minimum value is 5 mins.
         Type: string (or Expression with resultType string).
        :type hdinsightondemand_time_to_live: object
        :param hdinsightondemand_version: Version of the HDInsight cluster.  Type: string (or
         Expression with resultType string).
        :type hdinsightondemand_version: object
        :param hdinsightondemand_linked_service_name: Azure Storage linked service to be used by the
         on-demand cluster for storing and processing data.
        :type hdinsightondemand_linked_service_name: ~azure.mgmt.datafactory.models.LinkedServiceReference
        :param hdinsightondemand_host_subscription_id: The customer’s subscription to host the cluster.
         Type: string (or Expression with resultType string).
        :type hdinsightondemand_host_subscription_id: object
        :param hdinsightondemand_tenant: The Tenant id/name to which the service principal belongs.
         Type: string (or Expression with resultType string).
        :type hdinsightondemand_tenant: object
        :param hdinsightondemand_cluster_resource_group: The resource group where the cluster belongs.
         Type: string (or Expression with resultType string).
        :type hdinsightondemand_cluster_resource_group: object
        :param if_match: ETag of the linkedService entity.  Should only be specified for update, for
         which it should match existing entity or can be * for unconditional update.
        :type if_match: str
        :param hdinsightondemand_connect_via: The integration runtime reference.
        :type hdinsightondemand_connect_via: ~azure.mgmt.datafactory.models.IntegrationRuntimeReference
        :param hdinsightondemand_description: Linked service description.
        :type hdinsightondemand_description: str
        :param hdinsightondemand_parameters: Parameters for linked service.
        :type hdinsightondemand_parameters: dict[str, ~azure.mgmt.datafactory.models.ParameterSpecification]
        :param hdinsightondemand_annotations: List of tags that can be used for describing the linked
         service.
        :type hdinsightondemand_annotations: list[object]
        :param hdinsightondemand_service_principal_id: The service principal id for the
         hostSubscriptionId. Type: string (or Expression with resultType string).
        :type hdinsightondemand_service_principal_id: object
        :param hdinsightondemand_service_principal_key: The key for the service principal id.
        :type hdinsightondemand_service_principal_key: ~azure.mgmt.datafactory.models.SecretBase
        :param hdinsightondemand_cluster_name_prefix: The prefix of cluster name, postfix will be
         distinct with timestamp. Type: string (or Expression with resultType string).
        :type hdinsightondemand_cluster_name_prefix: object
        :param hdinsightondemand_cluster_user_name: The username to access the cluster. Type: string
         (or Expression with resultType string).
        :type hdinsightondemand_cluster_user_name: object
        :param hdinsightondemand_cluster_password: The password to access the cluster.
        :type hdinsightondemand_cluster_password: ~azure.mgmt.datafactory.models.SecretBase
        :param hdinsightondemand_cluster_ssh_user_name: The username to SSH remotely connect to
         cluster’s node (for Linux). Type: string (or Expression with resultType string).
        :type hdinsightondemand_cluster_ssh_user_name: object
        :param hdinsightondemand_cluster_ssh_password: The password to SSH remotely connect cluster’s
         node (for Linux).
        :type hdinsightondemand_cluster_ssh_password: ~azure.mgmt.datafactory.models.SecretBase
        :param hdinsightondemand_additional_linked_service_names: Specifies additional storage accounts
         for the HDInsight linked service so that the Data Factory service can register them on your
         behalf.
        :type hdinsightondemand_additional_linked_service_names: list[~azure.mgmt.datafactory.models.LinkedServiceReference]
        :param hdinsightondemand_hcatalog_linked_service_name: The name of Azure SQL linked service
         that point to the HCatalog database. The on-demand HDInsight cluster is created by using the
         Azure SQL database as the metastore.
        :type hdinsightondemand_hcatalog_linked_service_name: ~azure.mgmt.datafactory.models.LinkedServiceReference
        :param hdinsightondemand_cluster_type: The cluster type. Type: string (or Expression with
         resultType string).
        :type hdinsightondemand_cluster_type: object
        :param hdinsightondemand_spark_version: The version of spark if the cluster type is 'spark'.
         Type: string (or Expression with resultType string).
        :type hdinsightondemand_spark_version: object
        :param hdinsightondemand_core_configuration: Specifies the core configuration parameters (as in
         core-site.xml) for the HDInsight cluster to be created.
        :type hdinsightondemand_core_configuration: object
        :param hdinsightondemand_h_base_configuration: Specifies the HBase configuration parameters
         (hbase-site.xml) for the HDInsight cluster.
        :type hdinsightondemand_h_base_configuration: object
        :param hdinsightondemand_hdfs_configuration: Specifies the HDFS configuration parameters (hdfs-
         site.xml) for the HDInsight cluster.
        :type hdinsightondemand_hdfs_configuration: object
        :param hdinsightondemand_hive_configuration: Specifies the hive configuration parameters (hive-
         site.xml) for the HDInsight cluster.
        :type hdinsightondemand_hive_configuration: object
        :param hdinsightondemand_map_reduce_configuration: Specifies the MapReduce configuration
         parameters (mapred-site.xml) for the HDInsight cluster.
        :type hdinsightondemand_map_reduce_configuration: object
        :param hdinsightondemand_oozie_configuration: Specifies the Oozie configuration parameters
         (oozie-site.xml) for the HDInsight cluster.
        :type hdinsightondemand_oozie_configuration: object
        :param hdinsightondemand_storm_configuration: Specifies the Storm configuration parameters
         (storm-site.xml) for the HDInsight cluster.
        :type hdinsightondemand_storm_configuration: object
        :param hdinsightondemand_yarn_configuration: Specifies the Yarn configuration parameters (yarn-
         site.xml) for the HDInsight cluster.
        :type hdinsightondemand_yarn_configuration: object
        :param hdinsightondemand_encrypted_credential: The encrypted credential used for
         authentication. Credentials are encrypted using the integration runtime credential manager.
         Type: string (or Expression with resultType string).
        :type hdinsightondemand_encrypted_credential: object
        :param hdinsightondemand_head_node_size: Specifies the size of the head node for the HDInsight
         cluster.
        :type hdinsightondemand_head_node_size: object
        :param hdinsightondemand_data_node_size: Specifies the size of the data node for the HDInsight
         cluster.
        :type hdinsightondemand_data_node_size: object
        :param hdinsightondemand_zookeeper_node_size: Specifies the size of the Zoo Keeper node for the
         HDInsight cluster.
        :type hdinsightondemand_zookeeper_node_size: object
        :param hdinsightondemand_script_actions: Custom script actions to run on HDI ondemand cluster
         once it's up. Please refer to https://docs.microsoft.com/en-us/azure/hdinsight/hdinsight-
         hadoop-customize-cluster-linux?toc=%2Fen-us%2Fazure%2Fhdinsight%2Fr-server%2FTOC.json&bc=%2Fen-
         us%2Fazure%2Fbread%2Ftoc.json#understanding-script-actions.
        :type hdinsightondemand_script_actions: list[~azure.mgmt.datafactory.models.ScriptAction]
        :param hdinsightondemand_virtual_network_id: The ARM resource ID for the vNet to which the
         cluster should be joined after creation. Type: string (or Expression with resultType string).
        :type hdinsightondemand_virtual_network_id: object
        :param hdinsightondemand_subnet_name: The ARM resource ID for the subnet in the vNet. If
         virtualNetworkId was specified, then this property is required. Type: string (or Expression
         with resultType string).
        :type hdinsightondemand_subnet_name: object
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: LinkedServiceResource or the result of cls(response)
        :rtype: ~azure.mgmt.datafactory.models.LinkedServiceResource
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.LinkedServiceResource"]
        error_map = kwargs.pop('error_map', {404: ResourceNotFoundError, 409: ResourceExistsError})

        _linked_service = models.LinkedServiceResource(properties=properties, type=hdinsightondemand_type, connect_via=hdinsightondemand_connect_via, description=hdinsightondemand_description, parameters=hdinsightondemand_parameters, annotations=hdinsightondemand_annotations, cluster_size=hdinsightondemand_cluster_size, time_to_live=hdinsightondemand_time_to_live, version=hdinsightondemand_version, linked_service_name=hdinsightondemand_linked_service_name, host_subscription_id=hdinsightondemand_host_subscription_id, service_principal_id=hdinsightondemand_service_principal_id, service_principal_key=hdinsightondemand_service_principal_key, tenant=hdinsightondemand_tenant, cluster_resource_group=hdinsightondemand_cluster_resource_group, cluster_name_prefix=hdinsightondemand_cluster_name_prefix, cluster_user_name=hdinsightondemand_cluster_user_name, cluster_password=hdinsightondemand_cluster_password, cluster_ssh_user_name=hdinsightondemand_cluster_ssh_user_name, cluster_ssh_password=hdinsightondemand_cluster_ssh_password, additional_linked_service_names=hdinsightondemand_additional_linked_service_names, hcatalog_linked_service_name=hdinsightondemand_hcatalog_linked_service_name, cluster_type=hdinsightondemand_cluster_type, spark_version=hdinsightondemand_spark_version, core_configuration=hdinsightondemand_core_configuration, h_base_configuration=hdinsightondemand_h_base_configuration, hdfs_configuration=hdinsightondemand_hdfs_configuration, hive_configuration=hdinsightondemand_hive_configuration, map_reduce_configuration=hdinsightondemand_map_reduce_configuration, oozie_configuration=hdinsightondemand_oozie_configuration, storm_configuration=hdinsightondemand_storm_configuration, yarn_configuration=hdinsightondemand_yarn_configuration, encrypted_credential=hdinsightondemand_encrypted_credential, head_node_size=hdinsightondemand_head_node_size, data_node_size=hdinsightondemand_data_node_size, zookeeper_node_size=hdinsightondemand_zookeeper_node_size, script_actions=hdinsightondemand_script_actions, virtual_network_id=hdinsightondemand_virtual_network_id, subnet_name=hdinsightondemand_subnet_name)
        api_version = "2018-06-01"
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.create_or_update_hdinsightondemand.metadata['url']
        path_format_arguments = {
            'subscriptionId': self._serialize.url("self._config.subscription_id", self._config.subscription_id, 'str'),
            'resourceGroupName': self._serialize.url("resource_group_name", resource_group_name, 'str', max_length=90, min_length=1, pattern=r'^[-\w\._\(\)]+$'),
            'factoryName': self._serialize.url("factory_name", factory_name, 'str', max_length=63, min_length=3, pattern=r'^[A-Za-z0-9]+(?:-[A-Za-z0-9]+)*$'),
            'linkedServiceName': self._serialize.url("linked_service_name", linked_service_name, 'str', max_length=260, min_length=1, pattern=r'^[A-Za-z0-9_][^<>*#.%&:\\+?/]*$'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = 'application/json'

        # Construct and send request
        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_linked_service, 'LinkedServiceResource')
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = self._deserialize('LinkedServiceResource', pipeline_response)

        if cls:
          return cls(pipeline_response, deserialized, {})

        return deserialized
    create_or_update_hdinsightondemand.metadata = {'url': '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataFactory/factories/{factoryName}/linkedservices/{linkedServiceName}'}

    def create_or_update_hdfs(
        self,
        resource_group_name,  # type: str
        factory_name,  # type: str
        linked_service_name,  # type: str
        hdfs_type,  # type: str
        hdfs_url,  # type: object
        if_match=None,  # type: Optional[str]
        hdfs_connect_via=None,  # type: Optional["models.IntegrationRuntimeReference"]
        hdfs_description=None,  # type: Optional[str]
        hdfs_parameters=None,  # type: Optional[Dict[str, "ParameterSpecification"]]
        hdfs_annotations=None,  # type: Optional[List[object]]
        hdfs_authentication_type=None,  # type: Optional[object]
        hdfs_encrypted_credential=None,  # type: Optional[object]
        hdfs_user_name=None,  # type: Optional[object]
        hdfs_password=None,  # type: Optional["models.SecretBase"]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.LinkedServiceResource"
        """Creates or updates a linked service.

        :param resource_group_name: The resource group name.
        :type resource_group_name: str
        :param factory_name: The factory name.
        :type factory_name: str
        :param linked_service_name: The linked service name.
        :type linked_service_name: str
        :param hdfs_type: Type of linked service.
        :type hdfs_type: str
        :param hdfs_url: The URL of the HDFS service endpoint, e.g. http://myhostname:50070/webhdfs/v1
         . Type: string (or Expression with resultType string).
        :type hdfs_url: object
        :param if_match: ETag of the linkedService entity.  Should only be specified for update, for
         which it should match existing entity or can be * for unconditional update.
        :type if_match: str
        :param hdfs_connect_via: The integration runtime reference.
        :type hdfs_connect_via: ~azure.mgmt.datafactory.models.IntegrationRuntimeReference
        :param hdfs_description: Linked service description.
        :type hdfs_description: str
        :param hdfs_parameters: Parameters for linked service.
        :type hdfs_parameters: dict[str, ~azure.mgmt.datafactory.models.ParameterSpecification]
        :param hdfs_annotations: List of tags that can be used for describing the linked service.
        :type hdfs_annotations: list[object]
        :param hdfs_authentication_type: Type of authentication used to connect to the HDFS. Possible
         values are: Anonymous and Windows. Type: string (or Expression with resultType string).
        :type hdfs_authentication_type: object
        :param hdfs_encrypted_credential: The encrypted credential used for authentication. Credentials
         are encrypted using the integration runtime credential manager. Type: string (or Expression
         with resultType string).
        :type hdfs_encrypted_credential: object
        :param hdfs_user_name: User name for Windows authentication. Type: string (or Expression with
         resultType string).
        :type hdfs_user_name: object
        :param hdfs_password: Password for Windows authentication.
        :type hdfs_password: ~azure.mgmt.datafactory.models.SecretBase
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: LinkedServiceResource or the result of cls(response)
        :rtype: ~azure.mgmt.datafactory.models.LinkedServiceResource
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.LinkedServiceResource"]
        error_map = kwargs.pop('error_map', {404: ResourceNotFoundError, 409: ResourceExistsError})

        _linked_service = models.LinkedServiceResource(properties=properties, type=hdfs_type, connect_via=hdfs_connect_via, description=hdfs_description, parameters=hdfs_parameters, annotations=hdfs_annotations, url=hdfs_url, authentication_type=hdfs_authentication_type, encrypted_credential=hdfs_encrypted_credential, user_name=hdfs_user_name, password=hdfs_password)
        api_version = "2018-06-01"
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.create_or_update_hdfs.metadata['url']
        path_format_arguments = {
            'subscriptionId': self._serialize.url("self._config.subscription_id", self._config.subscription_id, 'str'),
            'resourceGroupName': self._serialize.url("resource_group_name", resource_group_name, 'str', max_length=90, min_length=1, pattern=r'^[-\w\._\(\)]+$'),
            'factoryName': self._serialize.url("factory_name", factory_name, 'str', max_length=63, min_length=3, pattern=r'^[A-Za-z0-9]+(?:-[A-Za-z0-9]+)*$'),
            'linkedServiceName': self._serialize.url("linked_service_name", linked_service_name, 'str', max_length=260, min_length=1, pattern=r'^[A-Za-z0-9_][^<>*#.%&:\\+?/]*$'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = 'application/json'

        # Construct and send request
        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_linked_service, 'LinkedServiceResource')
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = self._deserialize('LinkedServiceResource', pipeline_response)

        if cls:
          return cls(pipeline_response, deserialized, {})

        return deserialized
    create_or_update_hdfs.metadata = {'url': '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataFactory/factories/{factoryName}/linkedservices/{linkedServiceName}'}

    def create_or_update_hive(
        self,
        resource_group_name,  # type: str
        factory_name,  # type: str
        linked_service_name,  # type: str
        hive_type,  # type: str
        hive_host,  # type: object
        hive_authentication_type,  # type: Union[str, "models.HiveAuthenticationType"]
        if_match=None,  # type: Optional[str]
        hive_connect_via=None,  # type: Optional["models.IntegrationRuntimeReference"]
        hive_description=None,  # type: Optional[str]
        hive_parameters=None,  # type: Optional[Dict[str, "ParameterSpecification"]]
        hive_annotations=None,  # type: Optional[List[object]]
        hive_port=None,  # type: Optional[object]
        hive_server_type=None,  # type: Optional[Union[str, "models.HiveServerType"]]
        hive_thrift_transport_protocol=None,  # type: Optional[Union[str, "models.HiveThriftTransportProtocol"]]
        hive_service_discovery_mode=None,  # type: Optional[object]
        hive_zoo_keeper_name_space=None,  # type: Optional[object]
        hive_use_native_query=None,  # type: Optional[object]
        hive_username=None,  # type: Optional[object]
        hive_password=None,  # type: Optional["models.SecretBase"]
        hive_http_path=None,  # type: Optional[object]
        hive_enable_ssl=None,  # type: Optional[object]
        hive_trusted_cert_path=None,  # type: Optional[object]
        hive_use_system_trust_store=None,  # type: Optional[object]
        hive_allow_host_name_cn_mismatch=None,  # type: Optional[object]
        hive_allow_self_signed_server_cert=None,  # type: Optional[object]
        hive_encrypted_credential=None,  # type: Optional[object]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.LinkedServiceResource"
        """Creates or updates a linked service.

        :param resource_group_name: The resource group name.
        :type resource_group_name: str
        :param factory_name: The factory name.
        :type factory_name: str
        :param linked_service_name: The linked service name.
        :type linked_service_name: str
        :param hive_type: Type of linked service.
        :type hive_type: str
        :param hive_host: IP address or host name of the Hive server, separated by ';' for multiple
         hosts (only when serviceDiscoveryMode is enable).
        :type hive_host: object
        :param hive_authentication_type: The authentication method used to access the Hive server.
        :type hive_authentication_type: str or ~azure.mgmt.datafactory.models.HiveAuthenticationType
        :param if_match: ETag of the linkedService entity.  Should only be specified for update, for
         which it should match existing entity or can be * for unconditional update.
        :type if_match: str
        :param hive_connect_via: The integration runtime reference.
        :type hive_connect_via: ~azure.mgmt.datafactory.models.IntegrationRuntimeReference
        :param hive_description: Linked service description.
        :type hive_description: str
        :param hive_parameters: Parameters for linked service.
        :type hive_parameters: dict[str, ~azure.mgmt.datafactory.models.ParameterSpecification]
        :param hive_annotations: List of tags that can be used for describing the linked service.
        :type hive_annotations: list[object]
        :param hive_port: The TCP port that the Hive server uses to listen for client connections.
        :type hive_port: object
        :param hive_server_type: The type of Hive server.
        :type hive_server_type: str or ~azure.mgmt.datafactory.models.HiveServerType
        :param hive_thrift_transport_protocol: The transport protocol to use in the Thrift layer.
        :type hive_thrift_transport_protocol: str or ~azure.mgmt.datafactory.models.HiveThriftTransportProtocol
        :param hive_service_discovery_mode: true to indicate using the ZooKeeper service, false not.
        :type hive_service_discovery_mode: object
        :param hive_zoo_keeper_name_space: The namespace on ZooKeeper under which Hive Server 2 nodes
         are added.
        :type hive_zoo_keeper_name_space: object
        :param hive_use_native_query: Specifies whether the driver uses native HiveQL queries,or
         converts them into an equivalent form in HiveQL.
        :type hive_use_native_query: object
        :param hive_username: The user name that you use to access Hive Server.
        :type hive_username: object
        :param hive_password: The password corresponding to the user name that you provided in the
         Username field.
        :type hive_password: ~azure.mgmt.datafactory.models.SecretBase
        :param hive_http_path: The partial URL corresponding to the Hive server.
        :type hive_http_path: object
        :param hive_enable_ssl: Specifies whether the connections to the server are encrypted using
         SSL. The default value is false.
        :type hive_enable_ssl: object
        :param hive_trusted_cert_path: The full path of the .pem file containing trusted CA
         certificates for verifying the server when connecting over SSL. This property can only be set
         when using SSL on self-hosted IR. The default value is the cacerts.pem file installed with the
         IR.
        :type hive_trusted_cert_path: object
        :param hive_use_system_trust_store: Specifies whether to use a CA certificate from the system
         trust store or from a specified PEM file. The default value is false.
        :type hive_use_system_trust_store: object
        :param hive_allow_host_name_cn_mismatch: Specifies whether to require a CA-issued SSL
         certificate name to match the host name of the server when connecting over SSL. The default
         value is false.
        :type hive_allow_host_name_cn_mismatch: object
        :param hive_allow_self_signed_server_cert: Specifies whether to allow self-signed certificates
         from the server. The default value is false.
        :type hive_allow_self_signed_server_cert: object
        :param hive_encrypted_credential: The encrypted credential used for authentication. Credentials
         are encrypted using the integration runtime credential manager. Type: string (or Expression
         with resultType string).
        :type hive_encrypted_credential: object
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: LinkedServiceResource or the result of cls(response)
        :rtype: ~azure.mgmt.datafactory.models.LinkedServiceResource
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.LinkedServiceResource"]
        error_map = kwargs.pop('error_map', {404: ResourceNotFoundError, 409: ResourceExistsError})

        _linked_service = models.LinkedServiceResource(properties=properties, type=hive_type, connect_via=hive_connect_via, description=hive_description, parameters=hive_parameters, annotations=hive_annotations, host=hive_host, port=hive_port, server_type=hive_server_type, thrift_transport_protocol=hive_thrift_transport_protocol, authentication_type=hive_authentication_type, service_discovery_mode=hive_service_discovery_mode, zoo_keeper_name_space=hive_zoo_keeper_name_space, use_native_query=hive_use_native_query, username=hive_username, password=hive_password, http_path=hive_http_path, enable_ssl=hive_enable_ssl, trusted_cert_path=hive_trusted_cert_path, use_system_trust_store=hive_use_system_trust_store, allow_host_name_cn_mismatch=hive_allow_host_name_cn_mismatch, allow_self_signed_server_cert=hive_allow_self_signed_server_cert, encrypted_credential=hive_encrypted_credential)
        api_version = "2018-06-01"
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.create_or_update_hive.metadata['url']
        path_format_arguments = {
            'subscriptionId': self._serialize.url("self._config.subscription_id", self._config.subscription_id, 'str'),
            'resourceGroupName': self._serialize.url("resource_group_name", resource_group_name, 'str', max_length=90, min_length=1, pattern=r'^[-\w\._\(\)]+$'),
            'factoryName': self._serialize.url("factory_name", factory_name, 'str', max_length=63, min_length=3, pattern=r'^[A-Za-z0-9]+(?:-[A-Za-z0-9]+)*$'),
            'linkedServiceName': self._serialize.url("linked_service_name", linked_service_name, 'str', max_length=260, min_length=1, pattern=r'^[A-Za-z0-9_][^<>*#.%&:\\+?/]*$'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = 'application/json'

        # Construct and send request
        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_linked_service, 'LinkedServiceResource')
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = self._deserialize('LinkedServiceResource', pipeline_response)

        if cls:
          return cls(pipeline_response, deserialized, {})

        return deserialized
    create_or_update_hive.metadata = {'url': '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataFactory/factories/{factoryName}/linkedservices/{linkedServiceName}'}

    def create_or_update_httpserver(
        self,
        resource_group_name,  # type: str
        factory_name,  # type: str
        linked_service_name,  # type: str
        httpserver_type,  # type: str
        httpserver_url,  # type: object
        if_match=None,  # type: Optional[str]
        httpserver_connect_via=None,  # type: Optional["models.IntegrationRuntimeReference"]
        httpserver_description=None,  # type: Optional[str]
        httpserver_parameters=None,  # type: Optional[Dict[str, "ParameterSpecification"]]
        httpserver_annotations=None,  # type: Optional[List[object]]
        httpserver_authentication_type=None,  # type: Optional[Union[str, "models.HttpAuthenticationType"]]
        httpserver_user_name=None,  # type: Optional[object]
        httpserver_password=None,  # type: Optional["models.SecretBase"]
        httpserver_embedded_cert_data=None,  # type: Optional[object]
        httpserver_cert_thumbprint=None,  # type: Optional[object]
        httpserver_encrypted_credential=None,  # type: Optional[object]
        httpserver_enable_server_certificate_validation=None,  # type: Optional[object]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.LinkedServiceResource"
        """Creates or updates a linked service.

        :param resource_group_name: The resource group name.
        :type resource_group_name: str
        :param factory_name: The factory name.
        :type factory_name: str
        :param linked_service_name: The linked service name.
        :type linked_service_name: str
        :param httpserver_type: Type of linked service.
        :type httpserver_type: str
        :param httpserver_url: The base URL of the HTTP endpoint, e.g. http://www.microsoft.com. Type:
         string (or Expression with resultType string).
        :type httpserver_url: object
        :param if_match: ETag of the linkedService entity.  Should only be specified for update, for
         which it should match existing entity or can be * for unconditional update.
        :type if_match: str
        :param httpserver_connect_via: The integration runtime reference.
        :type httpserver_connect_via: ~azure.mgmt.datafactory.models.IntegrationRuntimeReference
        :param httpserver_description: Linked service description.
        :type httpserver_description: str
        :param httpserver_parameters: Parameters for linked service.
        :type httpserver_parameters: dict[str, ~azure.mgmt.datafactory.models.ParameterSpecification]
        :param httpserver_annotations: List of tags that can be used for describing the linked service.
        :type httpserver_annotations: list[object]
        :param httpserver_authentication_type: The authentication type to be used to connect to the
         HTTP server.
        :type httpserver_authentication_type: str or ~azure.mgmt.datafactory.models.HttpAuthenticationType
        :param httpserver_user_name: User name for Basic, Digest, or Windows authentication. Type:
         string (or Expression with resultType string).
        :type httpserver_user_name: object
        :param httpserver_password: Password for Basic, Digest, Windows, or ClientCertificate with
         EmbeddedCertData authentication.
        :type httpserver_password: ~azure.mgmt.datafactory.models.SecretBase
        :param httpserver_embedded_cert_data: Base64 encoded certificate data for ClientCertificate
         authentication. For on-premises copy with ClientCertificate authentication, either
         CertThumbprint or EmbeddedCertData/Password should be specified. Type: string (or Expression
         with resultType string).
        :type httpserver_embedded_cert_data: object
        :param httpserver_cert_thumbprint: Thumbprint of certificate for ClientCertificate
         authentication. Only valid for on-premises copy. For on-premises copy with ClientCertificate
         authentication, either CertThumbprint or EmbeddedCertData/Password should be specified. Type:
         string (or Expression with resultType string).
        :type httpserver_cert_thumbprint: object
        :param httpserver_encrypted_credential: The encrypted credential used for authentication.
         Credentials are encrypted using the integration runtime credential manager. Type: string (or
         Expression with resultType string).
        :type httpserver_encrypted_credential: object
        :param httpserver_enable_server_certificate_validation: If true, validate the HTTPS server SSL
         certificate. Default value is true. Type: boolean (or Expression with resultType boolean).
        :type httpserver_enable_server_certificate_validation: object
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: LinkedServiceResource or the result of cls(response)
        :rtype: ~azure.mgmt.datafactory.models.LinkedServiceResource
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.LinkedServiceResource"]
        error_map = kwargs.pop('error_map', {404: ResourceNotFoundError, 409: ResourceExistsError})

        _linked_service = models.LinkedServiceResource(properties=properties, type=httpserver_type, connect_via=httpserver_connect_via, description=httpserver_description, parameters=httpserver_parameters, annotations=httpserver_annotations, url=httpserver_url, authentication_type=httpserver_authentication_type, user_name=httpserver_user_name, password=httpserver_password, embedded_cert_data=httpserver_embedded_cert_data, cert_thumbprint=httpserver_cert_thumbprint, encrypted_credential=httpserver_encrypted_credential, enable_server_certificate_validation=httpserver_enable_server_certificate_validation)
        api_version = "2018-06-01"
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.create_or_update_httpserver.metadata['url']
        path_format_arguments = {
            'subscriptionId': self._serialize.url("self._config.subscription_id", self._config.subscription_id, 'str'),
            'resourceGroupName': self._serialize.url("resource_group_name", resource_group_name, 'str', max_length=90, min_length=1, pattern=r'^[-\w\._\(\)]+$'),
            'factoryName': self._serialize.url("factory_name", factory_name, 'str', max_length=63, min_length=3, pattern=r'^[A-Za-z0-9]+(?:-[A-Za-z0-9]+)*$'),
            'linkedServiceName': self._serialize.url("linked_service_name", linked_service_name, 'str', max_length=260, min_length=1, pattern=r'^[A-Za-z0-9_][^<>*#.%&:\\+?/]*$'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = 'application/json'

        # Construct and send request
        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_linked_service, 'LinkedServiceResource')
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = self._deserialize('LinkedServiceResource', pipeline_response)

        if cls:
          return cls(pipeline_response, deserialized, {})

        return deserialized
    create_or_update_httpserver.metadata = {'url': '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataFactory/factories/{factoryName}/linkedservices/{linkedServiceName}'}

    def create_or_update_hubspot(
        self,
        resource_group_name,  # type: str
        factory_name,  # type: str
        linked_service_name,  # type: str
        hubspot_type,  # type: str
        hubspot_client_id,  # type: object
        if_match=None,  # type: Optional[str]
        hubspot_connect_via=None,  # type: Optional["models.IntegrationRuntimeReference"]
        hubspot_description=None,  # type: Optional[str]
        hubspot_parameters=None,  # type: Optional[Dict[str, "ParameterSpecification"]]
        hubspot_annotations=None,  # type: Optional[List[object]]
        hubspot_client_secret=None,  # type: Optional["models.SecretBase"]
        hubspot_access_token=None,  # type: Optional["models.SecretBase"]
        hubspot_refresh_token=None,  # type: Optional["models.SecretBase"]
        hubspot_use_encrypted_endpoints=None,  # type: Optional[object]
        hubspot_use_host_verification=None,  # type: Optional[object]
        hubspot_use_peer_verification=None,  # type: Optional[object]
        hubspot_encrypted_credential=None,  # type: Optional[object]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.LinkedServiceResource"
        """Creates or updates a linked service.

        :param resource_group_name: The resource group name.
        :type resource_group_name: str
        :param factory_name: The factory name.
        :type factory_name: str
        :param linked_service_name: The linked service name.
        :type linked_service_name: str
        :param hubspot_type: Type of linked service.
        :type hubspot_type: str
        :param hubspot_client_id: The client ID associated with your Hubspot application.
        :type hubspot_client_id: object
        :param if_match: ETag of the linkedService entity.  Should only be specified for update, for
         which it should match existing entity or can be * for unconditional update.
        :type if_match: str
        :param hubspot_connect_via: The integration runtime reference.
        :type hubspot_connect_via: ~azure.mgmt.datafactory.models.IntegrationRuntimeReference
        :param hubspot_description: Linked service description.
        :type hubspot_description: str
        :param hubspot_parameters: Parameters for linked service.
        :type hubspot_parameters: dict[str, ~azure.mgmt.datafactory.models.ParameterSpecification]
        :param hubspot_annotations: List of tags that can be used for describing the linked service.
        :type hubspot_annotations: list[object]
        :param hubspot_client_secret: The client secret associated with your Hubspot application.
        :type hubspot_client_secret: ~azure.mgmt.datafactory.models.SecretBase
        :param hubspot_access_token: The access token obtained when initially authenticating your OAuth
         integration.
        :type hubspot_access_token: ~azure.mgmt.datafactory.models.SecretBase
        :param hubspot_refresh_token: The refresh token obtained when
         initially authenticating your OAuth integration.
        :type hubspot_refresh_token: ~azure.mgmt.datafactory.models.SecretBase
        :param hubspot_use_encrypted_endpoints: Specifies whether the data source endpoints are
         encrypted using HTTPS. The default value is true.
        :type hubspot_use_encrypted_endpoints: object
        :param hubspot_use_host_verification: Specifies whether to require the host name in the
         server's certificate to match the host name of the server when connecting over SSL. The default
         value is true.
        :type hubspot_use_host_verification: object
        :param hubspot_use_peer_verification: Specifies whether to verify the identity of the server
         when connecting over SSL. The default value is true.
        :type hubspot_use_peer_verification: object
        :param hubspot_encrypted_credential: The encrypted credential used for authentication.
         Credentials are encrypted using the integration runtime credential manager. Type: string (or
         Expression with resultType string).
        :type hubspot_encrypted_credential: object
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: LinkedServiceResource or the result of cls(response)
        :rtype: ~azure.mgmt.datafactory.models.LinkedServiceResource
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.LinkedServiceResource"]
        error_map = kwargs.pop('error_map', {404: ResourceNotFoundError, 409: ResourceExistsError})

        _linked_service = models.LinkedServiceResource(properties=properties, type=hubspot_type, connect_via=hubspot_connect_via, description=hubspot_description, parameters=hubspot_parameters, annotations=hubspot_annotations, client_id=hubspot_client_id, client_secret=hubspot_client_secret, access_token=hubspot_access_token, refresh_token=hubspot_refresh_token, use_encrypted_endpoints=hubspot_use_encrypted_endpoints, use_host_verification=hubspot_use_host_verification, use_peer_verification=hubspot_use_peer_verification, encrypted_credential=hubspot_encrypted_credential)
        api_version = "2018-06-01"
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.create_or_update_hubspot.metadata['url']
        path_format_arguments = {
            'subscriptionId': self._serialize.url("self._config.subscription_id", self._config.subscription_id, 'str'),
            'resourceGroupName': self._serialize.url("resource_group_name", resource_group_name, 'str', max_length=90, min_length=1, pattern=r'^[-\w\._\(\)]+$'),
            'factoryName': self._serialize.url("factory_name", factory_name, 'str', max_length=63, min_length=3, pattern=r'^[A-Za-z0-9]+(?:-[A-Za-z0-9]+)*$'),
            'linkedServiceName': self._serialize.url("linked_service_name", linked_service_name, 'str', max_length=260, min_length=1, pattern=r'^[A-Za-z0-9_][^<>*#.%&:\\+?/]*$'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = 'application/json'

        # Construct and send request
        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_linked_service, 'LinkedServiceResource')
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = self._deserialize('LinkedServiceResource', pipeline_response)

        if cls:
          return cls(pipeline_response, deserialized, {})

        return deserialized
    create_or_update_hubspot.metadata = {'url': '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataFactory/factories/{factoryName}/linkedservices/{linkedServiceName}'}

    def create_or_update_impala(
        self,
        resource_group_name,  # type: str
        factory_name,  # type: str
        linked_service_name,  # type: str
        impala_type,  # type: str
        impala_host,  # type: object
        impala_authentication_type,  # type: Union[str, "models.ImpalaAuthenticationType"]
        if_match=None,  # type: Optional[str]
        impala_connect_via=None,  # type: Optional["models.IntegrationRuntimeReference"]
        impala_description=None,  # type: Optional[str]
        impala_parameters=None,  # type: Optional[Dict[str, "ParameterSpecification"]]
        impala_annotations=None,  # type: Optional[List[object]]
        impala_port=None,  # type: Optional[object]
        impala_username=None,  # type: Optional[object]
        impala_password=None,  # type: Optional["models.SecretBase"]
        impala_enable_ssl=None,  # type: Optional[object]
        impala_trusted_cert_path=None,  # type: Optional[object]
        impala_use_system_trust_store=None,  # type: Optional[object]
        impala_allow_host_name_cn_mismatch=None,  # type: Optional[object]
        impala_allow_self_signed_server_cert=None,  # type: Optional[object]
        impala_encrypted_credential=None,  # type: Optional[object]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.LinkedServiceResource"
        """Creates or updates a linked service.

        :param resource_group_name: The resource group name.
        :type resource_group_name: str
        :param factory_name: The factory name.
        :type factory_name: str
        :param linked_service_name: The linked service name.
        :type linked_service_name: str
        :param impala_type: Type of linked service.
        :type impala_type: str
        :param impala_host: The IP address or host name of the Impala server. (i.e. 192.168.222.160).
        :type impala_host: object
        :param impala_authentication_type: The authentication type to use.
        :type impala_authentication_type: str or ~azure.mgmt.datafactory.models.ImpalaAuthenticationType
        :param if_match: ETag of the linkedService entity.  Should only be specified for update, for
         which it should match existing entity or can be * for unconditional update.
        :type if_match: str
        :param impala_connect_via: The integration runtime reference.
        :type impala_connect_via: ~azure.mgmt.datafactory.models.IntegrationRuntimeReference
        :param impala_description: Linked service description.
        :type impala_description: str
        :param impala_parameters: Parameters for linked service.
        :type impala_parameters: dict[str, ~azure.mgmt.datafactory.models.ParameterSpecification]
        :param impala_annotations: List of tags that can be used for describing the linked service.
        :type impala_annotations: list[object]
        :param impala_port: The TCP port that the Impala server uses to listen for client connections.
         The default value is 21050.
        :type impala_port: object
        :param impala_username: The user name used to access the Impala server. The default value is
         anonymous when using SASLUsername.
        :type impala_username: object
        :param impala_password: The password corresponding to the user name when using
         UsernameAndPassword.
        :type impala_password: ~azure.mgmt.datafactory.models.SecretBase
        :param impala_enable_ssl: Specifies whether the connections to the server are encrypted using
         SSL. The default value is false.
        :type impala_enable_ssl: object
        :param impala_trusted_cert_path: The full path of the .pem file containing trusted CA
         certificates for verifying the server when connecting over SSL. This property can only be set
         when using SSL on self-hosted IR. The default value is the cacerts.pem file installed with the
         IR.
        :type impala_trusted_cert_path: object
        :param impala_use_system_trust_store: Specifies whether to use a CA certificate from the system
         trust store or from a specified PEM file. The default value is false.
        :type impala_use_system_trust_store: object
        :param impala_allow_host_name_cn_mismatch: Specifies whether to require a CA-issued SSL
         certificate name to match the host name of the server when connecting over SSL. The default
         value is false.
        :type impala_allow_host_name_cn_mismatch: object
        :param impala_allow_self_signed_server_cert: Specifies whether to allow self-signed
         certificates from the server. The default value is false.
        :type impala_allow_self_signed_server_cert: object
        :param impala_encrypted_credential: The encrypted credential used for authentication.
         Credentials are encrypted using the integration runtime credential manager. Type: string (or
         Expression with resultType string).
        :type impala_encrypted_credential: object
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: LinkedServiceResource or the result of cls(response)
        :rtype: ~azure.mgmt.datafactory.models.LinkedServiceResource
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.LinkedServiceResource"]
        error_map = kwargs.pop('error_map', {404: ResourceNotFoundError, 409: ResourceExistsError})

        _linked_service = models.LinkedServiceResource(properties=properties, type=impala_type, connect_via=impala_connect_via, description=impala_description, parameters=impala_parameters, annotations=impala_annotations, host=impala_host, port=impala_port, authentication_type=impala_authentication_type, username=impala_username, password=impala_password, enable_ssl=impala_enable_ssl, trusted_cert_path=impala_trusted_cert_path, use_system_trust_store=impala_use_system_trust_store, allow_host_name_cn_mismatch=impala_allow_host_name_cn_mismatch, allow_self_signed_server_cert=impala_allow_self_signed_server_cert, encrypted_credential=impala_encrypted_credential)
        api_version = "2018-06-01"
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.create_or_update_impala.metadata['url']
        path_format_arguments = {
            'subscriptionId': self._serialize.url("self._config.subscription_id", self._config.subscription_id, 'str'),
            'resourceGroupName': self._serialize.url("resource_group_name", resource_group_name, 'str', max_length=90, min_length=1, pattern=r'^[-\w\._\(\)]+$'),
            'factoryName': self._serialize.url("factory_name", factory_name, 'str', max_length=63, min_length=3, pattern=r'^[A-Za-z0-9]+(?:-[A-Za-z0-9]+)*$'),
            'linkedServiceName': self._serialize.url("linked_service_name", linked_service_name, 'str', max_length=260, min_length=1, pattern=r'^[A-Za-z0-9_][^<>*#.%&:\\+?/]*$'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = 'application/json'

        # Construct and send request
        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_linked_service, 'LinkedServiceResource')
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = self._deserialize('LinkedServiceResource', pipeline_response)

        if cls:
          return cls(pipeline_response, deserialized, {})

        return deserialized
    create_or_update_impala.metadata = {'url': '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataFactory/factories/{factoryName}/linkedservices/{linkedServiceName}'}

    def create_or_update_informix(
        self,
        resource_group_name,  # type: str
        factory_name,  # type: str
        linked_service_name,  # type: str
        informix_type,  # type: str
        informix_connection_string,  # type: object
        if_match=None,  # type: Optional[str]
        informix_connect_via=None,  # type: Optional["models.IntegrationRuntimeReference"]
        informix_description=None,  # type: Optional[str]
        informix_parameters=None,  # type: Optional[Dict[str, "ParameterSpecification"]]
        informix_annotations=None,  # type: Optional[List[object]]
        informix_authentication_type=None,  # type: Optional[object]
        informix_credential=None,  # type: Optional["models.SecretBase"]
        informix_user_name=None,  # type: Optional[object]
        informix_password=None,  # type: Optional["models.SecretBase"]
        informix_encrypted_credential=None,  # type: Optional[object]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.LinkedServiceResource"
        """Creates or updates a linked service.

        :param resource_group_name: The resource group name.
        :type resource_group_name: str
        :param factory_name: The factory name.
        :type factory_name: str
        :param linked_service_name: The linked service name.
        :type linked_service_name: str
        :param informix_type: Type of linked service.
        :type informix_type: str
        :param informix_connection_string: The non-access credential portion of the connection string
         as well as an optional encrypted credential. Type: string, SecureString or
         AzureKeyVaultSecretReference.
        :type informix_connection_string: object
        :param if_match: ETag of the linkedService entity.  Should only be specified for update, for
         which it should match existing entity or can be * for unconditional update.
        :type if_match: str
        :param informix_connect_via: The integration runtime reference.
        :type informix_connect_via: ~azure.mgmt.datafactory.models.IntegrationRuntimeReference
        :param informix_description: Linked service description.
        :type informix_description: str
        :param informix_parameters: Parameters for linked service.
        :type informix_parameters: dict[str, ~azure.mgmt.datafactory.models.ParameterSpecification]
        :param informix_annotations: List of tags that can be used for describing the linked service.
        :type informix_annotations: list[object]
        :param informix_authentication_type: Type of authentication used to connect to the Informix as
         ODBC data store. Possible values are: Anonymous and Basic. Type: string (or Expression with
         resultType string).
        :type informix_authentication_type: object
        :param informix_credential: The access credential portion of the connection string specified in
         driver-specific property-value format.
        :type informix_credential: ~azure.mgmt.datafactory.models.SecretBase
        :param informix_user_name: User name for Basic authentication. Type: string (or Expression with
         resultType string).
        :type informix_user_name: object
        :param informix_password: Password for Basic authentication.
        :type informix_password: ~azure.mgmt.datafactory.models.SecretBase
        :param informix_encrypted_credential: The encrypted credential used for authentication.
         Credentials are encrypted using the integration runtime credential manager. Type: string (or
         Expression with resultType string).
        :type informix_encrypted_credential: object
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: LinkedServiceResource or the result of cls(response)
        :rtype: ~azure.mgmt.datafactory.models.LinkedServiceResource
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.LinkedServiceResource"]
        error_map = kwargs.pop('error_map', {404: ResourceNotFoundError, 409: ResourceExistsError})

        _linked_service = models.LinkedServiceResource(properties=properties, type=informix_type, connect_via=informix_connect_via, description=informix_description, parameters=informix_parameters, annotations=informix_annotations, connection_string=informix_connection_string, authentication_type=informix_authentication_type, credential=informix_credential, user_name=informix_user_name, password=informix_password, encrypted_credential=informix_encrypted_credential)
        api_version = "2018-06-01"
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.create_or_update_informix.metadata['url']
        path_format_arguments = {
            'subscriptionId': self._serialize.url("self._config.subscription_id", self._config.subscription_id, 'str'),
            'resourceGroupName': self._serialize.url("resource_group_name", resource_group_name, 'str', max_length=90, min_length=1, pattern=r'^[-\w\._\(\)]+$'),
            'factoryName': self._serialize.url("factory_name", factory_name, 'str', max_length=63, min_length=3, pattern=r'^[A-Za-z0-9]+(?:-[A-Za-z0-9]+)*$'),
            'linkedServiceName': self._serialize.url("linked_service_name", linked_service_name, 'str', max_length=260, min_length=1, pattern=r'^[A-Za-z0-9_][^<>*#.%&:\\+?/]*$'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = 'application/json'

        # Construct and send request
        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_linked_service, 'LinkedServiceResource')
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = self._deserialize('LinkedServiceResource', pipeline_response)

        if cls:
          return cls(pipeline_response, deserialized, {})

        return deserialized
    create_or_update_informix.metadata = {'url': '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataFactory/factories/{factoryName}/linkedservices/{linkedServiceName}'}

    def create_or_update_jira(
        self,
        resource_group_name,  # type: str
        factory_name,  # type: str
        linked_service_name,  # type: str
        jira_type,  # type: str
        jira_host,  # type: object
        jira_username,  # type: object
        if_match=None,  # type: Optional[str]
        jira_connect_via=None,  # type: Optional["models.IntegrationRuntimeReference"]
        jira_description=None,  # type: Optional[str]
        jira_parameters=None,  # type: Optional[Dict[str, "ParameterSpecification"]]
        jira_annotations=None,  # type: Optional[List[object]]
        jira_port=None,  # type: Optional[object]
        jira_password=None,  # type: Optional["models.SecretBase"]
        jira_use_encrypted_endpoints=None,  # type: Optional[object]
        jira_use_host_verification=None,  # type: Optional[object]
        jira_use_peer_verification=None,  # type: Optional[object]
        jira_encrypted_credential=None,  # type: Optional[object]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.LinkedServiceResource"
        """Creates or updates a linked service.

        :param resource_group_name: The resource group name.
        :type resource_group_name: str
        :param factory_name: The factory name.
        :type factory_name: str
        :param linked_service_name: The linked service name.
        :type linked_service_name: str
        :param jira_type: Type of linked service.
        :type jira_type: str
        :param jira_host: The IP address or host name of the Jira service. (e.g. jira.example.com).
        :type jira_host: object
        :param jira_username: The user name that you use to access Jira Service.
        :type jira_username: object
        :param if_match: ETag of the linkedService entity.  Should only be specified for update, for
         which it should match existing entity or can be * for unconditional update.
        :type if_match: str
        :param jira_connect_via: The integration runtime reference.
        :type jira_connect_via: ~azure.mgmt.datafactory.models.IntegrationRuntimeReference
        :param jira_description: Linked service description.
        :type jira_description: str
        :param jira_parameters: Parameters for linked service.
        :type jira_parameters: dict[str, ~azure.mgmt.datafactory.models.ParameterSpecification]
        :param jira_annotations: List of tags that can be used for describing the linked service.
        :type jira_annotations: list[object]
        :param jira_port: The TCP port that the Jira server uses to listen for client connections. The
         default value is 443 if connecting through HTTPS, or 8080 if connecting through HTTP.
        :type jira_port: object
        :param jira_password: The password corresponding to the user name that you provided in the
         username field.
        :type jira_password: ~azure.mgmt.datafactory.models.SecretBase
        :param jira_use_encrypted_endpoints: Specifies whether the data source endpoints are encrypted
         using HTTPS. The default value is true.
        :type jira_use_encrypted_endpoints: object
        :param jira_use_host_verification: Specifies whether to require the host name in the server's
         certificate to match the host name of the server when connecting over SSL. The default value is
         true.
        :type jira_use_host_verification: object
        :param jira_use_peer_verification: Specifies whether to verify the identity of the server when
         connecting over SSL. The default value is true.
        :type jira_use_peer_verification: object
        :param jira_encrypted_credential: The encrypted credential used for authentication. Credentials
         are encrypted using the integration runtime credential manager. Type: string (or Expression
         with resultType string).
        :type jira_encrypted_credential: object
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: LinkedServiceResource or the result of cls(response)
        :rtype: ~azure.mgmt.datafactory.models.LinkedServiceResource
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.LinkedServiceResource"]
        error_map = kwargs.pop('error_map', {404: ResourceNotFoundError, 409: ResourceExistsError})

        _linked_service = models.LinkedServiceResource(properties=properties, type=jira_type, connect_via=jira_connect_via, description=jira_description, parameters=jira_parameters, annotations=jira_annotations, host=jira_host, port=jira_port, username=jira_username, password=jira_password, use_encrypted_endpoints=jira_use_encrypted_endpoints, use_host_verification=jira_use_host_verification, use_peer_verification=jira_use_peer_verification, encrypted_credential=jira_encrypted_credential)
        api_version = "2018-06-01"
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.create_or_update_jira.metadata['url']
        path_format_arguments = {
            'subscriptionId': self._serialize.url("self._config.subscription_id", self._config.subscription_id, 'str'),
            'resourceGroupName': self._serialize.url("resource_group_name", resource_group_name, 'str', max_length=90, min_length=1, pattern=r'^[-\w\._\(\)]+$'),
            'factoryName': self._serialize.url("factory_name", factory_name, 'str', max_length=63, min_length=3, pattern=r'^[A-Za-z0-9]+(?:-[A-Za-z0-9]+)*$'),
            'linkedServiceName': self._serialize.url("linked_service_name", linked_service_name, 'str', max_length=260, min_length=1, pattern=r'^[A-Za-z0-9_][^<>*#.%&:\\+?/]*$'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = 'application/json'

        # Construct and send request
        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_linked_service, 'LinkedServiceResource')
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = self._deserialize('LinkedServiceResource', pipeline_response)

        if cls:
          return cls(pipeline_response, deserialized, {})

        return deserialized
    create_or_update_jira.metadata = {'url': '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataFactory/factories/{factoryName}/linkedservices/{linkedServiceName}'}

    def create_or_update_magento(
        self,
        resource_group_name,  # type: str
        factory_name,  # type: str
        linked_service_name,  # type: str
        magento_type,  # type: str
        magento_host,  # type: object
        if_match=None,  # type: Optional[str]
        magento_connect_via=None,  # type: Optional["models.IntegrationRuntimeReference"]
        magento_description=None,  # type: Optional[str]
        magento_parameters=None,  # type: Optional[Dict[str, "ParameterSpecification"]]
        magento_annotations=None,  # type: Optional[List[object]]
        magento_access_token=None,  # type: Optional["models.SecretBase"]
        magento_use_encrypted_endpoints=None,  # type: Optional[object]
        magento_use_host_verification=None,  # type: Optional[object]
        magento_use_peer_verification=None,  # type: Optional[object]
        magento_encrypted_credential=None,  # type: Optional[object]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.LinkedServiceResource"
        """Creates or updates a linked service.

        :param resource_group_name: The resource group name.
        :type resource_group_name: str
        :param factory_name: The factory name.
        :type factory_name: str
        :param linked_service_name: The linked service name.
        :type linked_service_name: str
        :param magento_type: Type of linked service.
        :type magento_type: str
        :param magento_host: The URL of the Magento instance. (i.e. 192.168.222.110/magento3).
        :type magento_host: object
        :param if_match: ETag of the linkedService entity.  Should only be specified for update, for
         which it should match existing entity or can be * for unconditional update.
        :type if_match: str
        :param magento_connect_via: The integration runtime reference.
        :type magento_connect_via: ~azure.mgmt.datafactory.models.IntegrationRuntimeReference
        :param magento_description: Linked service description.
        :type magento_description: str
        :param magento_parameters: Parameters for linked service.
        :type magento_parameters: dict[str, ~azure.mgmt.datafactory.models.ParameterSpecification]
        :param magento_annotations: List of tags that can be used for describing the linked service.
        :type magento_annotations: list[object]
        :param magento_access_token: The access token from Magento.
        :type magento_access_token: ~azure.mgmt.datafactory.models.SecretBase
        :param magento_use_encrypted_endpoints: Specifies whether the data source endpoints are
         encrypted using HTTPS. The default value is true.
        :type magento_use_encrypted_endpoints: object
        :param magento_use_host_verification: Specifies whether to require the host name in the
         server's certificate to match the host name of the server when connecting over SSL. The default
         value is true.
        :type magento_use_host_verification: object
        :param magento_use_peer_verification: Specifies whether to verify the identity of the server
         when connecting over SSL. The default value is true.
        :type magento_use_peer_verification: object
        :param magento_encrypted_credential: The encrypted credential used for authentication.
         Credentials are encrypted using the integration runtime credential manager. Type: string (or
         Expression with resultType string).
        :type magento_encrypted_credential: object
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: LinkedServiceResource or the result of cls(response)
        :rtype: ~azure.mgmt.datafactory.models.LinkedServiceResource
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.LinkedServiceResource"]
        error_map = kwargs.pop('error_map', {404: ResourceNotFoundError, 409: ResourceExistsError})

        _linked_service = models.LinkedServiceResource(properties=properties, type=magento_type, connect_via=magento_connect_via, description=magento_description, parameters=magento_parameters, annotations=magento_annotations, host=magento_host, access_token=magento_access_token, use_encrypted_endpoints=magento_use_encrypted_endpoints, use_host_verification=magento_use_host_verification, use_peer_verification=magento_use_peer_verification, encrypted_credential=magento_encrypted_credential)
        api_version = "2018-06-01"
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.create_or_update_magento.metadata['url']
        path_format_arguments = {
            'subscriptionId': self._serialize.url("self._config.subscription_id", self._config.subscription_id, 'str'),
            'resourceGroupName': self._serialize.url("resource_group_name", resource_group_name, 'str', max_length=90, min_length=1, pattern=r'^[-\w\._\(\)]+$'),
            'factoryName': self._serialize.url("factory_name", factory_name, 'str', max_length=63, min_length=3, pattern=r'^[A-Za-z0-9]+(?:-[A-Za-z0-9]+)*$'),
            'linkedServiceName': self._serialize.url("linked_service_name", linked_service_name, 'str', max_length=260, min_length=1, pattern=r'^[A-Za-z0-9_][^<>*#.%&:\\+?/]*$'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = 'application/json'

        # Construct and send request
        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_linked_service, 'LinkedServiceResource')
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = self._deserialize('LinkedServiceResource', pipeline_response)

        if cls:
          return cls(pipeline_response, deserialized, {})

        return deserialized
    create_or_update_magento.metadata = {'url': '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataFactory/factories/{factoryName}/linkedservices/{linkedServiceName}'}

    def create_or_update_mariadb(
        self,
        resource_group_name,  # type: str
        factory_name,  # type: str
        linked_service_name,  # type: str
        mariadb_type,  # type: str
        if_match=None,  # type: Optional[str]
        mariadb_connect_via=None,  # type: Optional["models.IntegrationRuntimeReference"]
        mariadb_description=None,  # type: Optional[str]
        mariadb_parameters=None,  # type: Optional[Dict[str, "ParameterSpecification"]]
        mariadb_annotations=None,  # type: Optional[List[object]]
        mariadb_connection_string=None,  # type: Optional[object]
        mariadb_pwd=None,  # type: Optional["models.AzureKeyVaultSecretReference"]
        mariadb_encrypted_credential=None,  # type: Optional[object]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.LinkedServiceResource"
        """Creates or updates a linked service.

        :param resource_group_name: The resource group name.
        :type resource_group_name: str
        :param factory_name: The factory name.
        :type factory_name: str
        :param linked_service_name: The linked service name.
        :type linked_service_name: str
        :param mariadb_type: Type of linked service.
        :type mariadb_type: str
        :param if_match: ETag of the linkedService entity.  Should only be specified for update, for
         which it should match existing entity or can be * for unconditional update.
        :type if_match: str
        :param mariadb_connect_via: The integration runtime reference.
        :type mariadb_connect_via: ~azure.mgmt.datafactory.models.IntegrationRuntimeReference
        :param mariadb_description: Linked service description.
        :type mariadb_description: str
        :param mariadb_parameters: Parameters for linked service.
        :type mariadb_parameters: dict[str, ~azure.mgmt.datafactory.models.ParameterSpecification]
        :param mariadb_annotations: List of tags that can be used for describing the linked service.
        :type mariadb_annotations: list[object]
        :param mariadb_connection_string: An ODBC connection string. Type: string, SecureString or
         AzureKeyVaultSecretReference.
        :type mariadb_connection_string: object
        :param mariadb_pwd: The Azure key vault secret reference of password in connection string.
        :type mariadb_pwd: ~azure.mgmt.datafactory.models.AzureKeyVaultSecretReference
        :param mariadb_encrypted_credential: The encrypted credential used for authentication.
         Credentials are encrypted using the integration runtime credential manager. Type: string (or
         Expression with resultType string).
        :type mariadb_encrypted_credential: object
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: LinkedServiceResource or the result of cls(response)
        :rtype: ~azure.mgmt.datafactory.models.LinkedServiceResource
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.LinkedServiceResource"]
        error_map = kwargs.pop('error_map', {404: ResourceNotFoundError, 409: ResourceExistsError})

        _linked_service = models.LinkedServiceResource(properties=properties, type=mariadb_type, connect_via=mariadb_connect_via, description=mariadb_description, parameters=mariadb_parameters, annotations=mariadb_annotations, connection_string=mariadb_connection_string, pwd=mariadb_pwd, encrypted_credential=mariadb_encrypted_credential)
        api_version = "2018-06-01"
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.create_or_update_mariadb.metadata['url']
        path_format_arguments = {
            'subscriptionId': self._serialize.url("self._config.subscription_id", self._config.subscription_id, 'str'),
            'resourceGroupName': self._serialize.url("resource_group_name", resource_group_name, 'str', max_length=90, min_length=1, pattern=r'^[-\w\._\(\)]+$'),
            'factoryName': self._serialize.url("factory_name", factory_name, 'str', max_length=63, min_length=3, pattern=r'^[A-Za-z0-9]+(?:-[A-Za-z0-9]+)*$'),
            'linkedServiceName': self._serialize.url("linked_service_name", linked_service_name, 'str', max_length=260, min_length=1, pattern=r'^[A-Za-z0-9_][^<>*#.%&:\\+?/]*$'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = 'application/json'

        # Construct and send request
        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_linked_service, 'LinkedServiceResource')
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = self._deserialize('LinkedServiceResource', pipeline_response)

        if cls:
          return cls(pipeline_response, deserialized, {})

        return deserialized
    create_or_update_mariadb.metadata = {'url': '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataFactory/factories/{factoryName}/linkedservices/{linkedServiceName}'}

    def create_or_update_marketo(
        self,
        resource_group_name,  # type: str
        factory_name,  # type: str
        linked_service_name,  # type: str
        marketo_type,  # type: str
        marketo_endpoint,  # type: object
        marketo_client_id,  # type: object
        if_match=None,  # type: Optional[str]
        marketo_connect_via=None,  # type: Optional["models.IntegrationRuntimeReference"]
        marketo_description=None,  # type: Optional[str]
        marketo_parameters=None,  # type: Optional[Dict[str, "ParameterSpecification"]]
        marketo_annotations=None,  # type: Optional[List[object]]
        marketo_client_secret=None,  # type: Optional["models.SecretBase"]
        marketo_use_encrypted_endpoints=None,  # type: Optional[object]
        marketo_use_host_verification=None,  # type: Optional[object]
        marketo_use_peer_verification=None,  # type: Optional[object]
        marketo_encrypted_credential=None,  # type: Optional[object]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.LinkedServiceResource"
        """Creates or updates a linked service.

        :param resource_group_name: The resource group name.
        :type resource_group_name: str
        :param factory_name: The factory name.
        :type factory_name: str
        :param linked_service_name: The linked service name.
        :type linked_service_name: str
        :param marketo_type: Type of linked service.
        :type marketo_type: str
        :param marketo_endpoint: The endpoint of the Marketo server. (i.e. 123-ABC-321.mktorest.com).
        :type marketo_endpoint: object
        :param marketo_client_id: The client Id of your Marketo service.
        :type marketo_client_id: object
        :param if_match: ETag of the linkedService entity.  Should only be specified for update, for
         which it should match existing entity or can be * for unconditional update.
        :type if_match: str
        :param marketo_connect_via: The integration runtime reference.
        :type marketo_connect_via: ~azure.mgmt.datafactory.models.IntegrationRuntimeReference
        :param marketo_description: Linked service description.
        :type marketo_description: str
        :param marketo_parameters: Parameters for linked service.
        :type marketo_parameters: dict[str, ~azure.mgmt.datafactory.models.ParameterSpecification]
        :param marketo_annotations: List of tags that can be used for describing the linked service.
        :type marketo_annotations: list[object]
        :param marketo_client_secret: The client secret of your Marketo service.
        :type marketo_client_secret: ~azure.mgmt.datafactory.models.SecretBase
        :param marketo_use_encrypted_endpoints: Specifies whether the data source endpoints are
         encrypted using HTTPS. The default value is true.
        :type marketo_use_encrypted_endpoints: object
        :param marketo_use_host_verification: Specifies whether to require the host name in the
         server's certificate to match the host name of the server when connecting over SSL. The default
         value is true.
        :type marketo_use_host_verification: object
        :param marketo_use_peer_verification: Specifies whether to verify the identity of the server
         when connecting over SSL. The default value is true.
        :type marketo_use_peer_verification: object
        :param marketo_encrypted_credential: The encrypted credential used for authentication.
         Credentials are encrypted using the integration runtime credential manager. Type: string (or
         Expression with resultType string).
        :type marketo_encrypted_credential: object
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: LinkedServiceResource or the result of cls(response)
        :rtype: ~azure.mgmt.datafactory.models.LinkedServiceResource
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.LinkedServiceResource"]
        error_map = kwargs.pop('error_map', {404: ResourceNotFoundError, 409: ResourceExistsError})

        _linked_service = models.LinkedServiceResource(properties=properties, type=marketo_type, connect_via=marketo_connect_via, description=marketo_description, parameters=marketo_parameters, annotations=marketo_annotations, endpoint=marketo_endpoint, client_id=marketo_client_id, client_secret=marketo_client_secret, use_encrypted_endpoints=marketo_use_encrypted_endpoints, use_host_verification=marketo_use_host_verification, use_peer_verification=marketo_use_peer_verification, encrypted_credential=marketo_encrypted_credential)
        api_version = "2018-06-01"
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.create_or_update_marketo.metadata['url']
        path_format_arguments = {
            'subscriptionId': self._serialize.url("self._config.subscription_id", self._config.subscription_id, 'str'),
            'resourceGroupName': self._serialize.url("resource_group_name", resource_group_name, 'str', max_length=90, min_length=1, pattern=r'^[-\w\._\(\)]+$'),
            'factoryName': self._serialize.url("factory_name", factory_name, 'str', max_length=63, min_length=3, pattern=r'^[A-Za-z0-9]+(?:-[A-Za-z0-9]+)*$'),
            'linkedServiceName': self._serialize.url("linked_service_name", linked_service_name, 'str', max_length=260, min_length=1, pattern=r'^[A-Za-z0-9_][^<>*#.%&:\\+?/]*$'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = 'application/json'

        # Construct and send request
        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_linked_service, 'LinkedServiceResource')
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = self._deserialize('LinkedServiceResource', pipeline_response)

        if cls:
          return cls(pipeline_response, deserialized, {})

        return deserialized
    create_or_update_marketo.metadata = {'url': '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataFactory/factories/{factoryName}/linkedservices/{linkedServiceName}'}

    def create_or_update_microsoftaccess(
        self,
        resource_group_name,  # type: str
        factory_name,  # type: str
        linked_service_name,  # type: str
        microsoftaccess_type,  # type: str
        microsoftaccess_connection_string,  # type: object
        if_match=None,  # type: Optional[str]
        microsoftaccess_connect_via=None,  # type: Optional["models.IntegrationRuntimeReference"]
        microsoftaccess_description=None,  # type: Optional[str]
        microsoftaccess_parameters=None,  # type: Optional[Dict[str, "ParameterSpecification"]]
        microsoftaccess_annotations=None,  # type: Optional[List[object]]
        microsoftaccess_authentication_type=None,  # type: Optional[object]
        microsoftaccess_credential=None,  # type: Optional["models.SecretBase"]
        microsoftaccess_user_name=None,  # type: Optional[object]
        microsoftaccess_password=None,  # type: Optional["models.SecretBase"]
        microsoftaccess_encrypted_credential=None,  # type: Optional[object]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.LinkedServiceResource"
        """Creates or updates a linked service.

        :param resource_group_name: The resource group name.
        :type resource_group_name: str
        :param factory_name: The factory name.
        :type factory_name: str
        :param linked_service_name: The linked service name.
        :type linked_service_name: str
        :param microsoftaccess_type: Type of linked service.
        :type microsoftaccess_type: str
        :param microsoftaccess_connection_string: The non-access credential portion of the connection
         string as well as an optional encrypted credential. Type: string, SecureString or
         AzureKeyVaultSecretReference.
        :type microsoftaccess_connection_string: object
        :param if_match: ETag of the linkedService entity.  Should only be specified for update, for
         which it should match existing entity or can be * for unconditional update.
        :type if_match: str
        :param microsoftaccess_connect_via: The integration runtime reference.
        :type microsoftaccess_connect_via: ~azure.mgmt.datafactory.models.IntegrationRuntimeReference
        :param microsoftaccess_description: Linked service description.
        :type microsoftaccess_description: str
        :param microsoftaccess_parameters: Parameters for linked service.
        :type microsoftaccess_parameters: dict[str, ~azure.mgmt.datafactory.models.ParameterSpecification]
        :param microsoftaccess_annotations: List of tags that can be used for describing the linked
         service.
        :type microsoftaccess_annotations: list[object]
        :param microsoftaccess_authentication_type: Type of authentication used to connect to the
         Microsoft Access as ODBC data store. Possible values are: Anonymous and Basic. Type: string (or
         Expression with resultType string).
        :type microsoftaccess_authentication_type: object
        :param microsoftaccess_credential: The access credential portion of the connection string
         specified in driver-specific property-value format.
        :type microsoftaccess_credential: ~azure.mgmt.datafactory.models.SecretBase
        :param microsoftaccess_user_name: User name for Basic authentication. Type: string (or
         Expression with resultType string).
        :type microsoftaccess_user_name: object
        :param microsoftaccess_password: Password for Basic authentication.
        :type microsoftaccess_password: ~azure.mgmt.datafactory.models.SecretBase
        :param microsoftaccess_encrypted_credential: The encrypted credential used for authentication.
         Credentials are encrypted using the integration runtime credential manager. Type: string (or
         Expression with resultType string).
        :type microsoftaccess_encrypted_credential: object
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: LinkedServiceResource or the result of cls(response)
        :rtype: ~azure.mgmt.datafactory.models.LinkedServiceResource
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.LinkedServiceResource"]
        error_map = kwargs.pop('error_map', {404: ResourceNotFoundError, 409: ResourceExistsError})

        _linked_service = models.LinkedServiceResource(properties=properties, type=microsoftaccess_type, connect_via=microsoftaccess_connect_via, description=microsoftaccess_description, parameters=microsoftaccess_parameters, annotations=microsoftaccess_annotations, connection_string=microsoftaccess_connection_string, authentication_type=microsoftaccess_authentication_type, credential=microsoftaccess_credential, user_name=microsoftaccess_user_name, password=microsoftaccess_password, encrypted_credential=microsoftaccess_encrypted_credential)
        api_version = "2018-06-01"
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.create_or_update_microsoftaccess.metadata['url']
        path_format_arguments = {
            'subscriptionId': self._serialize.url("self._config.subscription_id", self._config.subscription_id, 'str'),
            'resourceGroupName': self._serialize.url("resource_group_name", resource_group_name, 'str', max_length=90, min_length=1, pattern=r'^[-\w\._\(\)]+$'),
            'factoryName': self._serialize.url("factory_name", factory_name, 'str', max_length=63, min_length=3, pattern=r'^[A-Za-z0-9]+(?:-[A-Za-z0-9]+)*$'),
            'linkedServiceName': self._serialize.url("linked_service_name", linked_service_name, 'str', max_length=260, min_length=1, pattern=r'^[A-Za-z0-9_][^<>*#.%&:\\+?/]*$'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = 'application/json'

        # Construct and send request
        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_linked_service, 'LinkedServiceResource')
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = self._deserialize('LinkedServiceResource', pipeline_response)

        if cls:
          return cls(pipeline_response, deserialized, {})

        return deserialized
    create_or_update_microsoftaccess.metadata = {'url': '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataFactory/factories/{factoryName}/linkedservices/{linkedServiceName}'}

    def create_or_update_mongodb(
        self,
        resource_group_name,  # type: str
        factory_name,  # type: str
        linked_service_name,  # type: str
        mongodb_type,  # type: str
        mongodb_server,  # type: object
        mongodb_database_name,  # type: object
        if_match=None,  # type: Optional[str]
        mongodb_connect_via=None,  # type: Optional["models.IntegrationRuntimeReference"]
        mongodb_description=None,  # type: Optional[str]
        mongodb_parameters=None,  # type: Optional[Dict[str, "ParameterSpecification"]]
        mongodb_annotations=None,  # type: Optional[List[object]]
        mongodb_authentication_type=None,  # type: Optional[Union[str, "models.MongoDBAuthenticationType"]]
        mongodb_username=None,  # type: Optional[object]
        mongodb_password=None,  # type: Optional["models.SecretBase"]
        mongodb_auth_source=None,  # type: Optional[object]
        mongodb_port=None,  # type: Optional[object]
        mongodb_enable_ssl=None,  # type: Optional[object]
        mongodb_allow_self_signed_server_cert=None,  # type: Optional[object]
        mongodb_encrypted_credential=None,  # type: Optional[object]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.LinkedServiceResource"
        """Creates or updates a linked service.

        :param resource_group_name: The resource group name.
        :type resource_group_name: str
        :param factory_name: The factory name.
        :type factory_name: str
        :param linked_service_name: The linked service name.
        :type linked_service_name: str
        :param mongodb_type: Type of linked service.
        :type mongodb_type: str
        :param mongodb_server: The IP address or server name of the MongoDB server. Type: string (or
         Expression with resultType string).
        :type mongodb_server: object
        :param mongodb_database_name: The name of the MongoDB database that you want to access. Type:
         string (or Expression with resultType string).
        :type mongodb_database_name: object
        :param if_match: ETag of the linkedService entity.  Should only be specified for update, for
         which it should match existing entity or can be * for unconditional update.
        :type if_match: str
        :param mongodb_connect_via: The integration runtime reference.
        :type mongodb_connect_via: ~azure.mgmt.datafactory.models.IntegrationRuntimeReference
        :param mongodb_description: Linked service description.
        :type mongodb_description: str
        :param mongodb_parameters: Parameters for linked service.
        :type mongodb_parameters: dict[str, ~azure.mgmt.datafactory.models.ParameterSpecification]
        :param mongodb_annotations: List of tags that can be used for describing the linked service.
        :type mongodb_annotations: list[object]
        :param mongodb_authentication_type: The authentication type to be used to connect to the
         MongoDB database.
        :type mongodb_authentication_type: str or ~azure.mgmt.datafactory.models.MongoDBAuthenticationType
        :param mongodb_username: Username for authentication. Type: string (or Expression with
         resultType string).
        :type mongodb_username: object
        :param mongodb_password: Password for authentication.
        :type mongodb_password: ~azure.mgmt.datafactory.models.SecretBase
        :param mongodb_auth_source: Database to verify the username and password. Type: string (or
         Expression with resultType string).
        :type mongodb_auth_source: object
        :param mongodb_port: The TCP port number that the MongoDB server uses to listen for client
         connections. The default value is 27017. Type: integer (or Expression with resultType integer),
         minimum: 0.
        :type mongodb_port: object
        :param mongodb_enable_ssl: Specifies whether the connections to the server are encrypted using
         SSL. The default value is false. Type: boolean (or Expression with resultType boolean).
        :type mongodb_enable_ssl: object
        :param mongodb_allow_self_signed_server_cert: Specifies whether to allow self-signed
         certificates from the server. The default value is false. Type: boolean (or Expression with
         resultType boolean).
        :type mongodb_allow_self_signed_server_cert: object
        :param mongodb_encrypted_credential: The encrypted credential used for authentication.
         Credentials are encrypted using the integration runtime credential manager. Type: string (or
         Expression with resultType string).
        :type mongodb_encrypted_credential: object
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: LinkedServiceResource or the result of cls(response)
        :rtype: ~azure.mgmt.datafactory.models.LinkedServiceResource
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.LinkedServiceResource"]
        error_map = kwargs.pop('error_map', {404: ResourceNotFoundError, 409: ResourceExistsError})

        _linked_service = models.LinkedServiceResource(properties=properties, type=mongodb_type, connect_via=mongodb_connect_via, description=mongodb_description, parameters=mongodb_parameters, annotations=mongodb_annotations, server=mongodb_server, authentication_type=mongodb_authentication_type, database_name=mongodb_database_name, username=mongodb_username, password=mongodb_password, auth_source=mongodb_auth_source, port=mongodb_port, enable_ssl=mongodb_enable_ssl, allow_self_signed_server_cert=mongodb_allow_self_signed_server_cert, encrypted_credential=mongodb_encrypted_credential)
        api_version = "2018-06-01"
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.create_or_update_mongodb.metadata['url']
        path_format_arguments = {
            'subscriptionId': self._serialize.url("self._config.subscription_id", self._config.subscription_id, 'str'),
            'resourceGroupName': self._serialize.url("resource_group_name", resource_group_name, 'str', max_length=90, min_length=1, pattern=r'^[-\w\._\(\)]+$'),
            'factoryName': self._serialize.url("factory_name", factory_name, 'str', max_length=63, min_length=3, pattern=r'^[A-Za-z0-9]+(?:-[A-Za-z0-9]+)*$'),
            'linkedServiceName': self._serialize.url("linked_service_name", linked_service_name, 'str', max_length=260, min_length=1, pattern=r'^[A-Za-z0-9_][^<>*#.%&:\\+?/]*$'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = 'application/json'

        # Construct and send request
        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_linked_service, 'LinkedServiceResource')
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = self._deserialize('LinkedServiceResource', pipeline_response)

        if cls:
          return cls(pipeline_response, deserialized, {})

        return deserialized
    create_or_update_mongodb.metadata = {'url': '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataFactory/factories/{factoryName}/linkedservices/{linkedServiceName}'}

    def create_or_update_mongodbv2(
        self,
        resource_group_name,  # type: str
        factory_name,  # type: str
        linked_service_name,  # type: str
        mongodbv2_type,  # type: str
        mongodbv2_connection_string,  # type: object
        mongodbv2_database,  # type: object
        if_match=None,  # type: Optional[str]
        mongodbv2_connect_via=None,  # type: Optional["models.IntegrationRuntimeReference"]
        mongodbv2_description=None,  # type: Optional[str]
        mongodbv2_parameters=None,  # type: Optional[Dict[str, "ParameterSpecification"]]
        mongodbv2_annotations=None,  # type: Optional[List[object]]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.LinkedServiceResource"
        """Creates or updates a linked service.

        :param resource_group_name: The resource group name.
        :type resource_group_name: str
        :param factory_name: The factory name.
        :type factory_name: str
        :param linked_service_name: The linked service name.
        :type linked_service_name: str
        :param mongodbv2_type: Type of linked service.
        :type mongodbv2_type: str
        :param mongodbv2_connection_string: The MongoDB connection string. Type: string, SecureString
         or AzureKeyVaultSecretReference. Type: string, SecureString or AzureKeyVaultSecretReference.
        :type mongodbv2_connection_string: object
        :param mongodbv2_database: The name of the MongoDB database that you want to access. Type:
         string (or Expression with resultType string).
        :type mongodbv2_database: object
        :param if_match: ETag of the linkedService entity.  Should only be specified for update, for
         which it should match existing entity or can be * for unconditional update.
        :type if_match: str
        :param mongodbv2_connect_via: The integration runtime reference.
        :type mongodbv2_connect_via: ~azure.mgmt.datafactory.models.IntegrationRuntimeReference
        :param mongodbv2_description: Linked service description.
        :type mongodbv2_description: str
        :param mongodbv2_parameters: Parameters for linked service.
        :type mongodbv2_parameters: dict[str, ~azure.mgmt.datafactory.models.ParameterSpecification]
        :param mongodbv2_annotations: List of tags that can be used for describing the linked service.
        :type mongodbv2_annotations: list[object]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: LinkedServiceResource or the result of cls(response)
        :rtype: ~azure.mgmt.datafactory.models.LinkedServiceResource
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.LinkedServiceResource"]
        error_map = kwargs.pop('error_map', {404: ResourceNotFoundError, 409: ResourceExistsError})

        _linked_service = models.LinkedServiceResource(properties=properties, type=mongodbv2_type, connect_via=mongodbv2_connect_via, description=mongodbv2_description, parameters=mongodbv2_parameters, annotations=mongodbv2_annotations, connection_string=mongodbv2_connection_string, database=mongodbv2_database)
        api_version = "2018-06-01"
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.create_or_update_mongodbv2.metadata['url']
        path_format_arguments = {
            'subscriptionId': self._serialize.url("self._config.subscription_id", self._config.subscription_id, 'str'),
            'resourceGroupName': self._serialize.url("resource_group_name", resource_group_name, 'str', max_length=90, min_length=1, pattern=r'^[-\w\._\(\)]+$'),
            'factoryName': self._serialize.url("factory_name", factory_name, 'str', max_length=63, min_length=3, pattern=r'^[A-Za-z0-9]+(?:-[A-Za-z0-9]+)*$'),
            'linkedServiceName': self._serialize.url("linked_service_name", linked_service_name, 'str', max_length=260, min_length=1, pattern=r'^[A-Za-z0-9_][^<>*#.%&:\\+?/]*$'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = 'application/json'

        # Construct and send request
        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_linked_service, 'LinkedServiceResource')
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = self._deserialize('LinkedServiceResource', pipeline_response)

        if cls:
          return cls(pipeline_response, deserialized, {})

        return deserialized
    create_or_update_mongodbv2.metadata = {'url': '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataFactory/factories/{factoryName}/linkedservices/{linkedServiceName}'}

    def create_or_update_mysql(
        self,
        resource_group_name,  # type: str
        factory_name,  # type: str
        linked_service_name,  # type: str
        mysql_type,  # type: str
        mysql_connection_string,  # type: object
        if_match=None,  # type: Optional[str]
        mysql_connect_via=None,  # type: Optional["models.IntegrationRuntimeReference"]
        mysql_description=None,  # type: Optional[str]
        mysql_parameters=None,  # type: Optional[Dict[str, "ParameterSpecification"]]
        mysql_annotations=None,  # type: Optional[List[object]]
        mysql_password=None,  # type: Optional["models.AzureKeyVaultSecretReference"]
        mysql_encrypted_credential=None,  # type: Optional[object]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.LinkedServiceResource"
        """Creates or updates a linked service.

        :param resource_group_name: The resource group name.
        :type resource_group_name: str
        :param factory_name: The factory name.
        :type factory_name: str
        :param linked_service_name: The linked service name.
        :type linked_service_name: str
        :param mysql_type: Type of linked service.
        :type mysql_type: str
        :param mysql_connection_string: The connection string.
        :type mysql_connection_string: object
        :param if_match: ETag of the linkedService entity.  Should only be specified for update, for
         which it should match existing entity or can be * for unconditional update.
        :type if_match: str
        :param mysql_connect_via: The integration runtime reference.
        :type mysql_connect_via: ~azure.mgmt.datafactory.models.IntegrationRuntimeReference
        :param mysql_description: Linked service description.
        :type mysql_description: str
        :param mysql_parameters: Parameters for linked service.
        :type mysql_parameters: dict[str, ~azure.mgmt.datafactory.models.ParameterSpecification]
        :param mysql_annotations: List of tags that can be used for describing the linked service.
        :type mysql_annotations: list[object]
        :param mysql_password: The Azure key vault secret reference of password in connection string.
        :type mysql_password: ~azure.mgmt.datafactory.models.AzureKeyVaultSecretReference
        :param mysql_encrypted_credential: The encrypted credential used for authentication.
         Credentials are encrypted using the integration runtime credential manager. Type: string (or
         Expression with resultType string).
        :type mysql_encrypted_credential: object
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: LinkedServiceResource or the result of cls(response)
        :rtype: ~azure.mgmt.datafactory.models.LinkedServiceResource
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.LinkedServiceResource"]
        error_map = kwargs.pop('error_map', {404: ResourceNotFoundError, 409: ResourceExistsError})

        _linked_service = models.LinkedServiceResource(properties=properties, type=mysql_type, connect_via=mysql_connect_via, description=mysql_description, parameters=mysql_parameters, annotations=mysql_annotations, connection_string=mysql_connection_string, password=mysql_password, encrypted_credential=mysql_encrypted_credential)
        api_version = "2018-06-01"
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.create_or_update_mysql.metadata['url']
        path_format_arguments = {
            'subscriptionId': self._serialize.url("self._config.subscription_id", self._config.subscription_id, 'str'),
            'resourceGroupName': self._serialize.url("resource_group_name", resource_group_name, 'str', max_length=90, min_length=1, pattern=r'^[-\w\._\(\)]+$'),
            'factoryName': self._serialize.url("factory_name", factory_name, 'str', max_length=63, min_length=3, pattern=r'^[A-Za-z0-9]+(?:-[A-Za-z0-9]+)*$'),
            'linkedServiceName': self._serialize.url("linked_service_name", linked_service_name, 'str', max_length=260, min_length=1, pattern=r'^[A-Za-z0-9_][^<>*#.%&:\\+?/]*$'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = 'application/json'

        # Construct and send request
        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_linked_service, 'LinkedServiceResource')
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = self._deserialize('LinkedServiceResource', pipeline_response)

        if cls:
          return cls(pipeline_response, deserialized, {})

        return deserialized
    create_or_update_mysql.metadata = {'url': '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataFactory/factories/{factoryName}/linkedservices/{linkedServiceName}'}

    def create_or_update_netezza(
        self,
        resource_group_name,  # type: str
        factory_name,  # type: str
        linked_service_name,  # type: str
        netezza_type,  # type: str
        if_match=None,  # type: Optional[str]
        netezza_connect_via=None,  # type: Optional["models.IntegrationRuntimeReference"]
        netezza_description=None,  # type: Optional[str]
        netezza_parameters=None,  # type: Optional[Dict[str, "ParameterSpecification"]]
        netezza_annotations=None,  # type: Optional[List[object]]
        netezza_connection_string=None,  # type: Optional[object]
        netezza_pwd=None,  # type: Optional["models.AzureKeyVaultSecretReference"]
        netezza_encrypted_credential=None,  # type: Optional[object]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.LinkedServiceResource"
        """Creates or updates a linked service.

        :param resource_group_name: The resource group name.
        :type resource_group_name: str
        :param factory_name: The factory name.
        :type factory_name: str
        :param linked_service_name: The linked service name.
        :type linked_service_name: str
        :param netezza_type: Type of linked service.
        :type netezza_type: str
        :param if_match: ETag of the linkedService entity.  Should only be specified for update, for
         which it should match existing entity or can be * for unconditional update.
        :type if_match: str
        :param netezza_connect_via: The integration runtime reference.
        :type netezza_connect_via: ~azure.mgmt.datafactory.models.IntegrationRuntimeReference
        :param netezza_description: Linked service description.
        :type netezza_description: str
        :param netezza_parameters: Parameters for linked service.
        :type netezza_parameters: dict[str, ~azure.mgmt.datafactory.models.ParameterSpecification]
        :param netezza_annotations: List of tags that can be used for describing the linked service.
        :type netezza_annotations: list[object]
        :param netezza_connection_string: An ODBC connection string. Type: string, SecureString or
         AzureKeyVaultSecretReference.
        :type netezza_connection_string: object
        :param netezza_pwd: The Azure key vault secret reference of password in connection string.
        :type netezza_pwd: ~azure.mgmt.datafactory.models.AzureKeyVaultSecretReference
        :param netezza_encrypted_credential: The encrypted credential used for authentication.
         Credentials are encrypted using the integration runtime credential manager. Type: string (or
         Expression with resultType string).
        :type netezza_encrypted_credential: object
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: LinkedServiceResource or the result of cls(response)
        :rtype: ~azure.mgmt.datafactory.models.LinkedServiceResource
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.LinkedServiceResource"]
        error_map = kwargs.pop('error_map', {404: ResourceNotFoundError, 409: ResourceExistsError})

        _linked_service = models.LinkedServiceResource(properties=properties, type=netezza_type, connect_via=netezza_connect_via, description=netezza_description, parameters=netezza_parameters, annotations=netezza_annotations, connection_string=netezza_connection_string, pwd=netezza_pwd, encrypted_credential=netezza_encrypted_credential)
        api_version = "2018-06-01"
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.create_or_update_netezza.metadata['url']
        path_format_arguments = {
            'subscriptionId': self._serialize.url("self._config.subscription_id", self._config.subscription_id, 'str'),
            'resourceGroupName': self._serialize.url("resource_group_name", resource_group_name, 'str', max_length=90, min_length=1, pattern=r'^[-\w\._\(\)]+$'),
            'factoryName': self._serialize.url("factory_name", factory_name, 'str', max_length=63, min_length=3, pattern=r'^[A-Za-z0-9]+(?:-[A-Za-z0-9]+)*$'),
            'linkedServiceName': self._serialize.url("linked_service_name", linked_service_name, 'str', max_length=260, min_length=1, pattern=r'^[A-Za-z0-9_][^<>*#.%&:\\+?/]*$'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = 'application/json'

        # Construct and send request
        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_linked_service, 'LinkedServiceResource')
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = self._deserialize('LinkedServiceResource', pipeline_response)

        if cls:
          return cls(pipeline_response, deserialized, {})

        return deserialized
    create_or_update_netezza.metadata = {'url': '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataFactory/factories/{factoryName}/linkedservices/{linkedServiceName}'}

    def create_or_update_odata(
        self,
        resource_group_name,  # type: str
        factory_name,  # type: str
        linked_service_name,  # type: str
        odata_type,  # type: str
        odata_url,  # type: object
        if_match=None,  # type: Optional[str]
        odata_connect_via=None,  # type: Optional["models.IntegrationRuntimeReference"]
        odata_description=None,  # type: Optional[str]
        odata_parameters=None,  # type: Optional[Dict[str, "ParameterSpecification"]]
        odata_annotations=None,  # type: Optional[List[object]]
        odata_authentication_type=None,  # type: Optional[Union[str, "models.ODataAuthenticationType"]]
        odata_user_name=None,  # type: Optional[object]
        odata_password=None,  # type: Optional["models.SecretBase"]
        odata_tenant=None,  # type: Optional[object]
        odata_service_principal_id=None,  # type: Optional[object]
        odata_aad_resource_id=None,  # type: Optional[object]
        odata_aad_service_principal_credential_type=None,  # type: Optional[Union[str, "models.ODataAadServicePrincipalCredentialType"]]
        odata_service_principal_key=None,  # type: Optional["models.SecretBase"]
        odata_service_principal_embedded_cert=None,  # type: Optional["models.SecretBase"]
        odata_service_principal_embedded_cert_password=None,  # type: Optional["models.SecretBase"]
        odata_encrypted_credential=None,  # type: Optional[object]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.LinkedServiceResource"
        """Creates or updates a linked service.

        :param resource_group_name: The resource group name.
        :type resource_group_name: str
        :param factory_name: The factory name.
        :type factory_name: str
        :param linked_service_name: The linked service name.
        :type linked_service_name: str
        :param odata_type: Type of linked service.
        :type odata_type: str
        :param odata_url: The URL of the OData service endpoint. Type: string (or Expression with
         resultType string).
        :type odata_url: object
        :param if_match: ETag of the linkedService entity.  Should only be specified for update, for
         which it should match existing entity or can be * for unconditional update.
        :type if_match: str
        :param odata_connect_via: The integration runtime reference.
        :type odata_connect_via: ~azure.mgmt.datafactory.models.IntegrationRuntimeReference
        :param odata_description: Linked service description.
        :type odata_description: str
        :param odata_parameters: Parameters for linked service.
        :type odata_parameters: dict[str, ~azure.mgmt.datafactory.models.ParameterSpecification]
        :param odata_annotations: List of tags that can be used for describing the linked service.
        :type odata_annotations: list[object]
        :param odata_authentication_type: Type of authentication used to connect to the OData service.
        :type odata_authentication_type: str or ~azure.mgmt.datafactory.models.ODataAuthenticationType
        :param odata_user_name: User name of the OData service. Type: string (or Expression with
         resultType string).
        :type odata_user_name: object
        :param odata_password: Password of the OData service.
        :type odata_password: ~azure.mgmt.datafactory.models.SecretBase
        :param odata_tenant: Specify the tenant information (domain name or tenant ID) under which your
         application resides. Type: string (or Expression with resultType string).
        :type odata_tenant: object
        :param odata_service_principal_id: Specify the application id of your application registered in
         Azure Active Directory. Type: string (or Expression with resultType string).
        :type odata_service_principal_id: object
        :param odata_aad_resource_id: Specify the resource you are requesting authorization to use
         Directory. Type: string (or Expression with resultType string).
        :type odata_aad_resource_id: object
        :param odata_aad_service_principal_credential_type: Specify the credential type (key or cert)
         is used for service principal.
        :type odata_aad_service_principal_credential_type: str or ~azure.mgmt.datafactory.models.ODataAadServicePrincipalCredentialType
        :param odata_service_principal_key: Specify the secret of your application registered in Azure
         Active Directory. Type: string (or Expression with resultType string).
        :type odata_service_principal_key: ~azure.mgmt.datafactory.models.SecretBase
        :param odata_service_principal_embedded_cert: Specify the base64 encoded certificate of your
         application registered in Azure Active Directory. Type: string (or Expression with resultType
         string).
        :type odata_service_principal_embedded_cert: ~azure.mgmt.datafactory.models.SecretBase
        :param odata_service_principal_embedded_cert_password: Specify the password of your certificate
         if your certificate has a password and you are using AadServicePrincipal authentication. Type:
         string (or Expression with resultType string).
        :type odata_service_principal_embedded_cert_password: ~azure.mgmt.datafactory.models.SecretBase
        :param odata_encrypted_credential: The encrypted credential used for authentication.
         Credentials are encrypted using the integration runtime credential manager. Type: string (or
         Expression with resultType string).
        :type odata_encrypted_credential: object
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: LinkedServiceResource or the result of cls(response)
        :rtype: ~azure.mgmt.datafactory.models.LinkedServiceResource
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.LinkedServiceResource"]
        error_map = kwargs.pop('error_map', {404: ResourceNotFoundError, 409: ResourceExistsError})

        _linked_service = models.LinkedServiceResource(properties=properties, type=odata_type, connect_via=odata_connect_via, description=odata_description, parameters=odata_parameters, annotations=odata_annotations, url=odata_url, authentication_type=odata_authentication_type, user_name=odata_user_name, password=odata_password, tenant=odata_tenant, service_principal_id=odata_service_principal_id, aad_resource_id=odata_aad_resource_id, aad_service_principal_credential_type=odata_aad_service_principal_credential_type, service_principal_key=odata_service_principal_key, service_principal_embedded_cert=odata_service_principal_embedded_cert, service_principal_embedded_cert_password=odata_service_principal_embedded_cert_password, encrypted_credential=odata_encrypted_credential)
        api_version = "2018-06-01"
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.create_or_update_odata.metadata['url']
        path_format_arguments = {
            'subscriptionId': self._serialize.url("self._config.subscription_id", self._config.subscription_id, 'str'),
            'resourceGroupName': self._serialize.url("resource_group_name", resource_group_name, 'str', max_length=90, min_length=1, pattern=r'^[-\w\._\(\)]+$'),
            'factoryName': self._serialize.url("factory_name", factory_name, 'str', max_length=63, min_length=3, pattern=r'^[A-Za-z0-9]+(?:-[A-Za-z0-9]+)*$'),
            'linkedServiceName': self._serialize.url("linked_service_name", linked_service_name, 'str', max_length=260, min_length=1, pattern=r'^[A-Za-z0-9_][^<>*#.%&:\\+?/]*$'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = 'application/json'

        # Construct and send request
        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_linked_service, 'LinkedServiceResource')
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = self._deserialize('LinkedServiceResource', pipeline_response)

        if cls:
          return cls(pipeline_response, deserialized, {})

        return deserialized
    create_or_update_odata.metadata = {'url': '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataFactory/factories/{factoryName}/linkedservices/{linkedServiceName}'}

    def create_or_update_odbc(
        self,
        resource_group_name,  # type: str
        factory_name,  # type: str
        linked_service_name,  # type: str
        odbc_type,  # type: str
        odbc_connection_string,  # type: object
        if_match=None,  # type: Optional[str]
        odbc_connect_via=None,  # type: Optional["models.IntegrationRuntimeReference"]
        odbc_description=None,  # type: Optional[str]
        odbc_parameters=None,  # type: Optional[Dict[str, "ParameterSpecification"]]
        odbc_annotations=None,  # type: Optional[List[object]]
        odbc_authentication_type=None,  # type: Optional[object]
        odbc_credential=None,  # type: Optional["models.SecretBase"]
        odbc_user_name=None,  # type: Optional[object]
        odbc_password=None,  # type: Optional["models.SecretBase"]
        odbc_encrypted_credential=None,  # type: Optional[object]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.LinkedServiceResource"
        """Creates or updates a linked service.

        :param resource_group_name: The resource group name.
        :type resource_group_name: str
        :param factory_name: The factory name.
        :type factory_name: str
        :param linked_service_name: The linked service name.
        :type linked_service_name: str
        :param odbc_type: Type of linked service.
        :type odbc_type: str
        :param odbc_connection_string: The non-access credential portion of the connection string as
         well as an optional encrypted credential. Type: string, SecureString or
         AzureKeyVaultSecretReference.
        :type odbc_connection_string: object
        :param if_match: ETag of the linkedService entity.  Should only be specified for update, for
         which it should match existing entity or can be * for unconditional update.
        :type if_match: str
        :param odbc_connect_via: The integration runtime reference.
        :type odbc_connect_via: ~azure.mgmt.datafactory.models.IntegrationRuntimeReference
        :param odbc_description: Linked service description.
        :type odbc_description: str
        :param odbc_parameters: Parameters for linked service.
        :type odbc_parameters: dict[str, ~azure.mgmt.datafactory.models.ParameterSpecification]
        :param odbc_annotations: List of tags that can be used for describing the linked service.
        :type odbc_annotations: list[object]
        :param odbc_authentication_type: Type of authentication used to connect to the ODBC data store.
         Possible values are: Anonymous and Basic. Type: string (or Expression with resultType string).
        :type odbc_authentication_type: object
        :param odbc_credential: The access credential portion of the connection string specified in
         driver-specific property-value format.
        :type odbc_credential: ~azure.mgmt.datafactory.models.SecretBase
        :param odbc_user_name: User name for Basic authentication. Type: string (or Expression with
         resultType string).
        :type odbc_user_name: object
        :param odbc_password: Password for Basic authentication.
        :type odbc_password: ~azure.mgmt.datafactory.models.SecretBase
        :param odbc_encrypted_credential: The encrypted credential used for authentication. Credentials
         are encrypted using the integration runtime credential manager. Type: string (or Expression
         with resultType string).
        :type odbc_encrypted_credential: object
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: LinkedServiceResource or the result of cls(response)
        :rtype: ~azure.mgmt.datafactory.models.LinkedServiceResource
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.LinkedServiceResource"]
        error_map = kwargs.pop('error_map', {404: ResourceNotFoundError, 409: ResourceExistsError})

        _linked_service = models.LinkedServiceResource(properties=properties, type=odbc_type, connect_via=odbc_connect_via, description=odbc_description, parameters=odbc_parameters, annotations=odbc_annotations, connection_string=odbc_connection_string, authentication_type=odbc_authentication_type, credential=odbc_credential, user_name=odbc_user_name, password=odbc_password, encrypted_credential=odbc_encrypted_credential)
        api_version = "2018-06-01"
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.create_or_update_odbc.metadata['url']
        path_format_arguments = {
            'subscriptionId': self._serialize.url("self._config.subscription_id", self._config.subscription_id, 'str'),
            'resourceGroupName': self._serialize.url("resource_group_name", resource_group_name, 'str', max_length=90, min_length=1, pattern=r'^[-\w\._\(\)]+$'),
            'factoryName': self._serialize.url("factory_name", factory_name, 'str', max_length=63, min_length=3, pattern=r'^[A-Za-z0-9]+(?:-[A-Za-z0-9]+)*$'),
            'linkedServiceName': self._serialize.url("linked_service_name", linked_service_name, 'str', max_length=260, min_length=1, pattern=r'^[A-Za-z0-9_][^<>*#.%&:\\+?/]*$'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = 'application/json'

        # Construct and send request
        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_linked_service, 'LinkedServiceResource')
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = self._deserialize('LinkedServiceResource', pipeline_response)

        if cls:
          return cls(pipeline_response, deserialized, {})

        return deserialized
    create_or_update_odbc.metadata = {'url': '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataFactory/factories/{factoryName}/linkedservices/{linkedServiceName}'}

    def create_or_update_office365(
        self,
        resource_group_name,  # type: str
        factory_name,  # type: str
        linked_service_name,  # type: str
        office365_type,  # type: str
        office365_office365_tenant_id,  # type: object
        office365_service_principal_tenant_id,  # type: object
        office365_service_principal_id,  # type: object
        office365_service_principal_key,  # type: "models.SecretBase"
        if_match=None,  # type: Optional[str]
        office365_connect_via=None,  # type: Optional["models.IntegrationRuntimeReference"]
        office365_description=None,  # type: Optional[str]
        office365_parameters=None,  # type: Optional[Dict[str, "ParameterSpecification"]]
        office365_annotations=None,  # type: Optional[List[object]]
        office365_encrypted_credential=None,  # type: Optional[object]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.LinkedServiceResource"
        """Creates or updates a linked service.

        :param resource_group_name: The resource group name.
        :type resource_group_name: str
        :param factory_name: The factory name.
        :type factory_name: str
        :param linked_service_name: The linked service name.
        :type linked_service_name: str
        :param office365_type: Type of linked service.
        :type office365_type: str
        :param office365_office365_tenant_id: Azure tenant ID to which the Office 365 account belongs.
         Type: string (or Expression with resultType string).
        :type office365_office365_tenant_id: object
        :param office365_service_principal_tenant_id: Specify the tenant information under which your
         Azure AD web application resides. Type: string (or Expression with resultType string).
        :type office365_service_principal_tenant_id: object
        :param office365_service_principal_id: Specify the application's client ID. Type: string (or
         Expression with resultType string).
        :type office365_service_principal_id: object
        :param office365_service_principal_key: Specify the application's key.
        :type office365_service_principal_key: ~azure.mgmt.datafactory.models.SecretBase
        :param if_match: ETag of the linkedService entity.  Should only be specified for update, for
         which it should match existing entity or can be * for unconditional update.
        :type if_match: str
        :param office365_connect_via: The integration runtime reference.
        :type office365_connect_via: ~azure.mgmt.datafactory.models.IntegrationRuntimeReference
        :param office365_description: Linked service description.
        :type office365_description: str
        :param office365_parameters: Parameters for linked service.
        :type office365_parameters: dict[str, ~azure.mgmt.datafactory.models.ParameterSpecification]
        :param office365_annotations: List of tags that can be used for describing the linked service.
        :type office365_annotations: list[object]
        :param office365_encrypted_credential: The encrypted credential used for authentication.
         Credentials are encrypted using the integration runtime credential manager. Type: string (or
         Expression with resultType string).
        :type office365_encrypted_credential: object
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: LinkedServiceResource or the result of cls(response)
        :rtype: ~azure.mgmt.datafactory.models.LinkedServiceResource
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.LinkedServiceResource"]
        error_map = kwargs.pop('error_map', {404: ResourceNotFoundError, 409: ResourceExistsError})

        _linked_service = models.LinkedServiceResource(properties=properties, type=office365_type, connect_via=office365_connect_via, description=office365_description, parameters=office365_parameters, annotations=office365_annotations, office365_tenant_id=office365_office365_tenant_id, service_principal_tenant_id=office365_service_principal_tenant_id, service_principal_id=office365_service_principal_id, service_principal_key=office365_service_principal_key, encrypted_credential=office365_encrypted_credential)
        api_version = "2018-06-01"
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.create_or_update_office365.metadata['url']
        path_format_arguments = {
            'subscriptionId': self._serialize.url("self._config.subscription_id", self._config.subscription_id, 'str'),
            'resourceGroupName': self._serialize.url("resource_group_name", resource_group_name, 'str', max_length=90, min_length=1, pattern=r'^[-\w\._\(\)]+$'),
            'factoryName': self._serialize.url("factory_name", factory_name, 'str', max_length=63, min_length=3, pattern=r'^[A-Za-z0-9]+(?:-[A-Za-z0-9]+)*$'),
            'linkedServiceName': self._serialize.url("linked_service_name", linked_service_name, 'str', max_length=260, min_length=1, pattern=r'^[A-Za-z0-9_][^<>*#.%&:\\+?/]*$'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = 'application/json'

        # Construct and send request
        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_linked_service, 'LinkedServiceResource')
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = self._deserialize('LinkedServiceResource', pipeline_response)

        if cls:
          return cls(pipeline_response, deserialized, {})

        return deserialized
    create_or_update_office365.metadata = {'url': '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataFactory/factories/{factoryName}/linkedservices/{linkedServiceName}'}

    def create_or_update_oracle(
        self,
        resource_group_name,  # type: str
        factory_name,  # type: str
        linked_service_name,  # type: str
        oracle_type,  # type: str
        oracle_connection_string,  # type: object
        if_match=None,  # type: Optional[str]
        oracle_connect_via=None,  # type: Optional["models.IntegrationRuntimeReference"]
        oracle_description=None,  # type: Optional[str]
        oracle_parameters=None,  # type: Optional[Dict[str, "ParameterSpecification"]]
        oracle_annotations=None,  # type: Optional[List[object]]
        oracle_password=None,  # type: Optional["models.AzureKeyVaultSecretReference"]
        oracle_encrypted_credential=None,  # type: Optional[object]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.LinkedServiceResource"
        """Creates or updates a linked service.

        :param resource_group_name: The resource group name.
        :type resource_group_name: str
        :param factory_name: The factory name.
        :type factory_name: str
        :param linked_service_name: The linked service name.
        :type linked_service_name: str
        :param oracle_type: Type of linked service.
        :type oracle_type: str
        :param oracle_connection_string: The connection string. Type: string, SecureString or
         AzureKeyVaultSecretReference.
        :type oracle_connection_string: object
        :param if_match: ETag of the linkedService entity.  Should only be specified for update, for
         which it should match existing entity or can be * for unconditional update.
        :type if_match: str
        :param oracle_connect_via: The integration runtime reference.
        :type oracle_connect_via: ~azure.mgmt.datafactory.models.IntegrationRuntimeReference
        :param oracle_description: Linked service description.
        :type oracle_description: str
        :param oracle_parameters: Parameters for linked service.
        :type oracle_parameters: dict[str, ~azure.mgmt.datafactory.models.ParameterSpecification]
        :param oracle_annotations: List of tags that can be used for describing the linked service.
        :type oracle_annotations: list[object]
        :param oracle_password: The Azure key vault secret reference of password in connection string.
        :type oracle_password: ~azure.mgmt.datafactory.models.AzureKeyVaultSecretReference
        :param oracle_encrypted_credential: The encrypted credential used for authentication.
         Credentials are encrypted using the integration runtime credential manager. Type: string (or
         Expression with resultType string).
        :type oracle_encrypted_credential: object
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: LinkedServiceResource or the result of cls(response)
        :rtype: ~azure.mgmt.datafactory.models.LinkedServiceResource
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.LinkedServiceResource"]
        error_map = kwargs.pop('error_map', {404: ResourceNotFoundError, 409: ResourceExistsError})

        _linked_service = models.LinkedServiceResource(properties=properties, type=oracle_type, connect_via=oracle_connect_via, description=oracle_description, parameters=oracle_parameters, annotations=oracle_annotations, connection_string=oracle_connection_string, password=oracle_password, encrypted_credential=oracle_encrypted_credential)
        api_version = "2018-06-01"
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.create_or_update_oracle.metadata['url']
        path_format_arguments = {
            'subscriptionId': self._serialize.url("self._config.subscription_id", self._config.subscription_id, 'str'),
            'resourceGroupName': self._serialize.url("resource_group_name", resource_group_name, 'str', max_length=90, min_length=1, pattern=r'^[-\w\._\(\)]+$'),
            'factoryName': self._serialize.url("factory_name", factory_name, 'str', max_length=63, min_length=3, pattern=r'^[A-Za-z0-9]+(?:-[A-Za-z0-9]+)*$'),
            'linkedServiceName': self._serialize.url("linked_service_name", linked_service_name, 'str', max_length=260, min_length=1, pattern=r'^[A-Za-z0-9_][^<>*#.%&:\\+?/]*$'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = 'application/json'

        # Construct and send request
        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_linked_service, 'LinkedServiceResource')
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = self._deserialize('LinkedServiceResource', pipeline_response)

        if cls:
          return cls(pipeline_response, deserialized, {})

        return deserialized
    create_or_update_oracle.metadata = {'url': '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataFactory/factories/{factoryName}/linkedservices/{linkedServiceName}'}

    def create_or_update_oracleservicecloud(
        self,
        resource_group_name,  # type: str
        factory_name,  # type: str
        linked_service_name,  # type: str
        oracleservicecloud_type,  # type: str
        oracleservicecloud_host,  # type: object
        oracleservicecloud_username,  # type: object
        oracleservicecloud_password,  # type: "models.SecretBase"
        if_match=None,  # type: Optional[str]
        oracleservicecloud_connect_via=None,  # type: Optional["models.IntegrationRuntimeReference"]
        oracleservicecloud_description=None,  # type: Optional[str]
        oracleservicecloud_parameters=None,  # type: Optional[Dict[str, "ParameterSpecification"]]
        oracleservicecloud_annotations=None,  # type: Optional[List[object]]
        oracleservicecloud_use_encrypted_endpoints=None,  # type: Optional[object]
        oracleservicecloud_use_host_verification=None,  # type: Optional[object]
        oracleservicecloud_use_peer_verification=None,  # type: Optional[object]
        oracleservicecloud_encrypted_credential=None,  # type: Optional[object]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.LinkedServiceResource"
        """Creates or updates a linked service.

        :param resource_group_name: The resource group name.
        :type resource_group_name: str
        :param factory_name: The factory name.
        :type factory_name: str
        :param linked_service_name: The linked service name.
        :type linked_service_name: str
        :param oracleservicecloud_type: Type of linked service.
        :type oracleservicecloud_type: str
        :param oracleservicecloud_host: The URL of the Oracle Service Cloud instance.
        :type oracleservicecloud_host: object
        :param oracleservicecloud_username: The user name that you use to access Oracle Service Cloud
         server.
        :type oracleservicecloud_username: object
        :param oracleservicecloud_password: The password corresponding to the user name that you
         provided in the username key.
        :type oracleservicecloud_password: ~azure.mgmt.datafactory.models.SecretBase
        :param if_match: ETag of the linkedService entity.  Should only be specified for update, for
         which it should match existing entity or can be * for unconditional update.
        :type if_match: str
        :param oracleservicecloud_connect_via: The integration runtime reference.
        :type oracleservicecloud_connect_via: ~azure.mgmt.datafactory.models.IntegrationRuntimeReference
        :param oracleservicecloud_description: Linked service description.
        :type oracleservicecloud_description: str
        :param oracleservicecloud_parameters: Parameters for linked service.
        :type oracleservicecloud_parameters: dict[str, ~azure.mgmt.datafactory.models.ParameterSpecification]
        :param oracleservicecloud_annotations: List of tags that can be used for describing the linked
         service.
        :type oracleservicecloud_annotations: list[object]
        :param oracleservicecloud_use_encrypted_endpoints: Specifies whether the data source endpoints
         are encrypted using HTTPS. The default value is true. Type: boolean (or Expression with
         resultType boolean).
        :type oracleservicecloud_use_encrypted_endpoints: object
        :param oracleservicecloud_use_host_verification: Specifies whether to require the host name in
         the server's certificate to match the host name of the server when connecting over SSL. The
         default value is true. Type: boolean (or Expression with resultType boolean).
        :type oracleservicecloud_use_host_verification: object
        :param oracleservicecloud_use_peer_verification: Specifies whether to verify the identity of
         the server when connecting over SSL. The default value is true. Type: boolean (or Expression
         with resultType boolean).
        :type oracleservicecloud_use_peer_verification: object
        :param oracleservicecloud_encrypted_credential: The encrypted credential used for
         authentication. Credentials are encrypted using the integration runtime credential manager.
         Type: string (or Expression with resultType string).
        :type oracleservicecloud_encrypted_credential: object
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: LinkedServiceResource or the result of cls(response)
        :rtype: ~azure.mgmt.datafactory.models.LinkedServiceResource
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.LinkedServiceResource"]
        error_map = kwargs.pop('error_map', {404: ResourceNotFoundError, 409: ResourceExistsError})

        _linked_service = models.LinkedServiceResource(properties=properties, type=oracleservicecloud_type, connect_via=oracleservicecloud_connect_via, description=oracleservicecloud_description, parameters=oracleservicecloud_parameters, annotations=oracleservicecloud_annotations, host=oracleservicecloud_host, username=oracleservicecloud_username, password=oracleservicecloud_password, use_encrypted_endpoints=oracleservicecloud_use_encrypted_endpoints, use_host_verification=oracleservicecloud_use_host_verification, use_peer_verification=oracleservicecloud_use_peer_verification, encrypted_credential=oracleservicecloud_encrypted_credential)
        api_version = "2018-06-01"
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.create_or_update_oracleservicecloud.metadata['url']
        path_format_arguments = {
            'subscriptionId': self._serialize.url("self._config.subscription_id", self._config.subscription_id, 'str'),
            'resourceGroupName': self._serialize.url("resource_group_name", resource_group_name, 'str', max_length=90, min_length=1, pattern=r'^[-\w\._\(\)]+$'),
            'factoryName': self._serialize.url("factory_name", factory_name, 'str', max_length=63, min_length=3, pattern=r'^[A-Za-z0-9]+(?:-[A-Za-z0-9]+)*$'),
            'linkedServiceName': self._serialize.url("linked_service_name", linked_service_name, 'str', max_length=260, min_length=1, pattern=r'^[A-Za-z0-9_][^<>*#.%&:\\+?/]*$'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = 'application/json'

        # Construct and send request
        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_linked_service, 'LinkedServiceResource')
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = self._deserialize('LinkedServiceResource', pipeline_response)

        if cls:
          return cls(pipeline_response, deserialized, {})

        return deserialized
    create_or_update_oracleservicecloud.metadata = {'url': '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataFactory/factories/{factoryName}/linkedservices/{linkedServiceName}'}

    def create_or_update_paypal(
        self,
        resource_group_name,  # type: str
        factory_name,  # type: str
        linked_service_name,  # type: str
        paypal_type,  # type: str
        paypal_host,  # type: object
        paypal_client_id,  # type: object
        if_match=None,  # type: Optional[str]
        paypal_connect_via=None,  # type: Optional["models.IntegrationRuntimeReference"]
        paypal_description=None,  # type: Optional[str]
        paypal_parameters=None,  # type: Optional[Dict[str, "ParameterSpecification"]]
        paypal_annotations=None,  # type: Optional[List[object]]
        paypal_client_secret=None,  # type: Optional["models.SecretBase"]
        paypal_use_encrypted_endpoints=None,  # type: Optional[object]
        paypal_use_host_verification=None,  # type: Optional[object]
        paypal_use_peer_verification=None,  # type: Optional[object]
        paypal_encrypted_credential=None,  # type: Optional[object]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.LinkedServiceResource"
        """Creates or updates a linked service.

        :param resource_group_name: The resource group name.
        :type resource_group_name: str
        :param factory_name: The factory name.
        :type factory_name: str
        :param linked_service_name: The linked service name.
        :type linked_service_name: str
        :param paypal_type: Type of linked service.
        :type paypal_type: str
        :param paypal_host: The URL of the PayPal instance. (i.e. api.sandbox.paypal.com).
        :type paypal_host: object
        :param paypal_client_id: The client ID associated with your PayPal application.
        :type paypal_client_id: object
        :param if_match: ETag of the linkedService entity.  Should only be specified for update, for
         which it should match existing entity or can be * for unconditional update.
        :type if_match: str
        :param paypal_connect_via: The integration runtime reference.
        :type paypal_connect_via: ~azure.mgmt.datafactory.models.IntegrationRuntimeReference
        :param paypal_description: Linked service description.
        :type paypal_description: str
        :param paypal_parameters: Parameters for linked service.
        :type paypal_parameters: dict[str, ~azure.mgmt.datafactory.models.ParameterSpecification]
        :param paypal_annotations: List of tags that can be used for describing the linked service.
        :type paypal_annotations: list[object]
        :param paypal_client_secret: The client secret associated with your PayPal application.
        :type paypal_client_secret: ~azure.mgmt.datafactory.models.SecretBase
        :param paypal_use_encrypted_endpoints: Specifies whether the data source endpoints are
         encrypted using HTTPS. The default value is true.
        :type paypal_use_encrypted_endpoints: object
        :param paypal_use_host_verification: Specifies whether to require the host name in the server's
         certificate to match the host name of the server when connecting over SSL. The default value is
         true.
        :type paypal_use_host_verification: object
        :param paypal_use_peer_verification: Specifies whether to verify the identity of the server
         when connecting over SSL. The default value is true.
        :type paypal_use_peer_verification: object
        :param paypal_encrypted_credential: The encrypted credential used for authentication.
         Credentials are encrypted using the integration runtime credential manager. Type: string (or
         Expression with resultType string).
        :type paypal_encrypted_credential: object
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: LinkedServiceResource or the result of cls(response)
        :rtype: ~azure.mgmt.datafactory.models.LinkedServiceResource
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.LinkedServiceResource"]
        error_map = kwargs.pop('error_map', {404: ResourceNotFoundError, 409: ResourceExistsError})

        _linked_service = models.LinkedServiceResource(properties=properties, type=paypal_type, connect_via=paypal_connect_via, description=paypal_description, parameters=paypal_parameters, annotations=paypal_annotations, host=paypal_host, client_id=paypal_client_id, client_secret=paypal_client_secret, use_encrypted_endpoints=paypal_use_encrypted_endpoints, use_host_verification=paypal_use_host_verification, use_peer_verification=paypal_use_peer_verification, encrypted_credential=paypal_encrypted_credential)
        api_version = "2018-06-01"
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.create_or_update_paypal.metadata['url']
        path_format_arguments = {
            'subscriptionId': self._serialize.url("self._config.subscription_id", self._config.subscription_id, 'str'),
            'resourceGroupName': self._serialize.url("resource_group_name", resource_group_name, 'str', max_length=90, min_length=1, pattern=r'^[-\w\._\(\)]+$'),
            'factoryName': self._serialize.url("factory_name", factory_name, 'str', max_length=63, min_length=3, pattern=r'^[A-Za-z0-9]+(?:-[A-Za-z0-9]+)*$'),
            'linkedServiceName': self._serialize.url("linked_service_name", linked_service_name, 'str', max_length=260, min_length=1, pattern=r'^[A-Za-z0-9_][^<>*#.%&:\\+?/]*$'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = 'application/json'

        # Construct and send request
        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_linked_service, 'LinkedServiceResource')
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = self._deserialize('LinkedServiceResource', pipeline_response)

        if cls:
          return cls(pipeline_response, deserialized, {})

        return deserialized
    create_or_update_paypal.metadata = {'url': '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataFactory/factories/{factoryName}/linkedservices/{linkedServiceName}'}

    def create_or_update_phoenix(
        self,
        resource_group_name,  # type: str
        factory_name,  # type: str
        linked_service_name,  # type: str
        phoenix_type,  # type: str
        phoenix_host,  # type: object
        phoenix_authentication_type,  # type: Union[str, "models.PhoenixAuthenticationType"]
        if_match=None,  # type: Optional[str]
        phoenix_connect_via=None,  # type: Optional["models.IntegrationRuntimeReference"]
        phoenix_description=None,  # type: Optional[str]
        phoenix_parameters=None,  # type: Optional[Dict[str, "ParameterSpecification"]]
        phoenix_annotations=None,  # type: Optional[List[object]]
        phoenix_port=None,  # type: Optional[object]
        phoenix_http_path=None,  # type: Optional[object]
        phoenix_username=None,  # type: Optional[object]
        phoenix_password=None,  # type: Optional["models.SecretBase"]
        phoenix_enable_ssl=None,  # type: Optional[object]
        phoenix_trusted_cert_path=None,  # type: Optional[object]
        phoenix_use_system_trust_store=None,  # type: Optional[object]
        phoenix_allow_host_name_cn_mismatch=None,  # type: Optional[object]
        phoenix_allow_self_signed_server_cert=None,  # type: Optional[object]
        phoenix_encrypted_credential=None,  # type: Optional[object]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.LinkedServiceResource"
        """Creates or updates a linked service.

        :param resource_group_name: The resource group name.
        :type resource_group_name: str
        :param factory_name: The factory name.
        :type factory_name: str
        :param linked_service_name: The linked service name.
        :type linked_service_name: str
        :param phoenix_type: Type of linked service.
        :type phoenix_type: str
        :param phoenix_host: The IP address or host name of the Phoenix server. (i.e. 192.168.222.160).
        :type phoenix_host: object
        :param phoenix_authentication_type: The authentication mechanism used to connect to the Phoenix
         server.
        :type phoenix_authentication_type: str or ~azure.mgmt.datafactory.models.PhoenixAuthenticationType
        :param if_match: ETag of the linkedService entity.  Should only be specified for update, for
         which it should match existing entity or can be * for unconditional update.
        :type if_match: str
        :param phoenix_connect_via: The integration runtime reference.
        :type phoenix_connect_via: ~azure.mgmt.datafactory.models.IntegrationRuntimeReference
        :param phoenix_description: Linked service description.
        :type phoenix_description: str
        :param phoenix_parameters: Parameters for linked service.
        :type phoenix_parameters: dict[str, ~azure.mgmt.datafactory.models.ParameterSpecification]
        :param phoenix_annotations: List of tags that can be used for describing the linked service.
        :type phoenix_annotations: list[object]
        :param phoenix_port: The TCP port that the Phoenix server uses to listen for client
         connections. The default value is 8765.
        :type phoenix_port: object
        :param phoenix_http_path: The partial URL corresponding to the Phoenix server. (i.e.
         /gateway/sandbox/phoenix/version). The default value is hbasephoenix if using
         WindowsAzureHDInsightService.
        :type phoenix_http_path: object
        :param phoenix_username: The user name used to connect to the Phoenix server.
        :type phoenix_username: object
        :param phoenix_password: The password corresponding to the user name.
        :type phoenix_password: ~azure.mgmt.datafactory.models.SecretBase
        :param phoenix_enable_ssl: Specifies whether the connections to the server are encrypted using
         SSL. The default value is false.
        :type phoenix_enable_ssl: object
        :param phoenix_trusted_cert_path: The full path of the .pem file containing trusted CA
         certificates for verifying the server when connecting over SSL. This property can only be set
         when using SSL on self-hosted IR. The default value is the cacerts.pem file installed with the
         IR.
        :type phoenix_trusted_cert_path: object
        :param phoenix_use_system_trust_store: Specifies whether to use a CA certificate from the
         system trust store or from a specified PEM file. The default value is false.
        :type phoenix_use_system_trust_store: object
        :param phoenix_allow_host_name_cn_mismatch: Specifies whether to require a CA-issued SSL
         certificate name to match the host name of the server when connecting over SSL. The default
         value is false.
        :type phoenix_allow_host_name_cn_mismatch: object
        :param phoenix_allow_self_signed_server_cert: Specifies whether to allow self-signed
         certificates from the server. The default value is false.
        :type phoenix_allow_self_signed_server_cert: object
        :param phoenix_encrypted_credential: The encrypted credential used for authentication.
         Credentials are encrypted using the integration runtime credential manager. Type: string (or
         Expression with resultType string).
        :type phoenix_encrypted_credential: object
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: LinkedServiceResource or the result of cls(response)
        :rtype: ~azure.mgmt.datafactory.models.LinkedServiceResource
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.LinkedServiceResource"]
        error_map = kwargs.pop('error_map', {404: ResourceNotFoundError, 409: ResourceExistsError})

        _linked_service = models.LinkedServiceResource(properties=properties, type=phoenix_type, connect_via=phoenix_connect_via, description=phoenix_description, parameters=phoenix_parameters, annotations=phoenix_annotations, host=phoenix_host, port=phoenix_port, http_path=phoenix_http_path, authentication_type=phoenix_authentication_type, username=phoenix_username, password=phoenix_password, enable_ssl=phoenix_enable_ssl, trusted_cert_path=phoenix_trusted_cert_path, use_system_trust_store=phoenix_use_system_trust_store, allow_host_name_cn_mismatch=phoenix_allow_host_name_cn_mismatch, allow_self_signed_server_cert=phoenix_allow_self_signed_server_cert, encrypted_credential=phoenix_encrypted_credential)
        api_version = "2018-06-01"
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.create_or_update_phoenix.metadata['url']
        path_format_arguments = {
            'subscriptionId': self._serialize.url("self._config.subscription_id", self._config.subscription_id, 'str'),
            'resourceGroupName': self._serialize.url("resource_group_name", resource_group_name, 'str', max_length=90, min_length=1, pattern=r'^[-\w\._\(\)]+$'),
            'factoryName': self._serialize.url("factory_name", factory_name, 'str', max_length=63, min_length=3, pattern=r'^[A-Za-z0-9]+(?:-[A-Za-z0-9]+)*$'),
            'linkedServiceName': self._serialize.url("linked_service_name", linked_service_name, 'str', max_length=260, min_length=1, pattern=r'^[A-Za-z0-9_][^<>*#.%&:\\+?/]*$'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = 'application/json'

        # Construct and send request
        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_linked_service, 'LinkedServiceResource')
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = self._deserialize('LinkedServiceResource', pipeline_response)

        if cls:
          return cls(pipeline_response, deserialized, {})

        return deserialized
    create_or_update_phoenix.metadata = {'url': '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataFactory/factories/{factoryName}/linkedservices/{linkedServiceName}'}

    def create_or_update_postgresql(
        self,
        resource_group_name,  # type: str
        factory_name,  # type: str
        linked_service_name,  # type: str
        postgresql_type,  # type: str
        postgresql_connection_string,  # type: object
        if_match=None,  # type: Optional[str]
        postgresql_connect_via=None,  # type: Optional["models.IntegrationRuntimeReference"]
        postgresql_description=None,  # type: Optional[str]
        postgresql_parameters=None,  # type: Optional[Dict[str, "ParameterSpecification"]]
        postgresql_annotations=None,  # type: Optional[List[object]]
        postgresql_password=None,  # type: Optional["models.AzureKeyVaultSecretReference"]
        postgresql_encrypted_credential=None,  # type: Optional[object]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.LinkedServiceResource"
        """Creates or updates a linked service.

        :param resource_group_name: The resource group name.
        :type resource_group_name: str
        :param factory_name: The factory name.
        :type factory_name: str
        :param linked_service_name: The linked service name.
        :type linked_service_name: str
        :param postgresql_type: Type of linked service.
        :type postgresql_type: str
        :param postgresql_connection_string: The connection string.
        :type postgresql_connection_string: object
        :param if_match: ETag of the linkedService entity.  Should only be specified for update, for
         which it should match existing entity or can be * for unconditional update.
        :type if_match: str
        :param postgresql_connect_via: The integration runtime reference.
        :type postgresql_connect_via: ~azure.mgmt.datafactory.models.IntegrationRuntimeReference
        :param postgresql_description: Linked service description.
        :type postgresql_description: str
        :param postgresql_parameters: Parameters for linked service.
        :type postgresql_parameters: dict[str, ~azure.mgmt.datafactory.models.ParameterSpecification]
        :param postgresql_annotations: List of tags that can be used for describing the linked service.
        :type postgresql_annotations: list[object]
        :param postgresql_password: The Azure key vault secret reference of password in connection
         string.
        :type postgresql_password: ~azure.mgmt.datafactory.models.AzureKeyVaultSecretReference
        :param postgresql_encrypted_credential: The encrypted credential used for authentication.
         Credentials are encrypted using the integration runtime credential manager. Type: string (or
         Expression with resultType string).
        :type postgresql_encrypted_credential: object
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: LinkedServiceResource or the result of cls(response)
        :rtype: ~azure.mgmt.datafactory.models.LinkedServiceResource
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.LinkedServiceResource"]
        error_map = kwargs.pop('error_map', {404: ResourceNotFoundError, 409: ResourceExistsError})

        _linked_service = models.LinkedServiceResource(properties=properties, type=postgresql_type, connect_via=postgresql_connect_via, description=postgresql_description, parameters=postgresql_parameters, annotations=postgresql_annotations, connection_string=postgresql_connection_string, password=postgresql_password, encrypted_credential=postgresql_encrypted_credential)
        api_version = "2018-06-01"
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.create_or_update_postgresql.metadata['url']
        path_format_arguments = {
            'subscriptionId': self._serialize.url("self._config.subscription_id", self._config.subscription_id, 'str'),
            'resourceGroupName': self._serialize.url("resource_group_name", resource_group_name, 'str', max_length=90, min_length=1, pattern=r'^[-\w\._\(\)]+$'),
            'factoryName': self._serialize.url("factory_name", factory_name, 'str', max_length=63, min_length=3, pattern=r'^[A-Za-z0-9]+(?:-[A-Za-z0-9]+)*$'),
            'linkedServiceName': self._serialize.url("linked_service_name", linked_service_name, 'str', max_length=260, min_length=1, pattern=r'^[A-Za-z0-9_][^<>*#.%&:\\+?/]*$'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = 'application/json'

        # Construct and send request
        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_linked_service, 'LinkedServiceResource')
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = self._deserialize('LinkedServiceResource', pipeline_response)

        if cls:
          return cls(pipeline_response, deserialized, {})

        return deserialized
    create_or_update_postgresql.metadata = {'url': '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataFactory/factories/{factoryName}/linkedservices/{linkedServiceName}'}

    def create_or_update_presto(
        self,
        resource_group_name,  # type: str
        factory_name,  # type: str
        linked_service_name,  # type: str
        presto_type,  # type: str
        presto_host,  # type: object
        presto_server_version,  # type: object
        presto_catalog,  # type: object
        presto_authentication_type,  # type: Union[str, "models.PrestoAuthenticationType"]
        if_match=None,  # type: Optional[str]
        presto_connect_via=None,  # type: Optional["models.IntegrationRuntimeReference"]
        presto_description=None,  # type: Optional[str]
        presto_parameters=None,  # type: Optional[Dict[str, "ParameterSpecification"]]
        presto_annotations=None,  # type: Optional[List[object]]
        presto_port=None,  # type: Optional[object]
        presto_username=None,  # type: Optional[object]
        presto_password=None,  # type: Optional["models.SecretBase"]
        presto_enable_ssl=None,  # type: Optional[object]
        presto_trusted_cert_path=None,  # type: Optional[object]
        presto_use_system_trust_store=None,  # type: Optional[object]
        presto_allow_host_name_cn_mismatch=None,  # type: Optional[object]
        presto_allow_self_signed_server_cert=None,  # type: Optional[object]
        presto_time_zone_id=None,  # type: Optional[object]
        presto_encrypted_credential=None,  # type: Optional[object]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.LinkedServiceResource"
        """Creates or updates a linked service.

        :param resource_group_name: The resource group name.
        :type resource_group_name: str
        :param factory_name: The factory name.
        :type factory_name: str
        :param linked_service_name: The linked service name.
        :type linked_service_name: str
        :param presto_type: Type of linked service.
        :type presto_type: str
        :param presto_host: The IP address or host name of the Presto server. (i.e. 192.168.222.160).
        :type presto_host: object
        :param presto_server_version: The version of the Presto server. (i.e. 0.148-t).
        :type presto_server_version: object
        :param presto_catalog: The catalog context for all request against the server.
        :type presto_catalog: object
        :param presto_authentication_type: The authentication mechanism used to connect to the Presto
         server.
        :type presto_authentication_type: str or ~azure.mgmt.datafactory.models.PrestoAuthenticationType
        :param if_match: ETag of the linkedService entity.  Should only be specified for update, for
         which it should match existing entity or can be * for unconditional update.
        :type if_match: str
        :param presto_connect_via: The integration runtime reference.
        :type presto_connect_via: ~azure.mgmt.datafactory.models.IntegrationRuntimeReference
        :param presto_description: Linked service description.
        :type presto_description: str
        :param presto_parameters: Parameters for linked service.
        :type presto_parameters: dict[str, ~azure.mgmt.datafactory.models.ParameterSpecification]
        :param presto_annotations: List of tags that can be used for describing the linked service.
        :type presto_annotations: list[object]
        :param presto_port: The TCP port that the Presto server uses to listen for client connections.
         The default value is 8080.
        :type presto_port: object
        :param presto_username: The user name used to connect to the Presto server.
        :type presto_username: object
        :param presto_password: The password corresponding to the user name.
        :type presto_password: ~azure.mgmt.datafactory.models.SecretBase
        :param presto_enable_ssl: Specifies whether the connections to the server are encrypted using
         SSL. The default value is false.
        :type presto_enable_ssl: object
        :param presto_trusted_cert_path: The full path of the .pem file containing trusted CA
         certificates for verifying the server when connecting over SSL. This property can only be set
         when using SSL on self-hosted IR. The default value is the cacerts.pem file installed with the
         IR.
        :type presto_trusted_cert_path: object
        :param presto_use_system_trust_store: Specifies whether to use a CA certificate from the system
         trust store or from a specified PEM file. The default value is false.
        :type presto_use_system_trust_store: object
        :param presto_allow_host_name_cn_mismatch: Specifies whether to require a CA-issued SSL
         certificate name to match the host name of the server when connecting over SSL. The default
         value is false.
        :type presto_allow_host_name_cn_mismatch: object
        :param presto_allow_self_signed_server_cert: Specifies whether to allow self-signed
         certificates from the server. The default value is false.
        :type presto_allow_self_signed_server_cert: object
        :param presto_time_zone_id: The local time zone used by the connection. Valid values for this
         option are specified in the IANA Time Zone Database. The default value is the system time zone.
        :type presto_time_zone_id: object
        :param presto_encrypted_credential: The encrypted credential used for authentication.
         Credentials are encrypted using the integration runtime credential manager. Type: string (or
         Expression with resultType string).
        :type presto_encrypted_credential: object
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: LinkedServiceResource or the result of cls(response)
        :rtype: ~azure.mgmt.datafactory.models.LinkedServiceResource
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.LinkedServiceResource"]
        error_map = kwargs.pop('error_map', {404: ResourceNotFoundError, 409: ResourceExistsError})

        _linked_service = models.LinkedServiceResource(properties=properties, type=presto_type, connect_via=presto_connect_via, description=presto_description, parameters=presto_parameters, annotations=presto_annotations, host=presto_host, server_version=presto_server_version, catalog=presto_catalog, port=presto_port, authentication_type=presto_authentication_type, username=presto_username, password=presto_password, enable_ssl=presto_enable_ssl, trusted_cert_path=presto_trusted_cert_path, use_system_trust_store=presto_use_system_trust_store, allow_host_name_cn_mismatch=presto_allow_host_name_cn_mismatch, allow_self_signed_server_cert=presto_allow_self_signed_server_cert, time_zone_id=presto_time_zone_id, encrypted_credential=presto_encrypted_credential)
        api_version = "2018-06-01"
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.create_or_update_presto.metadata['url']
        path_format_arguments = {
            'subscriptionId': self._serialize.url("self._config.subscription_id", self._config.subscription_id, 'str'),
            'resourceGroupName': self._serialize.url("resource_group_name", resource_group_name, 'str', max_length=90, min_length=1, pattern=r'^[-\w\._\(\)]+$'),
            'factoryName': self._serialize.url("factory_name", factory_name, 'str', max_length=63, min_length=3, pattern=r'^[A-Za-z0-9]+(?:-[A-Za-z0-9]+)*$'),
            'linkedServiceName': self._serialize.url("linked_service_name", linked_service_name, 'str', max_length=260, min_length=1, pattern=r'^[A-Za-z0-9_][^<>*#.%&:\\+?/]*$'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = 'application/json'

        # Construct and send request
        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_linked_service, 'LinkedServiceResource')
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = self._deserialize('LinkedServiceResource', pipeline_response)

        if cls:
          return cls(pipeline_response, deserialized, {})

        return deserialized
    create_or_update_presto.metadata = {'url': '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataFactory/factories/{factoryName}/linkedservices/{linkedServiceName}'}

    def create_or_update_quickbooks(
        self,
        resource_group_name,  # type: str
        factory_name,  # type: str
        linked_service_name,  # type: str
        quickbooks_type,  # type: str
        quickbooks_endpoint,  # type: object
        quickbooks_company_id,  # type: object
        quickbooks_consumer_key,  # type: object
        quickbooks_consumer_secret,  # type: "models.SecretBase"
        quickbooks_access_token,  # type: "models.SecretBase"
        quickbooks_access_token_secret,  # type: "models.SecretBase"
        if_match=None,  # type: Optional[str]
        quickbooks_connect_via=None,  # type: Optional["models.IntegrationRuntimeReference"]
        quickbooks_description=None,  # type: Optional[str]
        quickbooks_parameters=None,  # type: Optional[Dict[str, "ParameterSpecification"]]
        quickbooks_annotations=None,  # type: Optional[List[object]]
        quickbooks_use_encrypted_endpoints=None,  # type: Optional[object]
        quickbooks_encrypted_credential=None,  # type: Optional[object]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.LinkedServiceResource"
        """Creates or updates a linked service.

        :param resource_group_name: The resource group name.
        :type resource_group_name: str
        :param factory_name: The factory name.
        :type factory_name: str
        :param linked_service_name: The linked service name.
        :type linked_service_name: str
        :param quickbooks_type: Type of linked service.
        :type quickbooks_type: str
        :param quickbooks_endpoint: The endpoint of the QuickBooks server. (i.e.
         quickbooks.api.intuit.com).
        :type quickbooks_endpoint: object
        :param quickbooks_company_id: The company ID of the QuickBooks company to authorize.
        :type quickbooks_company_id: object
        :param quickbooks_consumer_key: The consumer key for OAuth 1.0 authentication.
        :type quickbooks_consumer_key: object
        :param quickbooks_consumer_secret: The consumer secret for OAuth 1.0 authentication.
        :type quickbooks_consumer_secret: ~azure.mgmt.datafactory.models.SecretBase
        :param quickbooks_access_token: The access token for OAuth 1.0 authentication.
        :type quickbooks_access_token: ~azure.mgmt.datafactory.models.SecretBase
        :param quickbooks_access_token_secret: The access token secret for OAuth 1.0 authentication.
        :type quickbooks_access_token_secret: ~azure.mgmt.datafactory.models.SecretBase
        :param if_match: ETag of the linkedService entity.  Should only be specified for update, for
         which it should match existing entity or can be * for unconditional update.
        :type if_match: str
        :param quickbooks_connect_via: The integration runtime reference.
        :type quickbooks_connect_via: ~azure.mgmt.datafactory.models.IntegrationRuntimeReference
        :param quickbooks_description: Linked service description.
        :type quickbooks_description: str
        :param quickbooks_parameters: Parameters for linked service.
        :type quickbooks_parameters: dict[str, ~azure.mgmt.datafactory.models.ParameterSpecification]
        :param quickbooks_annotations: List of tags that can be used for describing the linked service.
        :type quickbooks_annotations: list[object]
        :param quickbooks_use_encrypted_endpoints: Specifies whether the data source endpoints are
         encrypted using HTTPS. The default value is true.
        :type quickbooks_use_encrypted_endpoints: object
        :param quickbooks_encrypted_credential: The encrypted credential used for authentication.
         Credentials are encrypted using the integration runtime credential manager. Type: string (or
         Expression with resultType string).
        :type quickbooks_encrypted_credential: object
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: LinkedServiceResource or the result of cls(response)
        :rtype: ~azure.mgmt.datafactory.models.LinkedServiceResource
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.LinkedServiceResource"]
        error_map = kwargs.pop('error_map', {404: ResourceNotFoundError, 409: ResourceExistsError})

        _linked_service = models.LinkedServiceResource(properties=properties, type=quickbooks_type, connect_via=quickbooks_connect_via, description=quickbooks_description, parameters=quickbooks_parameters, annotations=quickbooks_annotations, endpoint=quickbooks_endpoint, company_id=quickbooks_company_id, consumer_key=quickbooks_consumer_key, consumer_secret=quickbooks_consumer_secret, access_token=quickbooks_access_token, access_token_secret=quickbooks_access_token_secret, use_encrypted_endpoints=quickbooks_use_encrypted_endpoints, encrypted_credential=quickbooks_encrypted_credential)
        api_version = "2018-06-01"
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.create_or_update_quickbooks.metadata['url']
        path_format_arguments = {
            'subscriptionId': self._serialize.url("self._config.subscription_id", self._config.subscription_id, 'str'),
            'resourceGroupName': self._serialize.url("resource_group_name", resource_group_name, 'str', max_length=90, min_length=1, pattern=r'^[-\w\._\(\)]+$'),
            'factoryName': self._serialize.url("factory_name", factory_name, 'str', max_length=63, min_length=3, pattern=r'^[A-Za-z0-9]+(?:-[A-Za-z0-9]+)*$'),
            'linkedServiceName': self._serialize.url("linked_service_name", linked_service_name, 'str', max_length=260, min_length=1, pattern=r'^[A-Za-z0-9_][^<>*#.%&:\\+?/]*$'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = 'application/json'

        # Construct and send request
        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_linked_service, 'LinkedServiceResource')
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = self._deserialize('LinkedServiceResource', pipeline_response)

        if cls:
          return cls(pipeline_response, deserialized, {})

        return deserialized
    create_or_update_quickbooks.metadata = {'url': '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataFactory/factories/{factoryName}/linkedservices/{linkedServiceName}'}

    def create_or_update_responsys(
        self,
        resource_group_name,  # type: str
        factory_name,  # type: str
        linked_service_name,  # type: str
        responsys_type,  # type: str
        responsys_endpoint,  # type: object
        responsys_client_id,  # type: object
        if_match=None,  # type: Optional[str]
        responsys_connect_via=None,  # type: Optional["models.IntegrationRuntimeReference"]
        responsys_description=None,  # type: Optional[str]
        responsys_parameters=None,  # type: Optional[Dict[str, "ParameterSpecification"]]
        responsys_annotations=None,  # type: Optional[List[object]]
        responsys_client_secret=None,  # type: Optional["models.SecretBase"]
        responsys_use_encrypted_endpoints=None,  # type: Optional[object]
        responsys_use_host_verification=None,  # type: Optional[object]
        responsys_use_peer_verification=None,  # type: Optional[object]
        responsys_encrypted_credential=None,  # type: Optional[object]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.LinkedServiceResource"
        """Creates or updates a linked service.

        :param resource_group_name: The resource group name.
        :type resource_group_name: str
        :param factory_name: The factory name.
        :type factory_name: str
        :param linked_service_name: The linked service name.
        :type linked_service_name: str
        :param responsys_type: Type of linked service.
        :type responsys_type: str
        :param responsys_endpoint: The endpoint of the Responsys server.
        :type responsys_endpoint: object
        :param responsys_client_id: The client ID associated with the Responsys application. Type:
         string (or Expression with resultType string).
        :type responsys_client_id: object
        :param if_match: ETag of the linkedService entity.  Should only be specified for update, for
         which it should match existing entity or can be * for unconditional update.
        :type if_match: str
        :param responsys_connect_via: The integration runtime reference.
        :type responsys_connect_via: ~azure.mgmt.datafactory.models.IntegrationRuntimeReference
        :param responsys_description: Linked service description.
        :type responsys_description: str
        :param responsys_parameters: Parameters for linked service.
        :type responsys_parameters: dict[str, ~azure.mgmt.datafactory.models.ParameterSpecification]
        :param responsys_annotations: List of tags that can be used for describing the linked service.
        :type responsys_annotations: list[object]
        :param responsys_client_secret: The client secret associated with the Responsys application.
         Type: string (or Expression with resultType string).
        :type responsys_client_secret: ~azure.mgmt.datafactory.models.SecretBase
        :param responsys_use_encrypted_endpoints: Specifies whether the data source endpoints are
         encrypted using HTTPS. The default value is true. Type: boolean (or Expression with resultType
         boolean).
        :type responsys_use_encrypted_endpoints: object
        :param responsys_use_host_verification: Specifies whether to require the host name in the
         server's certificate to match the host name of the server when connecting over SSL. The default
         value is true. Type: boolean (or Expression with resultType boolean).
        :type responsys_use_host_verification: object
        :param responsys_use_peer_verification: Specifies whether to verify the identity of the server
         when connecting over SSL. The default value is true. Type: boolean (or Expression with
         resultType boolean).
        :type responsys_use_peer_verification: object
        :param responsys_encrypted_credential: The encrypted credential used for authentication.
         Credentials are encrypted using the integration runtime credential manager. Type: string (or
         Expression with resultType string).
        :type responsys_encrypted_credential: object
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: LinkedServiceResource or the result of cls(response)
        :rtype: ~azure.mgmt.datafactory.models.LinkedServiceResource
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.LinkedServiceResource"]
        error_map = kwargs.pop('error_map', {404: ResourceNotFoundError, 409: ResourceExistsError})

        _linked_service = models.LinkedServiceResource(properties=properties, type=responsys_type, connect_via=responsys_connect_via, description=responsys_description, parameters=responsys_parameters, annotations=responsys_annotations, endpoint=responsys_endpoint, client_id=responsys_client_id, client_secret=responsys_client_secret, use_encrypted_endpoints=responsys_use_encrypted_endpoints, use_host_verification=responsys_use_host_verification, use_peer_verification=responsys_use_peer_verification, encrypted_credential=responsys_encrypted_credential)
        api_version = "2018-06-01"
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.create_or_update_responsys.metadata['url']
        path_format_arguments = {
            'subscriptionId': self._serialize.url("self._config.subscription_id", self._config.subscription_id, 'str'),
            'resourceGroupName': self._serialize.url("resource_group_name", resource_group_name, 'str', max_length=90, min_length=1, pattern=r'^[-\w\._\(\)]+$'),
            'factoryName': self._serialize.url("factory_name", factory_name, 'str', max_length=63, min_length=3, pattern=r'^[A-Za-z0-9]+(?:-[A-Za-z0-9]+)*$'),
            'linkedServiceName': self._serialize.url("linked_service_name", linked_service_name, 'str', max_length=260, min_length=1, pattern=r'^[A-Za-z0-9_][^<>*#.%&:\\+?/]*$'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = 'application/json'

        # Construct and send request
        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_linked_service, 'LinkedServiceResource')
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = self._deserialize('LinkedServiceResource', pipeline_response)

        if cls:
          return cls(pipeline_response, deserialized, {})

        return deserialized
    create_or_update_responsys.metadata = {'url': '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataFactory/factories/{factoryName}/linkedservices/{linkedServiceName}'}

    def create_or_update_restservice(
        self,
        resource_group_name,  # type: str
        factory_name,  # type: str
        linked_service_name,  # type: str
        restservice_type,  # type: str
        restservice_url,  # type: object
        restservice_authentication_type,  # type: Union[str, "models.RestServiceAuthenticationType"]
        if_match=None,  # type: Optional[str]
        restservice_connect_via=None,  # type: Optional["models.IntegrationRuntimeReference"]
        restservice_description=None,  # type: Optional[str]
        restservice_parameters=None,  # type: Optional[Dict[str, "ParameterSpecification"]]
        restservice_annotations=None,  # type: Optional[List[object]]
        restservice_enable_server_certificate_validation=None,  # type: Optional[object]
        restservice_user_name=None,  # type: Optional[object]
        restservice_password=None,  # type: Optional["models.SecretBase"]
        restservice_service_principal_id=None,  # type: Optional[object]
        restservice_service_principal_key=None,  # type: Optional["models.SecretBase"]
        restservice_tenant=None,  # type: Optional[object]
        restservice_aad_resource_id=None,  # type: Optional[object]
        restservice_encrypted_credential=None,  # type: Optional[object]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.LinkedServiceResource"
        """Creates or updates a linked service.

        :param resource_group_name: The resource group name.
        :type resource_group_name: str
        :param factory_name: The factory name.
        :type factory_name: str
        :param linked_service_name: The linked service name.
        :type linked_service_name: str
        :param restservice_type: Type of linked service.
        :type restservice_type: str
        :param restservice_url: The base URL of the REST service.
        :type restservice_url: object
        :param restservice_authentication_type: Type of authentication used to connect to the REST
         service.
        :type restservice_authentication_type: str or ~azure.mgmt.datafactory.models.RestServiceAuthenticationType
        :param if_match: ETag of the linkedService entity.  Should only be specified for update, for
         which it should match existing entity or can be * for unconditional update.
        :type if_match: str
        :param restservice_connect_via: The integration runtime reference.
        :type restservice_connect_via: ~azure.mgmt.datafactory.models.IntegrationRuntimeReference
        :param restservice_description: Linked service description.
        :type restservice_description: str
        :param restservice_parameters: Parameters for linked service.
        :type restservice_parameters: dict[str, ~azure.mgmt.datafactory.models.ParameterSpecification]
        :param restservice_annotations: List of tags that can be used for describing the linked
         service.
        :type restservice_annotations: list[object]
        :param restservice_enable_server_certificate_validation: Whether to validate server side SSL
         certificate when connecting to the endpoint.The default value is true. Type: boolean (or
         Expression with resultType boolean).
        :type restservice_enable_server_certificate_validation: object
        :param restservice_user_name: The user name used in Basic authentication type.
        :type restservice_user_name: object
        :param restservice_password: The password used in Basic authentication type.
        :type restservice_password: ~azure.mgmt.datafactory.models.SecretBase
        :param restservice_service_principal_id: The application's client ID used in
         AadServicePrincipal authentication type.
        :type restservice_service_principal_id: object
        :param restservice_service_principal_key: The application's key used in AadServicePrincipal
         authentication type.
        :type restservice_service_principal_key: ~azure.mgmt.datafactory.models.SecretBase
        :param restservice_tenant: The tenant information (domain name or tenant ID) used in
         AadServicePrincipal authentication type under which your application resides.
        :type restservice_tenant: object
        :param restservice_aad_resource_id: The resource you are requesting authorization to use.
        :type restservice_aad_resource_id: object
        :param restservice_encrypted_credential: The encrypted credential used for authentication.
         Credentials are encrypted using the integration runtime credential manager. Type: string (or
         Expression with resultType string).
        :type restservice_encrypted_credential: object
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: LinkedServiceResource or the result of cls(response)
        :rtype: ~azure.mgmt.datafactory.models.LinkedServiceResource
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.LinkedServiceResource"]
        error_map = kwargs.pop('error_map', {404: ResourceNotFoundError, 409: ResourceExistsError})

        _linked_service = models.LinkedServiceResource(properties=properties, type=restservice_type, connect_via=restservice_connect_via, description=restservice_description, parameters=restservice_parameters, annotations=restservice_annotations, url=restservice_url, enable_server_certificate_validation=restservice_enable_server_certificate_validation, authentication_type=restservice_authentication_type, user_name=restservice_user_name, password=restservice_password, service_principal_id=restservice_service_principal_id, service_principal_key=restservice_service_principal_key, tenant=restservice_tenant, aad_resource_id=restservice_aad_resource_id, encrypted_credential=restservice_encrypted_credential)
        api_version = "2018-06-01"
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.create_or_update_restservice.metadata['url']
        path_format_arguments = {
            'subscriptionId': self._serialize.url("self._config.subscription_id", self._config.subscription_id, 'str'),
            'resourceGroupName': self._serialize.url("resource_group_name", resource_group_name, 'str', max_length=90, min_length=1, pattern=r'^[-\w\._\(\)]+$'),
            'factoryName': self._serialize.url("factory_name", factory_name, 'str', max_length=63, min_length=3, pattern=r'^[A-Za-z0-9]+(?:-[A-Za-z0-9]+)*$'),
            'linkedServiceName': self._serialize.url("linked_service_name", linked_service_name, 'str', max_length=260, min_length=1, pattern=r'^[A-Za-z0-9_][^<>*#.%&:\\+?/]*$'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = 'application/json'

        # Construct and send request
        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_linked_service, 'LinkedServiceResource')
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = self._deserialize('LinkedServiceResource', pipeline_response)

        if cls:
          return cls(pipeline_response, deserialized, {})

        return deserialized
    create_or_update_restservice.metadata = {'url': '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataFactory/factories/{factoryName}/linkedservices/{linkedServiceName}'}

    def create_or_update_salesforce(
        self,
        resource_group_name,  # type: str
        factory_name,  # type: str
        linked_service_name,  # type: str
        salesforce_type,  # type: str
        if_match=None,  # type: Optional[str]
        salesforce_connect_via=None,  # type: Optional["models.IntegrationRuntimeReference"]
        salesforce_description=None,  # type: Optional[str]
        salesforce_parameters=None,  # type: Optional[Dict[str, "ParameterSpecification"]]
        salesforce_annotations=None,  # type: Optional[List[object]]
        salesforce_environment_url=None,  # type: Optional[object]
        salesforce_username=None,  # type: Optional[object]
        salesforce_password=None,  # type: Optional["models.SecretBase"]
        salesforce_security_token=None,  # type: Optional["models.SecretBase"]
        salesforce_api_version=None,  # type: Optional[object]
        salesforce_encrypted_credential=None,  # type: Optional[object]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.LinkedServiceResource"
        """Creates or updates a linked service.

        :param resource_group_name: The resource group name.
        :type resource_group_name: str
        :param factory_name: The factory name.
        :type factory_name: str
        :param linked_service_name: The linked service name.
        :type linked_service_name: str
        :param salesforce_type: Type of linked service.
        :type salesforce_type: str
        :param if_match: ETag of the linkedService entity.  Should only be specified for update, for
         which it should match existing entity or can be * for unconditional update.
        :type if_match: str
        :param salesforce_connect_via: The integration runtime reference.
        :type salesforce_connect_via: ~azure.mgmt.datafactory.models.IntegrationRuntimeReference
        :param salesforce_description: Linked service description.
        :type salesforce_description: str
        :param salesforce_parameters: Parameters for linked service.
        :type salesforce_parameters: dict[str, ~azure.mgmt.datafactory.models.ParameterSpecification]
        :param salesforce_annotations: List of tags that can be used for describing the linked service.
        :type salesforce_annotations: list[object]
        :param salesforce_environment_url: The URL of Salesforce instance. Default is
         'https://login.salesforce.com'. To copy data from sandbox, specify
         'https://test.salesforce.com'. To copy data from custom domain, specify, for example,
         'https://[domain].my.salesforce.com'. Type: string (or Expression with resultType string).
        :type salesforce_environment_url: object
        :param salesforce_username: The username for Basic authentication of the Salesforce instance.
         Type: string (or Expression with resultType string).
        :type salesforce_username: object
        :param salesforce_password: The password for Basic authentication of the Salesforce instance.
        :type salesforce_password: ~azure.mgmt.datafactory.models.SecretBase
        :param salesforce_security_token: The security token is optional to remotely access Salesforce
         instance.
        :type salesforce_security_token: ~azure.mgmt.datafactory.models.SecretBase
        :param salesforce_api_version: The Salesforce API version used in ADF. Type: string (or
         Expression with resultType string).
        :type salesforce_api_version: object
        :param salesforce_encrypted_credential: The encrypted credential used for authentication.
         Credentials are encrypted using the integration runtime credential manager. Type: string (or
         Expression with resultType string).
        :type salesforce_encrypted_credential: object
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: LinkedServiceResource or the result of cls(response)
        :rtype: ~azure.mgmt.datafactory.models.LinkedServiceResource
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.LinkedServiceResource"]
        error_map = kwargs.pop('error_map', {404: ResourceNotFoundError, 409: ResourceExistsError})

        _linked_service = models.LinkedServiceResource(properties=properties, type=salesforce_type, connect_via=salesforce_connect_via, description=salesforce_description, parameters=salesforce_parameters, annotations=salesforce_annotations, environment_url=salesforce_environment_url, username=salesforce_username, password=salesforce_password, security_token=salesforce_security_token, api_version=salesforce_api_version, encrypted_credential=salesforce_encrypted_credential)
        api_version = "2018-06-01"
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.create_or_update_salesforce.metadata['url']
        path_format_arguments = {
            'subscriptionId': self._serialize.url("self._config.subscription_id", self._config.subscription_id, 'str'),
            'resourceGroupName': self._serialize.url("resource_group_name", resource_group_name, 'str', max_length=90, min_length=1, pattern=r'^[-\w\._\(\)]+$'),
            'factoryName': self._serialize.url("factory_name", factory_name, 'str', max_length=63, min_length=3, pattern=r'^[A-Za-z0-9]+(?:-[A-Za-z0-9]+)*$'),
            'linkedServiceName': self._serialize.url("linked_service_name", linked_service_name, 'str', max_length=260, min_length=1, pattern=r'^[A-Za-z0-9_][^<>*#.%&:\\+?/]*$'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = 'application/json'

        # Construct and send request
        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_linked_service, 'LinkedServiceResource')
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = self._deserialize('LinkedServiceResource', pipeline_response)

        if cls:
          return cls(pipeline_response, deserialized, {})

        return deserialized
    create_or_update_salesforce.metadata = {'url': '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataFactory/factories/{factoryName}/linkedservices/{linkedServiceName}'}

    def create_or_update_salesforcemarketingcloud(
        self,
        resource_group_name,  # type: str
        factory_name,  # type: str
        linked_service_name,  # type: str
        salesforcemarketingcloud_type,  # type: str
        salesforcemarketingcloud_client_id,  # type: object
        if_match=None,  # type: Optional[str]
        salesforcemarketingcloud_connect_via=None,  # type: Optional["models.IntegrationRuntimeReference"]
        salesforcemarketingcloud_description=None,  # type: Optional[str]
        salesforcemarketingcloud_parameters=None,  # type: Optional[Dict[str, "ParameterSpecification"]]
        salesforcemarketingcloud_annotations=None,  # type: Optional[List[object]]
        salesforcemarketingcloud_client_secret=None,  # type: Optional["models.SecretBase"]
        salesforcemarketingcloud_use_encrypted_endpoints=None,  # type: Optional[object]
        salesforcemarketingcloud_use_host_verification=None,  # type: Optional[object]
        salesforcemarketingcloud_use_peer_verification=None,  # type: Optional[object]
        salesforcemarketingcloud_encrypted_credential=None,  # type: Optional[object]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.LinkedServiceResource"
        """Creates or updates a linked service.

        :param resource_group_name: The resource group name.
        :type resource_group_name: str
        :param factory_name: The factory name.
        :type factory_name: str
        :param linked_service_name: The linked service name.
        :type linked_service_name: str
        :param salesforcemarketingcloud_type: Type of linked service.
        :type salesforcemarketingcloud_type: str
        :param salesforcemarketingcloud_client_id: The client ID associated with the Salesforce
         Marketing Cloud application. Type: string (or Expression with resultType string).
        :type salesforcemarketingcloud_client_id: object
        :param if_match: ETag of the linkedService entity.  Should only be specified for update, for
         which it should match existing entity or can be * for unconditional update.
        :type if_match: str
        :param salesforcemarketingcloud_connect_via: The integration runtime reference.
        :type salesforcemarketingcloud_connect_via: ~azure.mgmt.datafactory.models.IntegrationRuntimeReference
        :param salesforcemarketingcloud_description: Linked service description.
        :type salesforcemarketingcloud_description: str
        :param salesforcemarketingcloud_parameters: Parameters for linked service.
        :type salesforcemarketingcloud_parameters: dict[str, ~azure.mgmt.datafactory.models.ParameterSpecification]
        :param salesforcemarketingcloud_annotations: List of tags that can be used for describing the
         linked service.
        :type salesforcemarketingcloud_annotations: list[object]
        :param salesforcemarketingcloud_client_secret: The client secret associated with the Salesforce
         Marketing Cloud application. Type: string (or Expression with resultType string).
        :type salesforcemarketingcloud_client_secret: ~azure.mgmt.datafactory.models.SecretBase
        :param salesforcemarketingcloud_use_encrypted_endpoints: Specifies whether the data source
         endpoints are encrypted using HTTPS. The default value is true. Type: boolean (or Expression
         with resultType boolean).
        :type salesforcemarketingcloud_use_encrypted_endpoints: object
        :param salesforcemarketingcloud_use_host_verification: Specifies whether to require the host
         name in the server's certificate to match the host name of the server when connecting over SSL.
         The default value is true. Type: boolean (or Expression with resultType boolean).
        :type salesforcemarketingcloud_use_host_verification: object
        :param salesforcemarketingcloud_use_peer_verification: Specifies whether to verify the identity
         of the server when connecting over SSL. The default value is true. Type: boolean (or Expression
         with resultType boolean).
        :type salesforcemarketingcloud_use_peer_verification: object
        :param salesforcemarketingcloud_encrypted_credential: The encrypted credential used for
         authentication. Credentials are encrypted using the integration runtime credential manager.
         Type: string (or Expression with resultType string).
        :type salesforcemarketingcloud_encrypted_credential: object
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: LinkedServiceResource or the result of cls(response)
        :rtype: ~azure.mgmt.datafactory.models.LinkedServiceResource
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.LinkedServiceResource"]
        error_map = kwargs.pop('error_map', {404: ResourceNotFoundError, 409: ResourceExistsError})

        _linked_service = models.LinkedServiceResource(properties=properties, type=salesforcemarketingcloud_type, connect_via=salesforcemarketingcloud_connect_via, description=salesforcemarketingcloud_description, parameters=salesforcemarketingcloud_parameters, annotations=salesforcemarketingcloud_annotations, client_id=salesforcemarketingcloud_client_id, client_secret=salesforcemarketingcloud_client_secret, use_encrypted_endpoints=salesforcemarketingcloud_use_encrypted_endpoints, use_host_verification=salesforcemarketingcloud_use_host_verification, use_peer_verification=salesforcemarketingcloud_use_peer_verification, encrypted_credential=salesforcemarketingcloud_encrypted_credential)
        api_version = "2018-06-01"
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.create_or_update_salesforcemarketingcloud.metadata['url']
        path_format_arguments = {
            'subscriptionId': self._serialize.url("self._config.subscription_id", self._config.subscription_id, 'str'),
            'resourceGroupName': self._serialize.url("resource_group_name", resource_group_name, 'str', max_length=90, min_length=1, pattern=r'^[-\w\._\(\)]+$'),
            'factoryName': self._serialize.url("factory_name", factory_name, 'str', max_length=63, min_length=3, pattern=r'^[A-Za-z0-9]+(?:-[A-Za-z0-9]+)*$'),
            'linkedServiceName': self._serialize.url("linked_service_name", linked_service_name, 'str', max_length=260, min_length=1, pattern=r'^[A-Za-z0-9_][^<>*#.%&:\\+?/]*$'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = 'application/json'

        # Construct and send request
        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_linked_service, 'LinkedServiceResource')
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = self._deserialize('LinkedServiceResource', pipeline_response)

        if cls:
          return cls(pipeline_response, deserialized, {})

        return deserialized
    create_or_update_salesforcemarketingcloud.metadata = {'url': '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataFactory/factories/{factoryName}/linkedservices/{linkedServiceName}'}

    def create_or_update_salesforceservicecloud(
        self,
        resource_group_name,  # type: str
        factory_name,  # type: str
        linked_service_name,  # type: str
        salesforceservicecloud_type,  # type: str
        if_match=None,  # type: Optional[str]
        salesforceservicecloud_connect_via=None,  # type: Optional["models.IntegrationRuntimeReference"]
        salesforceservicecloud_description=None,  # type: Optional[str]
        salesforceservicecloud_parameters=None,  # type: Optional[Dict[str, "ParameterSpecification"]]
        salesforceservicecloud_annotations=None,  # type: Optional[List[object]]
        salesforceservicecloud_environment_url=None,  # type: Optional[object]
        salesforceservicecloud_username=None,  # type: Optional[object]
        salesforceservicecloud_password=None,  # type: Optional["models.SecretBase"]
        salesforceservicecloud_security_token=None,  # type: Optional["models.SecretBase"]
        salesforceservicecloud_api_version=None,  # type: Optional[object]
        salesforceservicecloud_extended_properties=None,  # type: Optional[object]
        salesforceservicecloud_encrypted_credential=None,  # type: Optional[object]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.LinkedServiceResource"
        """Creates or updates a linked service.

        :param resource_group_name: The resource group name.
        :type resource_group_name: str
        :param factory_name: The factory name.
        :type factory_name: str
        :param linked_service_name: The linked service name.
        :type linked_service_name: str
        :param salesforceservicecloud_type: Type of linked service.
        :type salesforceservicecloud_type: str
        :param if_match: ETag of the linkedService entity.  Should only be specified for update, for
         which it should match existing entity or can be * for unconditional update.
        :type if_match: str
        :param salesforceservicecloud_connect_via: The integration runtime reference.
        :type salesforceservicecloud_connect_via: ~azure.mgmt.datafactory.models.IntegrationRuntimeReference
        :param salesforceservicecloud_description: Linked service description.
        :type salesforceservicecloud_description: str
        :param salesforceservicecloud_parameters: Parameters for linked service.
        :type salesforceservicecloud_parameters: dict[str, ~azure.mgmt.datafactory.models.ParameterSpecification]
        :param salesforceservicecloud_annotations: List of tags that can be used for describing the
         linked service.
        :type salesforceservicecloud_annotations: list[object]
        :param salesforceservicecloud_environment_url: The URL of Salesforce Service Cloud instance.
         Default is 'https://login.salesforce.com'. To copy data from sandbox, specify
         'https://test.salesforce.com'. To copy data from custom domain, specify, for example,
         'https://[domain].my.salesforce.com'. Type: string (or Expression with resultType string).
        :type salesforceservicecloud_environment_url: object
        :param salesforceservicecloud_username: The username for Basic authentication of the Salesforce
         instance. Type: string (or Expression with resultType string).
        :type salesforceservicecloud_username: object
        :param salesforceservicecloud_password: The password for Basic authentication of the Salesforce
         instance.
        :type salesforceservicecloud_password: ~azure.mgmt.datafactory.models.SecretBase
        :param salesforceservicecloud_security_token: The security token is optional to remotely access
         Salesforce instance.
        :type salesforceservicecloud_security_token: ~azure.mgmt.datafactory.models.SecretBase
        :param salesforceservicecloud_api_version: The Salesforce API version used in ADF. Type: string
         (or Expression with resultType string).
        :type salesforceservicecloud_api_version: object
        :param salesforceservicecloud_extended_properties: Extended properties appended to the
         connection string. Type: string (or Expression with resultType string).
        :type salesforceservicecloud_extended_properties: object
        :param salesforceservicecloud_encrypted_credential: The encrypted credential used for
         authentication. Credentials are encrypted using the integration runtime credential manager.
         Type: string (or Expression with resultType string).
        :type salesforceservicecloud_encrypted_credential: object
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: LinkedServiceResource or the result of cls(response)
        :rtype: ~azure.mgmt.datafactory.models.LinkedServiceResource
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.LinkedServiceResource"]
        error_map = kwargs.pop('error_map', {404: ResourceNotFoundError, 409: ResourceExistsError})

        _linked_service = models.LinkedServiceResource(properties=properties, type=salesforceservicecloud_type, connect_via=salesforceservicecloud_connect_via, description=salesforceservicecloud_description, parameters=salesforceservicecloud_parameters, annotations=salesforceservicecloud_annotations, environment_url=salesforceservicecloud_environment_url, username=salesforceservicecloud_username, password=salesforceservicecloud_password, security_token=salesforceservicecloud_security_token, api_version=salesforceservicecloud_api_version, extended_properties=salesforceservicecloud_extended_properties, encrypted_credential=salesforceservicecloud_encrypted_credential)
        api_version = "2018-06-01"
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.create_or_update_salesforceservicecloud.metadata['url']
        path_format_arguments = {
            'subscriptionId': self._serialize.url("self._config.subscription_id", self._config.subscription_id, 'str'),
            'resourceGroupName': self._serialize.url("resource_group_name", resource_group_name, 'str', max_length=90, min_length=1, pattern=r'^[-\w\._\(\)]+$'),
            'factoryName': self._serialize.url("factory_name", factory_name, 'str', max_length=63, min_length=3, pattern=r'^[A-Za-z0-9]+(?:-[A-Za-z0-9]+)*$'),
            'linkedServiceName': self._serialize.url("linked_service_name", linked_service_name, 'str', max_length=260, min_length=1, pattern=r'^[A-Za-z0-9_][^<>*#.%&:\\+?/]*$'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = 'application/json'

        # Construct and send request
        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_linked_service, 'LinkedServiceResource')
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = self._deserialize('LinkedServiceResource', pipeline_response)

        if cls:
          return cls(pipeline_response, deserialized, {})

        return deserialized
    create_or_update_salesforceservicecloud.metadata = {'url': '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataFactory/factories/{factoryName}/linkedservices/{linkedServiceName}'}

    def create_or_update_sapbw(
        self,
        resource_group_name,  # type: str
        factory_name,  # type: str
        linked_service_name,  # type: str
        sapbw_type,  # type: str
        sapbw_server,  # type: object
        sapbw_system_number,  # type: object
        sapbw_client_id,  # type: object
        if_match=None,  # type: Optional[str]
        sapbw_connect_via=None,  # type: Optional["models.IntegrationRuntimeReference"]
        sapbw_description=None,  # type: Optional[str]
        sapbw_parameters=None,  # type: Optional[Dict[str, "ParameterSpecification"]]
        sapbw_annotations=None,  # type: Optional[List[object]]
        sapbw_user_name=None,  # type: Optional[object]
        sapbw_password=None,  # type: Optional["models.SecretBase"]
        sapbw_encrypted_credential=None,  # type: Optional[object]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.LinkedServiceResource"
        """Creates or updates a linked service.

        :param resource_group_name: The resource group name.
        :type resource_group_name: str
        :param factory_name: The factory name.
        :type factory_name: str
        :param linked_service_name: The linked service name.
        :type linked_service_name: str
        :param sapbw_type: Type of linked service.
        :type sapbw_type: str
        :param sapbw_server: Host name of the SAP BW instance. Type: string (or Expression with
         resultType string).
        :type sapbw_server: object
        :param sapbw_system_number: System number of the BW system. (Usually a two-digit decimal number
         represented as a string.) Type: string (or Expression with resultType string).
        :type sapbw_system_number: object
        :param sapbw_client_id: Client ID of the client on the BW system. (Usually a three-digit
         decimal number represented as a string) Type: string (or Expression with resultType string).
        :type sapbw_client_id: object
        :param if_match: ETag of the linkedService entity.  Should only be specified for update, for
         which it should match existing entity or can be * for unconditional update.
        :type if_match: str
        :param sapbw_connect_via: The integration runtime reference.
        :type sapbw_connect_via: ~azure.mgmt.datafactory.models.IntegrationRuntimeReference
        :param sapbw_description: Linked service description.
        :type sapbw_description: str
        :param sapbw_parameters: Parameters for linked service.
        :type sapbw_parameters: dict[str, ~azure.mgmt.datafactory.models.ParameterSpecification]
        :param sapbw_annotations: List of tags that can be used for describing the linked service.
        :type sapbw_annotations: list[object]
        :param sapbw_user_name: Username to access the SAP BW server. Type: string (or Expression with
         resultType string).
        :type sapbw_user_name: object
        :param sapbw_password: Password to access the SAP BW server.
        :type sapbw_password: ~azure.mgmt.datafactory.models.SecretBase
        :param sapbw_encrypted_credential: The encrypted credential used for authentication.
         Credentials are encrypted using the integration runtime credential manager. Type: string (or
         Expression with resultType string).
        :type sapbw_encrypted_credential: object
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: LinkedServiceResource or the result of cls(response)
        :rtype: ~azure.mgmt.datafactory.models.LinkedServiceResource
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.LinkedServiceResource"]
        error_map = kwargs.pop('error_map', {404: ResourceNotFoundError, 409: ResourceExistsError})

        _linked_service = models.LinkedServiceResource(properties=properties, type=sapbw_type, connect_via=sapbw_connect_via, description=sapbw_description, parameters=sapbw_parameters, annotations=sapbw_annotations, server=sapbw_server, system_number=sapbw_system_number, client_id=sapbw_client_id, user_name=sapbw_user_name, password=sapbw_password, encrypted_credential=sapbw_encrypted_credential)
        api_version = "2018-06-01"
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.create_or_update_sapbw.metadata['url']
        path_format_arguments = {
            'subscriptionId': self._serialize.url("self._config.subscription_id", self._config.subscription_id, 'str'),
            'resourceGroupName': self._serialize.url("resource_group_name", resource_group_name, 'str', max_length=90, min_length=1, pattern=r'^[-\w\._\(\)]+$'),
            'factoryName': self._serialize.url("factory_name", factory_name, 'str', max_length=63, min_length=3, pattern=r'^[A-Za-z0-9]+(?:-[A-Za-z0-9]+)*$'),
            'linkedServiceName': self._serialize.url("linked_service_name", linked_service_name, 'str', max_length=260, min_length=1, pattern=r'^[A-Za-z0-9_][^<>*#.%&:\\+?/]*$'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = 'application/json'

        # Construct and send request
        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_linked_service, 'LinkedServiceResource')
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = self._deserialize('LinkedServiceResource', pipeline_response)

        if cls:
          return cls(pipeline_response, deserialized, {})

        return deserialized
    create_or_update_sapbw.metadata = {'url': '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataFactory/factories/{factoryName}/linkedservices/{linkedServiceName}'}

    def create_or_update_sapcloudforcustomer(
        self,
        resource_group_name,  # type: str
        factory_name,  # type: str
        linked_service_name,  # type: str
        sapcloudforcustomer_type,  # type: str
        sapcloudforcustomer_url,  # type: object
        if_match=None,  # type: Optional[str]
        sapcloudforcustomer_connect_via=None,  # type: Optional["models.IntegrationRuntimeReference"]
        sapcloudforcustomer_description=None,  # type: Optional[str]
        sapcloudforcustomer_parameters=None,  # type: Optional[Dict[str, "ParameterSpecification"]]
        sapcloudforcustomer_annotations=None,  # type: Optional[List[object]]
        sapcloudforcustomer_username=None,  # type: Optional[object]
        sapcloudforcustomer_password=None,  # type: Optional["models.SecretBase"]
        sapcloudforcustomer_encrypted_credential=None,  # type: Optional[object]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.LinkedServiceResource"
        """Creates or updates a linked service.

        :param resource_group_name: The resource group name.
        :type resource_group_name: str
        :param factory_name: The factory name.
        :type factory_name: str
        :param linked_service_name: The linked service name.
        :type linked_service_name: str
        :param sapcloudforcustomer_type: Type of linked service.
        :type sapcloudforcustomer_type: str
        :param sapcloudforcustomer_url: The URL of SAP Cloud for Customer OData API. For example,
         '[https://[tenantname].crm.ondemand.com/sap/c4c/odata/v1]'. Type: string (or Expression with
         resultType string).
        :type sapcloudforcustomer_url: object
        :param if_match: ETag of the linkedService entity.  Should only be specified for update, for
         which it should match existing entity or can be * for unconditional update.
        :type if_match: str
        :param sapcloudforcustomer_connect_via: The integration runtime reference.
        :type sapcloudforcustomer_connect_via: ~azure.mgmt.datafactory.models.IntegrationRuntimeReference
        :param sapcloudforcustomer_description: Linked service description.
        :type sapcloudforcustomer_description: str
        :param sapcloudforcustomer_parameters: Parameters for linked service.
        :type sapcloudforcustomer_parameters: dict[str, ~azure.mgmt.datafactory.models.ParameterSpecification]
        :param sapcloudforcustomer_annotations: List of tags that can be used for describing the linked
         service.
        :type sapcloudforcustomer_annotations: list[object]
        :param sapcloudforcustomer_username: The username for Basic authentication. Type: string (or
         Expression with resultType string).
        :type sapcloudforcustomer_username: object
        :param sapcloudforcustomer_password: The password for Basic authentication.
        :type sapcloudforcustomer_password: ~azure.mgmt.datafactory.models.SecretBase
        :param sapcloudforcustomer_encrypted_credential: The encrypted credential used for
         authentication. Credentials are encrypted using the integration runtime credential manager.
         Either encryptedCredential or username/password must be provided. Type: string (or Expression
         with resultType string).
        :type sapcloudforcustomer_encrypted_credential: object
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: LinkedServiceResource or the result of cls(response)
        :rtype: ~azure.mgmt.datafactory.models.LinkedServiceResource
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.LinkedServiceResource"]
        error_map = kwargs.pop('error_map', {404: ResourceNotFoundError, 409: ResourceExistsError})

        _linked_service = models.LinkedServiceResource(properties=properties, type=sapcloudforcustomer_type, connect_via=sapcloudforcustomer_connect_via, description=sapcloudforcustomer_description, parameters=sapcloudforcustomer_parameters, annotations=sapcloudforcustomer_annotations, url=sapcloudforcustomer_url, username=sapcloudforcustomer_username, password=sapcloudforcustomer_password, encrypted_credential=sapcloudforcustomer_encrypted_credential)
        api_version = "2018-06-01"
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.create_or_update_sapcloudforcustomer.metadata['url']
        path_format_arguments = {
            'subscriptionId': self._serialize.url("self._config.subscription_id", self._config.subscription_id, 'str'),
            'resourceGroupName': self._serialize.url("resource_group_name", resource_group_name, 'str', max_length=90, min_length=1, pattern=r'^[-\w\._\(\)]+$'),
            'factoryName': self._serialize.url("factory_name", factory_name, 'str', max_length=63, min_length=3, pattern=r'^[A-Za-z0-9]+(?:-[A-Za-z0-9]+)*$'),
            'linkedServiceName': self._serialize.url("linked_service_name", linked_service_name, 'str', max_length=260, min_length=1, pattern=r'^[A-Za-z0-9_][^<>*#.%&:\\+?/]*$'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = 'application/json'

        # Construct and send request
        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_linked_service, 'LinkedServiceResource')
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = self._deserialize('LinkedServiceResource', pipeline_response)

        if cls:
          return cls(pipeline_response, deserialized, {})

        return deserialized
    create_or_update_sapcloudforcustomer.metadata = {'url': '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataFactory/factories/{factoryName}/linkedservices/{linkedServiceName}'}

    def create_or_update_sapecc(
        self,
        resource_group_name,  # type: str
        factory_name,  # type: str
        linked_service_name,  # type: str
        sapecc_type,  # type: str
        sapecc_url,  # type: str
        if_match=None,  # type: Optional[str]
        sapecc_connect_via=None,  # type: Optional["models.IntegrationRuntimeReference"]
        sapecc_description=None,  # type: Optional[str]
        sapecc_parameters=None,  # type: Optional[Dict[str, "ParameterSpecification"]]
        sapecc_annotations=None,  # type: Optional[List[object]]
        sapecc_username=None,  # type: Optional[str]
        sapecc_password=None,  # type: Optional["models.SecretBase"]
        sapecc_encrypted_credential=None,  # type: Optional[str]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.LinkedServiceResource"
        """Creates or updates a linked service.

        :param resource_group_name: The resource group name.
        :type resource_group_name: str
        :param factory_name: The factory name.
        :type factory_name: str
        :param linked_service_name: The linked service name.
        :type linked_service_name: str
        :param sapecc_type: Type of linked service.
        :type sapecc_type: str
        :param sapecc_url: The URL of SAP ECC OData API. For example,
         '[https://hostname:port/sap/opu/odata/sap/servicename/]'. Type: string (or Expression with
         resultType string).
        :type sapecc_url: str
        :param if_match: ETag of the linkedService entity.  Should only be specified for update, for
         which it should match existing entity or can be * for unconditional update.
        :type if_match: str
        :param sapecc_connect_via: The integration runtime reference.
        :type sapecc_connect_via: ~azure.mgmt.datafactory.models.IntegrationRuntimeReference
        :param sapecc_description: Linked service description.
        :type sapecc_description: str
        :param sapecc_parameters: Parameters for linked service.
        :type sapecc_parameters: dict[str, ~azure.mgmt.datafactory.models.ParameterSpecification]
        :param sapecc_annotations: List of tags that can be used for describing the linked service.
        :type sapecc_annotations: list[object]
        :param sapecc_username: The username for Basic authentication. Type: string (or Expression with
         resultType string).
        :type sapecc_username: str
        :param sapecc_password: The password for Basic authentication.
        :type sapecc_password: ~azure.mgmt.datafactory.models.SecretBase
        :param sapecc_encrypted_credential: The encrypted credential used for authentication.
         Credentials are encrypted using the integration runtime credential manager. Either
         encryptedCredential or username/password must be provided. Type: string (or Expression with
         resultType string).
        :type sapecc_encrypted_credential: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: LinkedServiceResource or the result of cls(response)
        :rtype: ~azure.mgmt.datafactory.models.LinkedServiceResource
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.LinkedServiceResource"]
        error_map = kwargs.pop('error_map', {404: ResourceNotFoundError, 409: ResourceExistsError})

        _linked_service = models.LinkedServiceResource(properties=properties, type=sapecc_type, connect_via=sapecc_connect_via, description=sapecc_description, parameters=sapecc_parameters, annotations=sapecc_annotations, url=sapecc_url, username=sapecc_username, password=sapecc_password, encrypted_credential=sapecc_encrypted_credential)
        api_version = "2018-06-01"
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.create_or_update_sapecc.metadata['url']
        path_format_arguments = {
            'subscriptionId': self._serialize.url("self._config.subscription_id", self._config.subscription_id, 'str'),
            'resourceGroupName': self._serialize.url("resource_group_name", resource_group_name, 'str', max_length=90, min_length=1, pattern=r'^[-\w\._\(\)]+$'),
            'factoryName': self._serialize.url("factory_name", factory_name, 'str', max_length=63, min_length=3, pattern=r'^[A-Za-z0-9]+(?:-[A-Za-z0-9]+)*$'),
            'linkedServiceName': self._serialize.url("linked_service_name", linked_service_name, 'str', max_length=260, min_length=1, pattern=r'^[A-Za-z0-9_][^<>*#.%&:\\+?/]*$'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = 'application/json'

        # Construct and send request
        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_linked_service, 'LinkedServiceResource')
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = self._deserialize('LinkedServiceResource', pipeline_response)

        if cls:
          return cls(pipeline_response, deserialized, {})

        return deserialized
    create_or_update_sapecc.metadata = {'url': '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataFactory/factories/{factoryName}/linkedservices/{linkedServiceName}'}

    def create_or_update_saphana(
        self,
        resource_group_name,  # type: str
        factory_name,  # type: str
        linked_service_name,  # type: str
        saphana_type,  # type: str
        if_match=None,  # type: Optional[str]
        saphana_connect_via=None,  # type: Optional["models.IntegrationRuntimeReference"]
        saphana_description=None,  # type: Optional[str]
        saphana_parameters=None,  # type: Optional[Dict[str, "ParameterSpecification"]]
        saphana_annotations=None,  # type: Optional[List[object]]
        saphana_connection_string=None,  # type: Optional[object]
        saphana_server=None,  # type: Optional[object]
        saphana_authentication_type=None,  # type: Optional[Union[str, "models.SapHanaAuthenticationType"]]
        saphana_user_name=None,  # type: Optional[object]
        saphana_password=None,  # type: Optional["models.SecretBase"]
        saphana_encrypted_credential=None,  # type: Optional[object]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.LinkedServiceResource"
        """Creates or updates a linked service.

        :param resource_group_name: The resource group name.
        :type resource_group_name: str
        :param factory_name: The factory name.
        :type factory_name: str
        :param linked_service_name: The linked service name.
        :type linked_service_name: str
        :param saphana_type: Type of linked service.
        :type saphana_type: str
        :param if_match: ETag of the linkedService entity.  Should only be specified for update, for
         which it should match existing entity or can be * for unconditional update.
        :type if_match: str
        :param saphana_connect_via: The integration runtime reference.
        :type saphana_connect_via: ~azure.mgmt.datafactory.models.IntegrationRuntimeReference
        :param saphana_description: Linked service description.
        :type saphana_description: str
        :param saphana_parameters: Parameters for linked service.
        :type saphana_parameters: dict[str, ~azure.mgmt.datafactory.models.ParameterSpecification]
        :param saphana_annotations: List of tags that can be used for describing the linked service.
        :type saphana_annotations: list[object]
        :param saphana_connection_string: SAP HANA ODBC connection string. Type: string, SecureString
         or AzureKeyVaultSecretReference.
        :type saphana_connection_string: object
        :param saphana_server: Host name of the SAP HANA server. Type: string (or Expression with
         resultType string).
        :type saphana_server: object
        :param saphana_authentication_type: The authentication type to be used to connect to the SAP
         HANA server.
        :type saphana_authentication_type: str or ~azure.mgmt.datafactory.models.SapHanaAuthenticationType
        :param saphana_user_name: Username to access the SAP HANA server. Type: string (or Expression
         with resultType string).
        :type saphana_user_name: object
        :param saphana_password: Password to access the SAP HANA server.
        :type saphana_password: ~azure.mgmt.datafactory.models.SecretBase
        :param saphana_encrypted_credential: The encrypted credential used for authentication.
         Credentials are encrypted using the integration runtime credential manager. Type: string (or
         Expression with resultType string).
        :type saphana_encrypted_credential: object
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: LinkedServiceResource or the result of cls(response)
        :rtype: ~azure.mgmt.datafactory.models.LinkedServiceResource
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.LinkedServiceResource"]
        error_map = kwargs.pop('error_map', {404: ResourceNotFoundError, 409: ResourceExistsError})

        _linked_service = models.LinkedServiceResource(properties=properties, type=saphana_type, connect_via=saphana_connect_via, description=saphana_description, parameters=saphana_parameters, annotations=saphana_annotations, connection_string=saphana_connection_string, server=saphana_server, authentication_type=saphana_authentication_type, user_name=saphana_user_name, password=saphana_password, encrypted_credential=saphana_encrypted_credential)
        api_version = "2018-06-01"
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.create_or_update_saphana.metadata['url']
        path_format_arguments = {
            'subscriptionId': self._serialize.url("self._config.subscription_id", self._config.subscription_id, 'str'),
            'resourceGroupName': self._serialize.url("resource_group_name", resource_group_name, 'str', max_length=90, min_length=1, pattern=r'^[-\w\._\(\)]+$'),
            'factoryName': self._serialize.url("factory_name", factory_name, 'str', max_length=63, min_length=3, pattern=r'^[A-Za-z0-9]+(?:-[A-Za-z0-9]+)*$'),
            'linkedServiceName': self._serialize.url("linked_service_name", linked_service_name, 'str', max_length=260, min_length=1, pattern=r'^[A-Za-z0-9_][^<>*#.%&:\\+?/]*$'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = 'application/json'

        # Construct and send request
        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_linked_service, 'LinkedServiceResource')
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = self._deserialize('LinkedServiceResource', pipeline_response)

        if cls:
          return cls(pipeline_response, deserialized, {})

        return deserialized
    create_or_update_saphana.metadata = {'url': '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataFactory/factories/{factoryName}/linkedservices/{linkedServiceName}'}

    def create_or_update_sapopenhub(
        self,
        resource_group_name,  # type: str
        factory_name,  # type: str
        linked_service_name,  # type: str
        sapopenhub_type,  # type: str
        sapopenhub_server,  # type: object
        sapopenhub_system_number,  # type: object
        sapopenhub_client_id,  # type: object
        if_match=None,  # type: Optional[str]
        sapopenhub_connect_via=None,  # type: Optional["models.IntegrationRuntimeReference"]
        sapopenhub_description=None,  # type: Optional[str]
        sapopenhub_parameters=None,  # type: Optional[Dict[str, "ParameterSpecification"]]
        sapopenhub_annotations=None,  # type: Optional[List[object]]
        sapopenhub_language=None,  # type: Optional[object]
        sapopenhub_user_name=None,  # type: Optional[object]
        sapopenhub_password=None,  # type: Optional["models.SecretBase"]
        sapopenhub_encrypted_credential=None,  # type: Optional[object]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.LinkedServiceResource"
        """Creates or updates a linked service.

        :param resource_group_name: The resource group name.
        :type resource_group_name: str
        :param factory_name: The factory name.
        :type factory_name: str
        :param linked_service_name: The linked service name.
        :type linked_service_name: str
        :param sapopenhub_type: Type of linked service.
        :type sapopenhub_type: str
        :param sapopenhub_server: Host name of the SAP BW instance where the open hub destination is
         located. Type: string (or Expression with resultType string).
        :type sapopenhub_server: object
        :param sapopenhub_system_number: System number of the BW system where the open hub destination
         is located. (Usually a two-digit decimal number represented as a string.) Type: string (or
         Expression with resultType string).
        :type sapopenhub_system_number: object
        :param sapopenhub_client_id: Client ID of the client on the BW system where the open hub
         destination is located. (Usually a three-digit decimal number represented as a string) Type:
         string (or Expression with resultType string).
        :type sapopenhub_client_id: object
        :param if_match: ETag of the linkedService entity.  Should only be specified for update, for
         which it should match existing entity or can be * for unconditional update.
        :type if_match: str
        :param sapopenhub_connect_via: The integration runtime reference.
        :type sapopenhub_connect_via: ~azure.mgmt.datafactory.models.IntegrationRuntimeReference
        :param sapopenhub_description: Linked service description.
        :type sapopenhub_description: str
        :param sapopenhub_parameters: Parameters for linked service.
        :type sapopenhub_parameters: dict[str, ~azure.mgmt.datafactory.models.ParameterSpecification]
        :param sapopenhub_annotations: List of tags that can be used for describing the linked service.
        :type sapopenhub_annotations: list[object]
        :param sapopenhub_language: Language of the BW system where the open hub destination is
         located. The default value is EN. Type: string (or Expression with resultType string).
        :type sapopenhub_language: object
        :param sapopenhub_user_name: Username to access the SAP BW server where the open hub
         destination is located. Type: string (or Expression with resultType string).
        :type sapopenhub_user_name: object
        :param sapopenhub_password: Password to access the SAP BW server where the open hub destination
         is located.
        :type sapopenhub_password: ~azure.mgmt.datafactory.models.SecretBase
        :param sapopenhub_encrypted_credential: The encrypted credential used for authentication.
         Credentials are encrypted using the integration runtime credential manager. Type: string (or
         Expression with resultType string).
        :type sapopenhub_encrypted_credential: object
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: LinkedServiceResource or the result of cls(response)
        :rtype: ~azure.mgmt.datafactory.models.LinkedServiceResource
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.LinkedServiceResource"]
        error_map = kwargs.pop('error_map', {404: ResourceNotFoundError, 409: ResourceExistsError})

        _linked_service = models.LinkedServiceResource(properties=properties, type=sapopenhub_type, connect_via=sapopenhub_connect_via, description=sapopenhub_description, parameters=sapopenhub_parameters, annotations=sapopenhub_annotations, server=sapopenhub_server, system_number=sapopenhub_system_number, client_id=sapopenhub_client_id, language=sapopenhub_language, user_name=sapopenhub_user_name, password=sapopenhub_password, encrypted_credential=sapopenhub_encrypted_credential)
        api_version = "2018-06-01"
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.create_or_update_sapopenhub.metadata['url']
        path_format_arguments = {
            'subscriptionId': self._serialize.url("self._config.subscription_id", self._config.subscription_id, 'str'),
            'resourceGroupName': self._serialize.url("resource_group_name", resource_group_name, 'str', max_length=90, min_length=1, pattern=r'^[-\w\._\(\)]+$'),
            'factoryName': self._serialize.url("factory_name", factory_name, 'str', max_length=63, min_length=3, pattern=r'^[A-Za-z0-9]+(?:-[A-Za-z0-9]+)*$'),
            'linkedServiceName': self._serialize.url("linked_service_name", linked_service_name, 'str', max_length=260, min_length=1, pattern=r'^[A-Za-z0-9_][^<>*#.%&:\\+?/]*$'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = 'application/json'

        # Construct and send request
        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_linked_service, 'LinkedServiceResource')
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = self._deserialize('LinkedServiceResource', pipeline_response)

        if cls:
          return cls(pipeline_response, deserialized, {})

        return deserialized
    create_or_update_sapopenhub.metadata = {'url': '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataFactory/factories/{factoryName}/linkedservices/{linkedServiceName}'}

    def create_or_update_saptable(
        self,
        resource_group_name,  # type: str
        factory_name,  # type: str
        linked_service_name,  # type: str
        saptable_type,  # type: str
        if_match=None,  # type: Optional[str]
        saptable_connect_via=None,  # type: Optional["models.IntegrationRuntimeReference"]
        saptable_description=None,  # type: Optional[str]
        saptable_parameters=None,  # type: Optional[Dict[str, "ParameterSpecification"]]
        saptable_annotations=None,  # type: Optional[List[object]]
        saptable_server=None,  # type: Optional[object]
        saptable_system_number=None,  # type: Optional[object]
        saptable_client_id=None,  # type: Optional[object]
        saptable_language=None,  # type: Optional[object]
        saptable_system_id=None,  # type: Optional[object]
        saptable_user_name=None,  # type: Optional[object]
        saptable_password=None,  # type: Optional["models.SecretBase"]
        saptable_message_server=None,  # type: Optional[object]
        saptable_message_server_service=None,  # type: Optional[object]
        saptable_snc_mode=None,  # type: Optional[object]
        saptable_snc_my_name=None,  # type: Optional[object]
        saptable_snc_partner_name=None,  # type: Optional[object]
        saptable_snc_library_path=None,  # type: Optional[object]
        saptable_snc_qop=None,  # type: Optional[object]
        saptable_logon_group=None,  # type: Optional[object]
        saptable_encrypted_credential=None,  # type: Optional[object]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.LinkedServiceResource"
        """Creates or updates a linked service.

        :param resource_group_name: The resource group name.
        :type resource_group_name: str
        :param factory_name: The factory name.
        :type factory_name: str
        :param linked_service_name: The linked service name.
        :type linked_service_name: str
        :param saptable_type: Type of linked service.
        :type saptable_type: str
        :param if_match: ETag of the linkedService entity.  Should only be specified for update, for
         which it should match existing entity or can be * for unconditional update.
        :type if_match: str
        :param saptable_connect_via: The integration runtime reference.
        :type saptable_connect_via: ~azure.mgmt.datafactory.models.IntegrationRuntimeReference
        :param saptable_description: Linked service description.
        :type saptable_description: str
        :param saptable_parameters: Parameters for linked service.
        :type saptable_parameters: dict[str, ~azure.mgmt.datafactory.models.ParameterSpecification]
        :param saptable_annotations: List of tags that can be used for describing the linked service.
        :type saptable_annotations: list[object]
        :param saptable_server: Host name of the SAP instance where the table is located. Type: string
         (or Expression with resultType string).
        :type saptable_server: object
        :param saptable_system_number: System number of the SAP system where the table is located.
         (Usually a two-digit decimal number represented as a string.) Type: string (or Expression with
         resultType string).
        :type saptable_system_number: object
        :param saptable_client_id: Client ID of the client on the SAP system where the table is
         located. (Usually a three-digit decimal number represented as a string) Type: string (or
         Expression with resultType string).
        :type saptable_client_id: object
        :param saptable_language: Language of the SAP system where the table is located. The default
         value is EN. Type: string (or Expression with resultType string).
        :type saptable_language: object
        :param saptable_system_id: SystemID of the SAP system where the table is located. Type: string
         (or Expression with resultType string).
        :type saptable_system_id: object
        :param saptable_user_name: Username to access the SAP server where the table is located. Type:
         string (or Expression with resultType string).
        :type saptable_user_name: object
        :param saptable_password: Password to access the SAP server where the table is located.
        :type saptable_password: ~azure.mgmt.datafactory.models.SecretBase
        :param saptable_message_server: The hostname of the SAP Message Server. Type: string (or
         Expression with resultType string).
        :type saptable_message_server: object
        :param saptable_message_server_service: The service name or port number of the Message Server.
         Type: string (or Expression with resultType string).
        :type saptable_message_server_service: object
        :param saptable_snc_mode: SNC activation indicator to access the SAP server where the table is
         located. Must be either 0 (off) or 1 (on). Type: string (or Expression with resultType string).
        :type saptable_snc_mode: object
        :param saptable_snc_my_name: Initiator's SNC name to access the SAP server where the table is
         located. Type: string (or Expression with resultType string).
        :type saptable_snc_my_name: object
        :param saptable_snc_partner_name: Communication partner's SNC name to access the SAP server
         where the table is located. Type: string (or Expression with resultType string).
        :type saptable_snc_partner_name: object
        :param saptable_snc_library_path: External security product's library to access the SAP server
         where the table is located. Type: string (or Expression with resultType string).
        :type saptable_snc_library_path: object
        :param saptable_snc_qop: SNC Quality of Protection. Allowed value include: 1, 2, 3, 8, 9. Type:
         string (or Expression with resultType string).
        :type saptable_snc_qop: object
        :param saptable_logon_group: The Logon Group for the SAP System. Type: string (or Expression
         with resultType string).
        :type saptable_logon_group: object
        :param saptable_encrypted_credential: The encrypted credential used for authentication.
         Credentials are encrypted using the integration runtime credential manager. Type: string (or
         Expression with resultType string).
        :type saptable_encrypted_credential: object
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: LinkedServiceResource or the result of cls(response)
        :rtype: ~azure.mgmt.datafactory.models.LinkedServiceResource
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.LinkedServiceResource"]
        error_map = kwargs.pop('error_map', {404: ResourceNotFoundError, 409: ResourceExistsError})

        _linked_service = models.LinkedServiceResource(properties=properties, type=saptable_type, connect_via=saptable_connect_via, description=saptable_description, parameters=saptable_parameters, annotations=saptable_annotations, server=saptable_server, system_number=saptable_system_number, client_id=saptable_client_id, language=saptable_language, system_id=saptable_system_id, user_name=saptable_user_name, password=saptable_password, message_server=saptable_message_server, message_server_service=saptable_message_server_service, snc_mode=saptable_snc_mode, snc_my_name=saptable_snc_my_name, snc_partner_name=saptable_snc_partner_name, snc_library_path=saptable_snc_library_path, snc_qop=saptable_snc_qop, logon_group=saptable_logon_group, encrypted_credential=saptable_encrypted_credential)
        api_version = "2018-06-01"
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.create_or_update_saptable.metadata['url']
        path_format_arguments = {
            'subscriptionId': self._serialize.url("self._config.subscription_id", self._config.subscription_id, 'str'),
            'resourceGroupName': self._serialize.url("resource_group_name", resource_group_name, 'str', max_length=90, min_length=1, pattern=r'^[-\w\._\(\)]+$'),
            'factoryName': self._serialize.url("factory_name", factory_name, 'str', max_length=63, min_length=3, pattern=r'^[A-Za-z0-9]+(?:-[A-Za-z0-9]+)*$'),
            'linkedServiceName': self._serialize.url("linked_service_name", linked_service_name, 'str', max_length=260, min_length=1, pattern=r'^[A-Za-z0-9_][^<>*#.%&:\\+?/]*$'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = 'application/json'

        # Construct and send request
        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_linked_service, 'LinkedServiceResource')
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = self._deserialize('LinkedServiceResource', pipeline_response)

        if cls:
          return cls(pipeline_response, deserialized, {})

        return deserialized
    create_or_update_saptable.metadata = {'url': '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataFactory/factories/{factoryName}/linkedservices/{linkedServiceName}'}

    def create_or_update_servicenow(
        self,
        resource_group_name,  # type: str
        factory_name,  # type: str
        linked_service_name,  # type: str
        servicenow_type,  # type: str
        servicenow_endpoint,  # type: object
        servicenow_authentication_type,  # type: Union[str, "models.ServiceNowAuthenticationType"]
        if_match=None,  # type: Optional[str]
        servicenow_connect_via=None,  # type: Optional["models.IntegrationRuntimeReference"]
        servicenow_description=None,  # type: Optional[str]
        servicenow_parameters=None,  # type: Optional[Dict[str, "ParameterSpecification"]]
        servicenow_annotations=None,  # type: Optional[List[object]]
        servicenow_username=None,  # type: Optional[object]
        servicenow_password=None,  # type: Optional["models.SecretBase"]
        servicenow_client_id=None,  # type: Optional[object]
        servicenow_client_secret=None,  # type: Optional["models.SecretBase"]
        servicenow_use_encrypted_endpoints=None,  # type: Optional[object]
        servicenow_use_host_verification=None,  # type: Optional[object]
        servicenow_use_peer_verification=None,  # type: Optional[object]
        servicenow_encrypted_credential=None,  # type: Optional[object]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.LinkedServiceResource"
        """Creates or updates a linked service.

        :param resource_group_name: The resource group name.
        :type resource_group_name: str
        :param factory_name: The factory name.
        :type factory_name: str
        :param linked_service_name: The linked service name.
        :type linked_service_name: str
        :param servicenow_type: Type of linked service.
        :type servicenow_type: str
        :param servicenow_endpoint: The endpoint of the ServiceNow server. (i.e.
         :code:`<instance>`.service-now.com).
        :type servicenow_endpoint: object
        :param servicenow_authentication_type: The authentication type to use.
        :type servicenow_authentication_type: str or ~azure.mgmt.datafactory.models.ServiceNowAuthenticationType
        :param if_match: ETag of the linkedService entity.  Should only be specified for update, for
         which it should match existing entity or can be * for unconditional update.
        :type if_match: str
        :param servicenow_connect_via: The integration runtime reference.
        :type servicenow_connect_via: ~azure.mgmt.datafactory.models.IntegrationRuntimeReference
        :param servicenow_description: Linked service description.
        :type servicenow_description: str
        :param servicenow_parameters: Parameters for linked service.
        :type servicenow_parameters: dict[str, ~azure.mgmt.datafactory.models.ParameterSpecification]
        :param servicenow_annotations: List of tags that can be used for describing the linked service.
        :type servicenow_annotations: list[object]
        :param servicenow_username: The user name used to connect to the ServiceNow server for Basic
         and OAuth2 authentication.
        :type servicenow_username: object
        :param servicenow_password: The password corresponding to the user name for Basic and OAuth2
         authentication.
        :type servicenow_password: ~azure.mgmt.datafactory.models.SecretBase
        :param servicenow_client_id: The client id for OAuth2 authentication.
        :type servicenow_client_id: object
        :param servicenow_client_secret: The client secret for OAuth2 authentication.
        :type servicenow_client_secret: ~azure.mgmt.datafactory.models.SecretBase
        :param servicenow_use_encrypted_endpoints: Specifies whether the data source endpoints are
         encrypted using HTTPS. The default value is true.
        :type servicenow_use_encrypted_endpoints: object
        :param servicenow_use_host_verification: Specifies whether to require the host name in the
         server's certificate to match the host name of the server when connecting over SSL. The default
         value is true.
        :type servicenow_use_host_verification: object
        :param servicenow_use_peer_verification: Specifies whether to verify the identity of the server
         when connecting over SSL. The default value is true.
        :type servicenow_use_peer_verification: object
        :param servicenow_encrypted_credential: The encrypted credential used for authentication.
         Credentials are encrypted using the integration runtime credential manager. Type: string (or
         Expression with resultType string).
        :type servicenow_encrypted_credential: object
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: LinkedServiceResource or the result of cls(response)
        :rtype: ~azure.mgmt.datafactory.models.LinkedServiceResource
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.LinkedServiceResource"]
        error_map = kwargs.pop('error_map', {404: ResourceNotFoundError, 409: ResourceExistsError})

        _linked_service = models.LinkedServiceResource(properties=properties, type=servicenow_type, connect_via=servicenow_connect_via, description=servicenow_description, parameters=servicenow_parameters, annotations=servicenow_annotations, endpoint=servicenow_endpoint, authentication_type=servicenow_authentication_type, username=servicenow_username, password=servicenow_password, client_id=servicenow_client_id, client_secret=servicenow_client_secret, use_encrypted_endpoints=servicenow_use_encrypted_endpoints, use_host_verification=servicenow_use_host_verification, use_peer_verification=servicenow_use_peer_verification, encrypted_credential=servicenow_encrypted_credential)
        api_version = "2018-06-01"
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.create_or_update_servicenow.metadata['url']
        path_format_arguments = {
            'subscriptionId': self._serialize.url("self._config.subscription_id", self._config.subscription_id, 'str'),
            'resourceGroupName': self._serialize.url("resource_group_name", resource_group_name, 'str', max_length=90, min_length=1, pattern=r'^[-\w\._\(\)]+$'),
            'factoryName': self._serialize.url("factory_name", factory_name, 'str', max_length=63, min_length=3, pattern=r'^[A-Za-z0-9]+(?:-[A-Za-z0-9]+)*$'),
            'linkedServiceName': self._serialize.url("linked_service_name", linked_service_name, 'str', max_length=260, min_length=1, pattern=r'^[A-Za-z0-9_][^<>*#.%&:\\+?/]*$'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = 'application/json'

        # Construct and send request
        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_linked_service, 'LinkedServiceResource')
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = self._deserialize('LinkedServiceResource', pipeline_response)

        if cls:
          return cls(pipeline_response, deserialized, {})

        return deserialized
    create_or_update_servicenow.metadata = {'url': '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataFactory/factories/{factoryName}/linkedservices/{linkedServiceName}'}

    def create_or_update_sftp(
        self,
        resource_group_name,  # type: str
        factory_name,  # type: str
        linked_service_name,  # type: str
        sftp_type,  # type: str
        sftp_host,  # type: object
        if_match=None,  # type: Optional[str]
        sftp_connect_via=None,  # type: Optional["models.IntegrationRuntimeReference"]
        sftp_description=None,  # type: Optional[str]
        sftp_parameters=None,  # type: Optional[Dict[str, "ParameterSpecification"]]
        sftp_annotations=None,  # type: Optional[List[object]]
        sftp_port=None,  # type: Optional[object]
        sftp_authentication_type=None,  # type: Optional[Union[str, "models.SftpAuthenticationType"]]
        sftp_user_name=None,  # type: Optional[object]
        sftp_password=None,  # type: Optional["models.SecretBase"]
        sftp_encrypted_credential=None,  # type: Optional[object]
        sftp_private_key_path=None,  # type: Optional[object]
        sftp_private_key_content=None,  # type: Optional["models.SecretBase"]
        sftp_pass_phrase=None,  # type: Optional["models.SecretBase"]
        sftp_skip_host_key_validation=None,  # type: Optional[object]
        sftp_host_key_fingerprint=None,  # type: Optional[object]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.LinkedServiceResource"
        """Creates or updates a linked service.

        :param resource_group_name: The resource group name.
        :type resource_group_name: str
        :param factory_name: The factory name.
        :type factory_name: str
        :param linked_service_name: The linked service name.
        :type linked_service_name: str
        :param sftp_type: Type of linked service.
        :type sftp_type: str
        :param sftp_host: The SFTP server host name. Type: string (or Expression with resultType
         string).
        :type sftp_host: object
        :param if_match: ETag of the linkedService entity.  Should only be specified for update, for
         which it should match existing entity or can be * for unconditional update.
        :type if_match: str
        :param sftp_connect_via: The integration runtime reference.
        :type sftp_connect_via: ~azure.mgmt.datafactory.models.IntegrationRuntimeReference
        :param sftp_description: Linked service description.
        :type sftp_description: str
        :param sftp_parameters: Parameters for linked service.
        :type sftp_parameters: dict[str, ~azure.mgmt.datafactory.models.ParameterSpecification]
        :param sftp_annotations: List of tags that can be used for describing the linked service.
        :type sftp_annotations: list[object]
        :param sftp_port: The TCP port number that the SFTP server uses to listen for client
         connections. Default value is 22. Type: integer (or Expression with resultType integer),
         minimum: 0.
        :type sftp_port: object
        :param sftp_authentication_type: The authentication type to be used to connect to the FTP
         server.
        :type sftp_authentication_type: str or ~azure.mgmt.datafactory.models.SftpAuthenticationType
        :param sftp_user_name: The username used to log on to the SFTP server. Type: string (or
         Expression with resultType string).
        :type sftp_user_name: object
        :param sftp_password: Password to logon the SFTP server for Basic authentication.
        :type sftp_password: ~azure.mgmt.datafactory.models.SecretBase
        :param sftp_encrypted_credential: The encrypted credential used for authentication. Credentials
         are encrypted using the integration runtime credential manager. Type: string (or Expression
         with resultType string).
        :type sftp_encrypted_credential: object
        :param sftp_private_key_path: The SSH private key file path for SshPublicKey authentication.
         Only valid for on-premises copy. For on-premises copy with SshPublicKey authentication, either
         PrivateKeyPath or PrivateKeyContent should be specified. SSH private key should be OpenSSH
         format. Type: string (or Expression with resultType string).
        :type sftp_private_key_path: object
        :param sftp_private_key_content: Base64 encoded SSH private key content for SshPublicKey
         authentication. For on-premises copy with SshPublicKey authentication, either PrivateKeyPath or
         PrivateKeyContent should be specified. SSH private key should be OpenSSH format.
        :type sftp_private_key_content: ~azure.mgmt.datafactory.models.SecretBase
        :param sftp_pass_phrase: The password to decrypt the SSH private key if the SSH private key is
         encrypted.
        :type sftp_pass_phrase: ~azure.mgmt.datafactory.models.SecretBase
        :param sftp_skip_host_key_validation: If true, skip the SSH host key validation. Default value
         is false. Type: boolean (or Expression with resultType boolean).
        :type sftp_skip_host_key_validation: object
        :param sftp_host_key_fingerprint: The host key finger-print of the SFTP server. When
         SkipHostKeyValidation is false, HostKeyFingerprint should be specified. Type: string (or
         Expression with resultType string).
        :type sftp_host_key_fingerprint: object
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: LinkedServiceResource or the result of cls(response)
        :rtype: ~azure.mgmt.datafactory.models.LinkedServiceResource
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.LinkedServiceResource"]
        error_map = kwargs.pop('error_map', {404: ResourceNotFoundError, 409: ResourceExistsError})

        _linked_service = models.LinkedServiceResource(properties=properties, type=sftp_type, connect_via=sftp_connect_via, description=sftp_description, parameters=sftp_parameters, annotations=sftp_annotations, host=sftp_host, port=sftp_port, authentication_type=sftp_authentication_type, user_name=sftp_user_name, password=sftp_password, encrypted_credential=sftp_encrypted_credential, private_key_path=sftp_private_key_path, private_key_content=sftp_private_key_content, pass_phrase=sftp_pass_phrase, skip_host_key_validation=sftp_skip_host_key_validation, host_key_fingerprint=sftp_host_key_fingerprint)
        api_version = "2018-06-01"
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.create_or_update_sftp.metadata['url']
        path_format_arguments = {
            'subscriptionId': self._serialize.url("self._config.subscription_id", self._config.subscription_id, 'str'),
            'resourceGroupName': self._serialize.url("resource_group_name", resource_group_name, 'str', max_length=90, min_length=1, pattern=r'^[-\w\._\(\)]+$'),
            'factoryName': self._serialize.url("factory_name", factory_name, 'str', max_length=63, min_length=3, pattern=r'^[A-Za-z0-9]+(?:-[A-Za-z0-9]+)*$'),
            'linkedServiceName': self._serialize.url("linked_service_name", linked_service_name, 'str', max_length=260, min_length=1, pattern=r'^[A-Za-z0-9_][^<>*#.%&:\\+?/]*$'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = 'application/json'

        # Construct and send request
        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_linked_service, 'LinkedServiceResource')
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = self._deserialize('LinkedServiceResource', pipeline_response)

        if cls:
          return cls(pipeline_response, deserialized, {})

        return deserialized
    create_or_update_sftp.metadata = {'url': '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataFactory/factories/{factoryName}/linkedservices/{linkedServiceName}'}

    def create_or_update_shopify(
        self,
        resource_group_name,  # type: str
        factory_name,  # type: str
        linked_service_name,  # type: str
        shopify_type,  # type: str
        shopify_host,  # type: object
        if_match=None,  # type: Optional[str]
        shopify_connect_via=None,  # type: Optional["models.IntegrationRuntimeReference"]
        shopify_description=None,  # type: Optional[str]
        shopify_parameters=None,  # type: Optional[Dict[str, "ParameterSpecification"]]
        shopify_annotations=None,  # type: Optional[List[object]]
        shopify_access_token=None,  # type: Optional["models.SecretBase"]
        shopify_use_encrypted_endpoints=None,  # type: Optional[object]
        shopify_use_host_verification=None,  # type: Optional[object]
        shopify_use_peer_verification=None,  # type: Optional[object]
        shopify_encrypted_credential=None,  # type: Optional[object]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.LinkedServiceResource"
        """Creates or updates a linked service.

        :param resource_group_name: The resource group name.
        :type resource_group_name: str
        :param factory_name: The factory name.
        :type factory_name: str
        :param linked_service_name: The linked service name.
        :type linked_service_name: str
        :param shopify_type: Type of linked service.
        :type shopify_type: str
        :param shopify_host: The endpoint of the Shopify server. (i.e. mystore.myshopify.com).
        :type shopify_host: object
        :param if_match: ETag of the linkedService entity.  Should only be specified for update, for
         which it should match existing entity or can be * for unconditional update.
        :type if_match: str
        :param shopify_connect_via: The integration runtime reference.
        :type shopify_connect_via: ~azure.mgmt.datafactory.models.IntegrationRuntimeReference
        :param shopify_description: Linked service description.
        :type shopify_description: str
        :param shopify_parameters: Parameters for linked service.
        :type shopify_parameters: dict[str, ~azure.mgmt.datafactory.models.ParameterSpecification]
        :param shopify_annotations: List of tags that can be used for describing the linked service.
        :type shopify_annotations: list[object]
        :param shopify_access_token: The API access token that can be used to access Shopify’s data.
         The token won't expire if it is offline mode.
        :type shopify_access_token: ~azure.mgmt.datafactory.models.SecretBase
        :param shopify_use_encrypted_endpoints: Specifies whether the data source endpoints are
         encrypted using HTTPS. The default value is true.
        :type shopify_use_encrypted_endpoints: object
        :param shopify_use_host_verification: Specifies whether to require the host name in the
         server's certificate to match the host name of the server when connecting over SSL. The default
         value is true.
        :type shopify_use_host_verification: object
        :param shopify_use_peer_verification: Specifies whether to verify the identity of the server
         when connecting over SSL. The default value is true.
        :type shopify_use_peer_verification: object
        :param shopify_encrypted_credential: The encrypted credential used for authentication.
         Credentials are encrypted using the integration runtime credential manager. Type: string (or
         Expression with resultType string).
        :type shopify_encrypted_credential: object
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: LinkedServiceResource or the result of cls(response)
        :rtype: ~azure.mgmt.datafactory.models.LinkedServiceResource
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.LinkedServiceResource"]
        error_map = kwargs.pop('error_map', {404: ResourceNotFoundError, 409: ResourceExistsError})

        _linked_service = models.LinkedServiceResource(properties=properties, type=shopify_type, connect_via=shopify_connect_via, description=shopify_description, parameters=shopify_parameters, annotations=shopify_annotations, host=shopify_host, access_token=shopify_access_token, use_encrypted_endpoints=shopify_use_encrypted_endpoints, use_host_verification=shopify_use_host_verification, use_peer_verification=shopify_use_peer_verification, encrypted_credential=shopify_encrypted_credential)
        api_version = "2018-06-01"
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.create_or_update_shopify.metadata['url']
        path_format_arguments = {
            'subscriptionId': self._serialize.url("self._config.subscription_id", self._config.subscription_id, 'str'),
            'resourceGroupName': self._serialize.url("resource_group_name", resource_group_name, 'str', max_length=90, min_length=1, pattern=r'^[-\w\._\(\)]+$'),
            'factoryName': self._serialize.url("factory_name", factory_name, 'str', max_length=63, min_length=3, pattern=r'^[A-Za-z0-9]+(?:-[A-Za-z0-9]+)*$'),
            'linkedServiceName': self._serialize.url("linked_service_name", linked_service_name, 'str', max_length=260, min_length=1, pattern=r'^[A-Za-z0-9_][^<>*#.%&:\\+?/]*$'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = 'application/json'

        # Construct and send request
        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_linked_service, 'LinkedServiceResource')
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = self._deserialize('LinkedServiceResource', pipeline_response)

        if cls:
          return cls(pipeline_response, deserialized, {})

        return deserialized
    create_or_update_shopify.metadata = {'url': '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataFactory/factories/{factoryName}/linkedservices/{linkedServiceName}'}

    def create_or_update_snowflake(
        self,
        resource_group_name,  # type: str
        factory_name,  # type: str
        linked_service_name,  # type: str
        snowflake_type,  # type: str
        snowflake_connection_string,  # type: object
        if_match=None,  # type: Optional[str]
        snowflake_connect_via=None,  # type: Optional["models.IntegrationRuntimeReference"]
        snowflake_description=None,  # type: Optional[str]
        snowflake_parameters=None,  # type: Optional[Dict[str, "ParameterSpecification"]]
        snowflake_annotations=None,  # type: Optional[List[object]]
        snowflake_password=None,  # type: Optional["models.AzureKeyVaultSecretReference"]
        snowflake_encrypted_credential=None,  # type: Optional[object]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.LinkedServiceResource"
        """Creates or updates a linked service.

        :param resource_group_name: The resource group name.
        :type resource_group_name: str
        :param factory_name: The factory name.
        :type factory_name: str
        :param linked_service_name: The linked service name.
        :type linked_service_name: str
        :param snowflake_type: Type of linked service.
        :type snowflake_type: str
        :param snowflake_connection_string: The connection string of snowflake. Type: string,
         SecureString.
        :type snowflake_connection_string: object
        :param if_match: ETag of the linkedService entity.  Should only be specified for update, for
         which it should match existing entity or can be * for unconditional update.
        :type if_match: str
        :param snowflake_connect_via: The integration runtime reference.
        :type snowflake_connect_via: ~azure.mgmt.datafactory.models.IntegrationRuntimeReference
        :param snowflake_description: Linked service description.
        :type snowflake_description: str
        :param snowflake_parameters: Parameters for linked service.
        :type snowflake_parameters: dict[str, ~azure.mgmt.datafactory.models.ParameterSpecification]
        :param snowflake_annotations: List of tags that can be used for describing the linked service.
        :type snowflake_annotations: list[object]
        :param snowflake_password: The Azure key vault secret reference of password in connection
         string.
        :type snowflake_password: ~azure.mgmt.datafactory.models.AzureKeyVaultSecretReference
        :param snowflake_encrypted_credential: The encrypted credential used for authentication.
         Credentials are encrypted using the integration runtime credential manager. Type: string (or
         Expression with resultType string).
        :type snowflake_encrypted_credential: object
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: LinkedServiceResource or the result of cls(response)
        :rtype: ~azure.mgmt.datafactory.models.LinkedServiceResource
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.LinkedServiceResource"]
        error_map = kwargs.pop('error_map', {404: ResourceNotFoundError, 409: ResourceExistsError})

        _linked_service = models.LinkedServiceResource(properties=properties, type=snowflake_type, connect_via=snowflake_connect_via, description=snowflake_description, parameters=snowflake_parameters, annotations=snowflake_annotations, connection_string=snowflake_connection_string, password=snowflake_password, encrypted_credential=snowflake_encrypted_credential)
        api_version = "2018-06-01"
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.create_or_update_snowflake.metadata['url']
        path_format_arguments = {
            'subscriptionId': self._serialize.url("self._config.subscription_id", self._config.subscription_id, 'str'),
            'resourceGroupName': self._serialize.url("resource_group_name", resource_group_name, 'str', max_length=90, min_length=1, pattern=r'^[-\w\._\(\)]+$'),
            'factoryName': self._serialize.url("factory_name", factory_name, 'str', max_length=63, min_length=3, pattern=r'^[A-Za-z0-9]+(?:-[A-Za-z0-9]+)*$'),
            'linkedServiceName': self._serialize.url("linked_service_name", linked_service_name, 'str', max_length=260, min_length=1, pattern=r'^[A-Za-z0-9_][^<>*#.%&:\\+?/]*$'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = 'application/json'

        # Construct and send request
        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_linked_service, 'LinkedServiceResource')
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = self._deserialize('LinkedServiceResource', pipeline_response)

        if cls:
          return cls(pipeline_response, deserialized, {})

        return deserialized
    create_or_update_snowflake.metadata = {'url': '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataFactory/factories/{factoryName}/linkedservices/{linkedServiceName}'}

    def create_or_update_spark(
        self,
        resource_group_name,  # type: str
        factory_name,  # type: str
        linked_service_name,  # type: str
        spark_type,  # type: str
        spark_host,  # type: object
        spark_port,  # type: object
        spark_authentication_type,  # type: Union[str, "models.SparkAuthenticationType"]
        if_match=None,  # type: Optional[str]
        spark_connect_via=None,  # type: Optional["models.IntegrationRuntimeReference"]
        spark_description=None,  # type: Optional[str]
        spark_parameters=None,  # type: Optional[Dict[str, "ParameterSpecification"]]
        spark_annotations=None,  # type: Optional[List[object]]
        spark_server_type=None,  # type: Optional[Union[str, "models.SparkServerType"]]
        spark_thrift_transport_protocol=None,  # type: Optional[Union[str, "models.SparkThriftTransportProtocol"]]
        spark_username=None,  # type: Optional[object]
        spark_password=None,  # type: Optional["models.SecretBase"]
        spark_http_path=None,  # type: Optional[object]
        spark_enable_ssl=None,  # type: Optional[object]
        spark_trusted_cert_path=None,  # type: Optional[object]
        spark_use_system_trust_store=None,  # type: Optional[object]
        spark_allow_host_name_cn_mismatch=None,  # type: Optional[object]
        spark_allow_self_signed_server_cert=None,  # type: Optional[object]
        spark_encrypted_credential=None,  # type: Optional[object]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.LinkedServiceResource"
        """Creates or updates a linked service.

        :param resource_group_name: The resource group name.
        :type resource_group_name: str
        :param factory_name: The factory name.
        :type factory_name: str
        :param linked_service_name: The linked service name.
        :type linked_service_name: str
        :param spark_type: Type of linked service.
        :type spark_type: str
        :param spark_host: IP address or host name of the Spark server.
        :type spark_host: object
        :param spark_port: The TCP port that the Spark server uses to listen for client connections.
        :type spark_port: object
        :param spark_authentication_type: The authentication method used to access the Spark server.
        :type spark_authentication_type: str or ~azure.mgmt.datafactory.models.SparkAuthenticationType
        :param if_match: ETag of the linkedService entity.  Should only be specified for update, for
         which it should match existing entity or can be * for unconditional update.
        :type if_match: str
        :param spark_connect_via: The integration runtime reference.
        :type spark_connect_via: ~azure.mgmt.datafactory.models.IntegrationRuntimeReference
        :param spark_description: Linked service description.
        :type spark_description: str
        :param spark_parameters: Parameters for linked service.
        :type spark_parameters: dict[str, ~azure.mgmt.datafactory.models.ParameterSpecification]
        :param spark_annotations: List of tags that can be used for describing the linked service.
        :type spark_annotations: list[object]
        :param spark_server_type: The type of Spark server.
        :type spark_server_type: str or ~azure.mgmt.datafactory.models.SparkServerType
        :param spark_thrift_transport_protocol: The transport protocol to use in the Thrift layer.
        :type spark_thrift_transport_protocol: str or ~azure.mgmt.datafactory.models.SparkThriftTransportProtocol
        :param spark_username: The user name that you use to access Spark Server.
        :type spark_username: object
        :param spark_password: The password corresponding to the user name that you provided in the
         Username field.
        :type spark_password: ~azure.mgmt.datafactory.models.SecretBase
        :param spark_http_path: The partial URL corresponding to the Spark server.
        :type spark_http_path: object
        :param spark_enable_ssl: Specifies whether the connections to the server are encrypted using
         SSL. The default value is false.
        :type spark_enable_ssl: object
        :param spark_trusted_cert_path: The full path of the .pem file containing trusted CA
         certificates for verifying the server when connecting over SSL. This property can only be set
         when using SSL on self-hosted IR. The default value is the cacerts.pem file installed with the
         IR.
        :type spark_trusted_cert_path: object
        :param spark_use_system_trust_store: Specifies whether to use a CA certificate from the system
         trust store or from a specified PEM file. The default value is false.
        :type spark_use_system_trust_store: object
        :param spark_allow_host_name_cn_mismatch: Specifies whether to require a CA-issued SSL
         certificate name to match the host name of the server when connecting over SSL. The default
         value is false.
        :type spark_allow_host_name_cn_mismatch: object
        :param spark_allow_self_signed_server_cert: Specifies whether to allow self-signed certificates
         from the server. The default value is false.
        :type spark_allow_self_signed_server_cert: object
        :param spark_encrypted_credential: The encrypted credential used for authentication.
         Credentials are encrypted using the integration runtime credential manager. Type: string (or
         Expression with resultType string).
        :type spark_encrypted_credential: object
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: LinkedServiceResource or the result of cls(response)
        :rtype: ~azure.mgmt.datafactory.models.LinkedServiceResource
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.LinkedServiceResource"]
        error_map = kwargs.pop('error_map', {404: ResourceNotFoundError, 409: ResourceExistsError})

        _linked_service = models.LinkedServiceResource(properties=properties, type=spark_type, connect_via=spark_connect_via, description=spark_description, parameters=spark_parameters, annotations=spark_annotations, host=spark_host, port=spark_port, server_type=spark_server_type, thrift_transport_protocol=spark_thrift_transport_protocol, authentication_type=spark_authentication_type, username=spark_username, password=spark_password, http_path=spark_http_path, enable_ssl=spark_enable_ssl, trusted_cert_path=spark_trusted_cert_path, use_system_trust_store=spark_use_system_trust_store, allow_host_name_cn_mismatch=spark_allow_host_name_cn_mismatch, allow_self_signed_server_cert=spark_allow_self_signed_server_cert, encrypted_credential=spark_encrypted_credential)
        api_version = "2018-06-01"
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.create_or_update_spark.metadata['url']
        path_format_arguments = {
            'subscriptionId': self._serialize.url("self._config.subscription_id", self._config.subscription_id, 'str'),
            'resourceGroupName': self._serialize.url("resource_group_name", resource_group_name, 'str', max_length=90, min_length=1, pattern=r'^[-\w\._\(\)]+$'),
            'factoryName': self._serialize.url("factory_name", factory_name, 'str', max_length=63, min_length=3, pattern=r'^[A-Za-z0-9]+(?:-[A-Za-z0-9]+)*$'),
            'linkedServiceName': self._serialize.url("linked_service_name", linked_service_name, 'str', max_length=260, min_length=1, pattern=r'^[A-Za-z0-9_][^<>*#.%&:\\+?/]*$'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = 'application/json'

        # Construct and send request
        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_linked_service, 'LinkedServiceResource')
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = self._deserialize('LinkedServiceResource', pipeline_response)

        if cls:
          return cls(pipeline_response, deserialized, {})

        return deserialized
    create_or_update_spark.metadata = {'url': '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataFactory/factories/{factoryName}/linkedservices/{linkedServiceName}'}

    def create_or_update_sqlserver(
        self,
        resource_group_name,  # type: str
        factory_name,  # type: str
        linked_service_name,  # type: str
        sqlserver_type,  # type: str
        sqlserver_connection_string,  # type: object
        if_match=None,  # type: Optional[str]
        sqlserver_connect_via=None,  # type: Optional["models.IntegrationRuntimeReference"]
        sqlserver_description=None,  # type: Optional[str]
        sqlserver_parameters=None,  # type: Optional[Dict[str, "ParameterSpecification"]]
        sqlserver_annotations=None,  # type: Optional[List[object]]
        sqlserver_user_name=None,  # type: Optional[object]
        sqlserver_password=None,  # type: Optional["models.SecretBase"]
        sqlserver_encrypted_credential=None,  # type: Optional[object]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.LinkedServiceResource"
        """Creates or updates a linked service.

        :param resource_group_name: The resource group name.
        :type resource_group_name: str
        :param factory_name: The factory name.
        :type factory_name: str
        :param linked_service_name: The linked service name.
        :type linked_service_name: str
        :param sqlserver_type: Type of linked service.
        :type sqlserver_type: str
        :param sqlserver_connection_string: The connection string. Type: string, SecureString or
         AzureKeyVaultSecretReference.
        :type sqlserver_connection_string: object
        :param if_match: ETag of the linkedService entity.  Should only be specified for update, for
         which it should match existing entity or can be * for unconditional update.
        :type if_match: str
        :param sqlserver_connect_via: The integration runtime reference.
        :type sqlserver_connect_via: ~azure.mgmt.datafactory.models.IntegrationRuntimeReference
        :param sqlserver_description: Linked service description.
        :type sqlserver_description: str
        :param sqlserver_parameters: Parameters for linked service.
        :type sqlserver_parameters: dict[str, ~azure.mgmt.datafactory.models.ParameterSpecification]
        :param sqlserver_annotations: List of tags that can be used for describing the linked service.
        :type sqlserver_annotations: list[object]
        :param sqlserver_user_name: The on-premises Windows authentication user name. Type: string (or
         Expression with resultType string).
        :type sqlserver_user_name: object
        :param sqlserver_password: The on-premises Windows authentication password.
        :type sqlserver_password: ~azure.mgmt.datafactory.models.SecretBase
        :param sqlserver_encrypted_credential: The encrypted credential used for authentication.
         Credentials are encrypted using the integration runtime credential manager. Type: string (or
         Expression with resultType string).
        :type sqlserver_encrypted_credential: object
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: LinkedServiceResource or the result of cls(response)
        :rtype: ~azure.mgmt.datafactory.models.LinkedServiceResource
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.LinkedServiceResource"]
        error_map = kwargs.pop('error_map', {404: ResourceNotFoundError, 409: ResourceExistsError})

        _linked_service = models.LinkedServiceResource(properties=properties, type=sqlserver_type, connect_via=sqlserver_connect_via, description=sqlserver_description, parameters=sqlserver_parameters, annotations=sqlserver_annotations, connection_string=sqlserver_connection_string, user_name=sqlserver_user_name, password=sqlserver_password, encrypted_credential=sqlserver_encrypted_credential)
        api_version = "2018-06-01"
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.create_or_update_sqlserver.metadata['url']
        path_format_arguments = {
            'subscriptionId': self._serialize.url("self._config.subscription_id", self._config.subscription_id, 'str'),
            'resourceGroupName': self._serialize.url("resource_group_name", resource_group_name, 'str', max_length=90, min_length=1, pattern=r'^[-\w\._\(\)]+$'),
            'factoryName': self._serialize.url("factory_name", factory_name, 'str', max_length=63, min_length=3, pattern=r'^[A-Za-z0-9]+(?:-[A-Za-z0-9]+)*$'),
            'linkedServiceName': self._serialize.url("linked_service_name", linked_service_name, 'str', max_length=260, min_length=1, pattern=r'^[A-Za-z0-9_][^<>*#.%&:\\+?/]*$'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = 'application/json'

        # Construct and send request
        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_linked_service, 'LinkedServiceResource')
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = self._deserialize('LinkedServiceResource', pipeline_response)

        if cls:
          return cls(pipeline_response, deserialized, {})

        return deserialized
    create_or_update_sqlserver.metadata = {'url': '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataFactory/factories/{factoryName}/linkedservices/{linkedServiceName}'}

    def create_or_update_square(
        self,
        resource_group_name,  # type: str
        factory_name,  # type: str
        linked_service_name,  # type: str
        square_type,  # type: str
        square_host,  # type: object
        square_client_id,  # type: object
        square_redirect_uri,  # type: object
        if_match=None,  # type: Optional[str]
        square_connect_via=None,  # type: Optional["models.IntegrationRuntimeReference"]
        square_description=None,  # type: Optional[str]
        square_parameters=None,  # type: Optional[Dict[str, "ParameterSpecification"]]
        square_annotations=None,  # type: Optional[List[object]]
        square_client_secret=None,  # type: Optional["models.SecretBase"]
        square_use_encrypted_endpoints=None,  # type: Optional[object]
        square_use_host_verification=None,  # type: Optional[object]
        square_use_peer_verification=None,  # type: Optional[object]
        square_encrypted_credential=None,  # type: Optional[object]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.LinkedServiceResource"
        """Creates or updates a linked service.

        :param resource_group_name: The resource group name.
        :type resource_group_name: str
        :param factory_name: The factory name.
        :type factory_name: str
        :param linked_service_name: The linked service name.
        :type linked_service_name: str
        :param square_type: Type of linked service.
        :type square_type: str
        :param square_host: The URL of the Square instance. (i.e. mystore.mysquare.com).
        :type square_host: object
        :param square_client_id: The client ID associated with your Square application.
        :type square_client_id: object
        :param square_redirect_uri: The redirect URL assigned in the Square application dashboard.
         (i.e. http://localhost:2500).
        :type square_redirect_uri: object
        :param if_match: ETag of the linkedService entity.  Should only be specified for update, for
         which it should match existing entity or can be * for unconditional update.
        :type if_match: str
        :param square_connect_via: The integration runtime reference.
        :type square_connect_via: ~azure.mgmt.datafactory.models.IntegrationRuntimeReference
        :param square_description: Linked service description.
        :type square_description: str
        :param square_parameters: Parameters for linked service.
        :type square_parameters: dict[str, ~azure.mgmt.datafactory.models.ParameterSpecification]
        :param square_annotations: List of tags that can be used for describing the linked service.
        :type square_annotations: list[object]
        :param square_client_secret: The client secret associated with your Square application.
        :type square_client_secret: ~azure.mgmt.datafactory.models.SecretBase
        :param square_use_encrypted_endpoints: Specifies whether the data source endpoints are
         encrypted using HTTPS. The default value is true.
        :type square_use_encrypted_endpoints: object
        :param square_use_host_verification: Specifies whether to require the host name in the server's
         certificate to match the host name of the server when connecting over SSL. The default value is
         true.
        :type square_use_host_verification: object
        :param square_use_peer_verification: Specifies whether to verify the identity of the server
         when connecting over SSL. The default value is true.
        :type square_use_peer_verification: object
        :param square_encrypted_credential: The encrypted credential used for authentication.
         Credentials are encrypted using the integration runtime credential manager. Type: string (or
         Expression with resultType string).
        :type square_encrypted_credential: object
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: LinkedServiceResource or the result of cls(response)
        :rtype: ~azure.mgmt.datafactory.models.LinkedServiceResource
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.LinkedServiceResource"]
        error_map = kwargs.pop('error_map', {404: ResourceNotFoundError, 409: ResourceExistsError})

        _linked_service = models.LinkedServiceResource(properties=properties, type=square_type, connect_via=square_connect_via, description=square_description, parameters=square_parameters, annotations=square_annotations, host=square_host, client_id=square_client_id, client_secret=square_client_secret, redirect_uri=square_redirect_uri, use_encrypted_endpoints=square_use_encrypted_endpoints, use_host_verification=square_use_host_verification, use_peer_verification=square_use_peer_verification, encrypted_credential=square_encrypted_credential)
        api_version = "2018-06-01"
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.create_or_update_square.metadata['url']
        path_format_arguments = {
            'subscriptionId': self._serialize.url("self._config.subscription_id", self._config.subscription_id, 'str'),
            'resourceGroupName': self._serialize.url("resource_group_name", resource_group_name, 'str', max_length=90, min_length=1, pattern=r'^[-\w\._\(\)]+$'),
            'factoryName': self._serialize.url("factory_name", factory_name, 'str', max_length=63, min_length=3, pattern=r'^[A-Za-z0-9]+(?:-[A-Za-z0-9]+)*$'),
            'linkedServiceName': self._serialize.url("linked_service_name", linked_service_name, 'str', max_length=260, min_length=1, pattern=r'^[A-Za-z0-9_][^<>*#.%&:\\+?/]*$'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = 'application/json'

        # Construct and send request
        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_linked_service, 'LinkedServiceResource')
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = self._deserialize('LinkedServiceResource', pipeline_response)

        if cls:
          return cls(pipeline_response, deserialized, {})

        return deserialized
    create_or_update_square.metadata = {'url': '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataFactory/factories/{factoryName}/linkedservices/{linkedServiceName}'}

    def create_or_update_sybase(
        self,
        resource_group_name,  # type: str
        factory_name,  # type: str
        linked_service_name,  # type: str
        sybase_type,  # type: str
        sybase_server,  # type: object
        sybase_database,  # type: object
        if_match=None,  # type: Optional[str]
        sybase_connect_via=None,  # type: Optional["models.IntegrationRuntimeReference"]
        sybase_description=None,  # type: Optional[str]
        sybase_parameters=None,  # type: Optional[Dict[str, "ParameterSpecification"]]
        sybase_annotations=None,  # type: Optional[List[object]]
        sybase_schema=None,  # type: Optional[object]
        sybase_authentication_type=None,  # type: Optional[Union[str, "models.SybaseAuthenticationType"]]
        sybase_username=None,  # type: Optional[object]
        sybase_password=None,  # type: Optional["models.SecretBase"]
        sybase_encrypted_credential=None,  # type: Optional[object]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.LinkedServiceResource"
        """Creates or updates a linked service.

        :param resource_group_name: The resource group name.
        :type resource_group_name: str
        :param factory_name: The factory name.
        :type factory_name: str
        :param linked_service_name: The linked service name.
        :type linked_service_name: str
        :param sybase_type: Type of linked service.
        :type sybase_type: str
        :param sybase_server: Server name for connection. Type: string (or Expression with resultType
         string).
        :type sybase_server: object
        :param sybase_database: Database name for connection. Type: string (or Expression with
         resultType string).
        :type sybase_database: object
        :param if_match: ETag of the linkedService entity.  Should only be specified for update, for
         which it should match existing entity or can be * for unconditional update.
        :type if_match: str
        :param sybase_connect_via: The integration runtime reference.
        :type sybase_connect_via: ~azure.mgmt.datafactory.models.IntegrationRuntimeReference
        :param sybase_description: Linked service description.
        :type sybase_description: str
        :param sybase_parameters: Parameters for linked service.
        :type sybase_parameters: dict[str, ~azure.mgmt.datafactory.models.ParameterSpecification]
        :param sybase_annotations: List of tags that can be used for describing the linked service.
        :type sybase_annotations: list[object]
        :param sybase_schema: Schema name for connection. Type: string (or Expression with resultType
         string).
        :type sybase_schema: object
        :param sybase_authentication_type: AuthenticationType to be used for connection.
        :type sybase_authentication_type: str or ~azure.mgmt.datafactory.models.SybaseAuthenticationType
        :param sybase_username: Username for authentication. Type: string (or Expression with
         resultType string).
        :type sybase_username: object
        :param sybase_password: Password for authentication.
        :type sybase_password: ~azure.mgmt.datafactory.models.SecretBase
        :param sybase_encrypted_credential: The encrypted credential used for authentication.
         Credentials are encrypted using the integration runtime credential manager. Type: string (or
         Expression with resultType string).
        :type sybase_encrypted_credential: object
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: LinkedServiceResource or the result of cls(response)
        :rtype: ~azure.mgmt.datafactory.models.LinkedServiceResource
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.LinkedServiceResource"]
        error_map = kwargs.pop('error_map', {404: ResourceNotFoundError, 409: ResourceExistsError})

        _linked_service = models.LinkedServiceResource(properties=properties, type=sybase_type, connect_via=sybase_connect_via, description=sybase_description, parameters=sybase_parameters, annotations=sybase_annotations, server=sybase_server, database=sybase_database, schema=sybase_schema, authentication_type=sybase_authentication_type, username=sybase_username, password=sybase_password, encrypted_credential=sybase_encrypted_credential)
        api_version = "2018-06-01"
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.create_or_update_sybase.metadata['url']
        path_format_arguments = {
            'subscriptionId': self._serialize.url("self._config.subscription_id", self._config.subscription_id, 'str'),
            'resourceGroupName': self._serialize.url("resource_group_name", resource_group_name, 'str', max_length=90, min_length=1, pattern=r'^[-\w\._\(\)]+$'),
            'factoryName': self._serialize.url("factory_name", factory_name, 'str', max_length=63, min_length=3, pattern=r'^[A-Za-z0-9]+(?:-[A-Za-z0-9]+)*$'),
            'linkedServiceName': self._serialize.url("linked_service_name", linked_service_name, 'str', max_length=260, min_length=1, pattern=r'^[A-Za-z0-9_][^<>*#.%&:\\+?/]*$'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = 'application/json'

        # Construct and send request
        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_linked_service, 'LinkedServiceResource')
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = self._deserialize('LinkedServiceResource', pipeline_response)

        if cls:
          return cls(pipeline_response, deserialized, {})

        return deserialized
    create_or_update_sybase.metadata = {'url': '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataFactory/factories/{factoryName}/linkedservices/{linkedServiceName}'}

    def create_or_update_teradata(
        self,
        resource_group_name,  # type: str
        factory_name,  # type: str
        linked_service_name,  # type: str
        teradata_type,  # type: str
        if_match=None,  # type: Optional[str]
        teradata_connect_via=None,  # type: Optional["models.IntegrationRuntimeReference"]
        teradata_description=None,  # type: Optional[str]
        teradata_parameters=None,  # type: Optional[Dict[str, "ParameterSpecification"]]
        teradata_annotations=None,  # type: Optional[List[object]]
        teradata_connection_string=None,  # type: Optional[object]
        teradata_server=None,  # type: Optional[object]
        teradata_authentication_type=None,  # type: Optional[Union[str, "models.TeradataAuthenticationType"]]
        teradata_username=None,  # type: Optional[object]
        teradata_password=None,  # type: Optional["models.SecretBase"]
        teradata_encrypted_credential=None,  # type: Optional[object]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.LinkedServiceResource"
        """Creates or updates a linked service.

        :param resource_group_name: The resource group name.
        :type resource_group_name: str
        :param factory_name: The factory name.
        :type factory_name: str
        :param linked_service_name: The linked service name.
        :type linked_service_name: str
        :param teradata_type: Type of linked service.
        :type teradata_type: str
        :param if_match: ETag of the linkedService entity.  Should only be specified for update, for
         which it should match existing entity or can be * for unconditional update.
        :type if_match: str
        :param teradata_connect_via: The integration runtime reference.
        :type teradata_connect_via: ~azure.mgmt.datafactory.models.IntegrationRuntimeReference
        :param teradata_description: Linked service description.
        :type teradata_description: str
        :param teradata_parameters: Parameters for linked service.
        :type teradata_parameters: dict[str, ~azure.mgmt.datafactory.models.ParameterSpecification]
        :param teradata_annotations: List of tags that can be used for describing the linked service.
        :type teradata_annotations: list[object]
        :param teradata_connection_string: Teradata ODBC connection string. Type: string, SecureString
         or AzureKeyVaultSecretReference.
        :type teradata_connection_string: object
        :param teradata_server: Server name for connection. Type: string (or Expression with resultType
         string).
        :type teradata_server: object
        :param teradata_authentication_type: AuthenticationType to be used for connection.
        :type teradata_authentication_type: str or ~azure.mgmt.datafactory.models.TeradataAuthenticationType
        :param teradata_username: Username for authentication. Type: string (or Expression with
         resultType string).
        :type teradata_username: object
        :param teradata_password: Password for authentication.
        :type teradata_password: ~azure.mgmt.datafactory.models.SecretBase
        :param teradata_encrypted_credential: The encrypted credential used for authentication.
         Credentials are encrypted using the integration runtime credential manager. Type: string (or
         Expression with resultType string).
        :type teradata_encrypted_credential: object
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: LinkedServiceResource or the result of cls(response)
        :rtype: ~azure.mgmt.datafactory.models.LinkedServiceResource
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.LinkedServiceResource"]
        error_map = kwargs.pop('error_map', {404: ResourceNotFoundError, 409: ResourceExistsError})

        _linked_service = models.LinkedServiceResource(properties=properties, type=teradata_type, connect_via=teradata_connect_via, description=teradata_description, parameters=teradata_parameters, annotations=teradata_annotations, connection_string=teradata_connection_string, server=teradata_server, authentication_type=teradata_authentication_type, username=teradata_username, password=teradata_password, encrypted_credential=teradata_encrypted_credential)
        api_version = "2018-06-01"
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.create_or_update_teradata.metadata['url']
        path_format_arguments = {
            'subscriptionId': self._serialize.url("self._config.subscription_id", self._config.subscription_id, 'str'),
            'resourceGroupName': self._serialize.url("resource_group_name", resource_group_name, 'str', max_length=90, min_length=1, pattern=r'^[-\w\._\(\)]+$'),
            'factoryName': self._serialize.url("factory_name", factory_name, 'str', max_length=63, min_length=3, pattern=r'^[A-Za-z0-9]+(?:-[A-Za-z0-9]+)*$'),
            'linkedServiceName': self._serialize.url("linked_service_name", linked_service_name, 'str', max_length=260, min_length=1, pattern=r'^[A-Za-z0-9_][^<>*#.%&:\\+?/]*$'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = 'application/json'

        # Construct and send request
        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_linked_service, 'LinkedServiceResource')
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = self._deserialize('LinkedServiceResource', pipeline_response)

        if cls:
          return cls(pipeline_response, deserialized, {})

        return deserialized
    create_or_update_teradata.metadata = {'url': '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataFactory/factories/{factoryName}/linkedservices/{linkedServiceName}'}

    def create_or_update_vertica(
        self,
        resource_group_name,  # type: str
        factory_name,  # type: str
        linked_service_name,  # type: str
        vertica_type,  # type: str
        if_match=None,  # type: Optional[str]
        vertica_connect_via=None,  # type: Optional["models.IntegrationRuntimeReference"]
        vertica_description=None,  # type: Optional[str]
        vertica_parameters=None,  # type: Optional[Dict[str, "ParameterSpecification"]]
        vertica_annotations=None,  # type: Optional[List[object]]
        vertica_connection_string=None,  # type: Optional[object]
        vertica_pwd=None,  # type: Optional["models.AzureKeyVaultSecretReference"]
        vertica_encrypted_credential=None,  # type: Optional[object]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.LinkedServiceResource"
        """Creates or updates a linked service.

        :param resource_group_name: The resource group name.
        :type resource_group_name: str
        :param factory_name: The factory name.
        :type factory_name: str
        :param linked_service_name: The linked service name.
        :type linked_service_name: str
        :param vertica_type: Type of linked service.
        :type vertica_type: str
        :param if_match: ETag of the linkedService entity.  Should only be specified for update, for
         which it should match existing entity or can be * for unconditional update.
        :type if_match: str
        :param vertica_connect_via: The integration runtime reference.
        :type vertica_connect_via: ~azure.mgmt.datafactory.models.IntegrationRuntimeReference
        :param vertica_description: Linked service description.
        :type vertica_description: str
        :param vertica_parameters: Parameters for linked service.
        :type vertica_parameters: dict[str, ~azure.mgmt.datafactory.models.ParameterSpecification]
        :param vertica_annotations: List of tags that can be used for describing the linked service.
        :type vertica_annotations: list[object]
        :param vertica_connection_string: An ODBC connection string. Type: string, SecureString or
         AzureKeyVaultSecretReference.
        :type vertica_connection_string: object
        :param vertica_pwd: The Azure key vault secret reference of password in connection string.
        :type vertica_pwd: ~azure.mgmt.datafactory.models.AzureKeyVaultSecretReference
        :param vertica_encrypted_credential: The encrypted credential used for authentication.
         Credentials are encrypted using the integration runtime credential manager. Type: string (or
         Expression with resultType string).
        :type vertica_encrypted_credential: object
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: LinkedServiceResource or the result of cls(response)
        :rtype: ~azure.mgmt.datafactory.models.LinkedServiceResource
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.LinkedServiceResource"]
        error_map = kwargs.pop('error_map', {404: ResourceNotFoundError, 409: ResourceExistsError})

        _linked_service = models.LinkedServiceResource(properties=properties, type=vertica_type, connect_via=vertica_connect_via, description=vertica_description, parameters=vertica_parameters, annotations=vertica_annotations, connection_string=vertica_connection_string, pwd=vertica_pwd, encrypted_credential=vertica_encrypted_credential)
        api_version = "2018-06-01"
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.create_or_update_vertica.metadata['url']
        path_format_arguments = {
            'subscriptionId': self._serialize.url("self._config.subscription_id", self._config.subscription_id, 'str'),
            'resourceGroupName': self._serialize.url("resource_group_name", resource_group_name, 'str', max_length=90, min_length=1, pattern=r'^[-\w\._\(\)]+$'),
            'factoryName': self._serialize.url("factory_name", factory_name, 'str', max_length=63, min_length=3, pattern=r'^[A-Za-z0-9]+(?:-[A-Za-z0-9]+)*$'),
            'linkedServiceName': self._serialize.url("linked_service_name", linked_service_name, 'str', max_length=260, min_length=1, pattern=r'^[A-Za-z0-9_][^<>*#.%&:\\+?/]*$'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = 'application/json'

        # Construct and send request
        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_linked_service, 'LinkedServiceResource')
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = self._deserialize('LinkedServiceResource', pipeline_response)

        if cls:
          return cls(pipeline_response, deserialized, {})

        return deserialized
    create_or_update_vertica.metadata = {'url': '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataFactory/factories/{factoryName}/linkedservices/{linkedServiceName}'}

    def create_or_update_web(
        self,
        resource_group_name,  # type: str
        factory_name,  # type: str
        linked_service_name,  # type: str
        web_type,  # type: str
        web_type_properties,  # type: "models.WebLinkedServiceTypeProperties"
        if_match=None,  # type: Optional[str]
        web_connect_via=None,  # type: Optional["models.IntegrationRuntimeReference"]
        web_description=None,  # type: Optional[str]
        web_parameters=None,  # type: Optional[Dict[str, "ParameterSpecification"]]
        web_annotations=None,  # type: Optional[List[object]]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.LinkedServiceResource"
        """Creates or updates a linked service.

        :param resource_group_name: The resource group name.
        :type resource_group_name: str
        :param factory_name: The factory name.
        :type factory_name: str
        :param linked_service_name: The linked service name.
        :type linked_service_name: str
        :param web_type: Type of linked service.
        :type web_type: str
        :param web_type_properties: Web linked service properties.
        :type web_type_properties: ~azure.mgmt.datafactory.models.WebLinkedServiceTypeProperties
        :param if_match: ETag of the linkedService entity.  Should only be specified for update, for
         which it should match existing entity or can be * for unconditional update.
        :type if_match: str
        :param web_connect_via: The integration runtime reference.
        :type web_connect_via: ~azure.mgmt.datafactory.models.IntegrationRuntimeReference
        :param web_description: Linked service description.
        :type web_description: str
        :param web_parameters: Parameters for linked service.
        :type web_parameters: dict[str, ~azure.mgmt.datafactory.models.ParameterSpecification]
        :param web_annotations: List of tags that can be used for describing the linked service.
        :type web_annotations: list[object]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: LinkedServiceResource or the result of cls(response)
        :rtype: ~azure.mgmt.datafactory.models.LinkedServiceResource
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.LinkedServiceResource"]
        error_map = kwargs.pop('error_map', {404: ResourceNotFoundError, 409: ResourceExistsError})

        _linked_service = models.LinkedServiceResource(properties=properties, type=web_type, connect_via=web_connect_via, description=web_description, parameters=web_parameters, annotations=web_annotations, type_properties=web_type_properties)
        api_version = "2018-06-01"
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.create_or_update_web.metadata['url']
        path_format_arguments = {
            'subscriptionId': self._serialize.url("self._config.subscription_id", self._config.subscription_id, 'str'),
            'resourceGroupName': self._serialize.url("resource_group_name", resource_group_name, 'str', max_length=90, min_length=1, pattern=r'^[-\w\._\(\)]+$'),
            'factoryName': self._serialize.url("factory_name", factory_name, 'str', max_length=63, min_length=3, pattern=r'^[A-Za-z0-9]+(?:-[A-Za-z0-9]+)*$'),
            'linkedServiceName': self._serialize.url("linked_service_name", linked_service_name, 'str', max_length=260, min_length=1, pattern=r'^[A-Za-z0-9_][^<>*#.%&:\\+?/]*$'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = 'application/json'

        # Construct and send request
        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_linked_service, 'LinkedServiceResource')
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = self._deserialize('LinkedServiceResource', pipeline_response)

        if cls:
          return cls(pipeline_response, deserialized, {})

        return deserialized
    create_or_update_web.metadata = {'url': '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataFactory/factories/{factoryName}/linkedservices/{linkedServiceName}'}

    def create_or_update_xero(
        self,
        resource_group_name,  # type: str
        factory_name,  # type: str
        linked_service_name,  # type: str
        xero_type,  # type: str
        xero_host,  # type: object
        if_match=None,  # type: Optional[str]
        xero_connect_via=None,  # type: Optional["models.IntegrationRuntimeReference"]
        xero_description=None,  # type: Optional[str]
        xero_parameters=None,  # type: Optional[Dict[str, "ParameterSpecification"]]
        xero_annotations=None,  # type: Optional[List[object]]
        xero_consumer_key=None,  # type: Optional["models.SecretBase"]
        xero_private_key=None,  # type: Optional["models.SecretBase"]
        xero_use_encrypted_endpoints=None,  # type: Optional[object]
        xero_use_host_verification=None,  # type: Optional[object]
        xero_use_peer_verification=None,  # type: Optional[object]
        xero_encrypted_credential=None,  # type: Optional[object]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.LinkedServiceResource"
        """Creates or updates a linked service.

        :param resource_group_name: The resource group name.
        :type resource_group_name: str
        :param factory_name: The factory name.
        :type factory_name: str
        :param linked_service_name: The linked service name.
        :type linked_service_name: str
        :param xero_type: Type of linked service.
        :type xero_type: str
        :param xero_host: The endpoint of the Xero server. (i.e. api.xero.com).
        :type xero_host: object
        :param if_match: ETag of the linkedService entity.  Should only be specified for update, for
         which it should match existing entity or can be * for unconditional update.
        :type if_match: str
        :param xero_connect_via: The integration runtime reference.
        :type xero_connect_via: ~azure.mgmt.datafactory.models.IntegrationRuntimeReference
        :param xero_description: Linked service description.
        :type xero_description: str
        :param xero_parameters: Parameters for linked service.
        :type xero_parameters: dict[str, ~azure.mgmt.datafactory.models.ParameterSpecification]
        :param xero_annotations: List of tags that can be used for describing the linked service.
        :type xero_annotations: list[object]
        :param xero_consumer_key: The consumer key associated with the Xero application.
        :type xero_consumer_key: ~azure.mgmt.datafactory.models.SecretBase
        :param xero_private_key: The private key from the .pem file that was generated for your Xero
         private application. You must include all the text from the .pem file, including the Unix line
         endings(
         ).
        :type xero_private_key: ~azure.mgmt.datafactory.models.SecretBase
        :param xero_use_encrypted_endpoints: Specifies whether the data source endpoints are encrypted
         using HTTPS. The default value is true.
        :type xero_use_encrypted_endpoints: object
        :param xero_use_host_verification: Specifies whether to require the host name in the server's
         certificate to match the host name of the server when connecting over SSL. The default value is
         true.
        :type xero_use_host_verification: object
        :param xero_use_peer_verification: Specifies whether to verify the identity of the server when
         connecting over SSL. The default value is true.
        :type xero_use_peer_verification: object
        :param xero_encrypted_credential: The encrypted credential used for authentication. Credentials
         are encrypted using the integration runtime credential manager. Type: string (or Expression
         with resultType string).
        :type xero_encrypted_credential: object
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: LinkedServiceResource or the result of cls(response)
        :rtype: ~azure.mgmt.datafactory.models.LinkedServiceResource
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.LinkedServiceResource"]
        error_map = kwargs.pop('error_map', {404: ResourceNotFoundError, 409: ResourceExistsError})

        _linked_service = models.LinkedServiceResource(properties=properties, type=xero_type, connect_via=xero_connect_via, description=xero_description, parameters=xero_parameters, annotations=xero_annotations, host=xero_host, consumer_key=xero_consumer_key, private_key=xero_private_key, use_encrypted_endpoints=xero_use_encrypted_endpoints, use_host_verification=xero_use_host_verification, use_peer_verification=xero_use_peer_verification, encrypted_credential=xero_encrypted_credential)
        api_version = "2018-06-01"
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.create_or_update_xero.metadata['url']
        path_format_arguments = {
            'subscriptionId': self._serialize.url("self._config.subscription_id", self._config.subscription_id, 'str'),
            'resourceGroupName': self._serialize.url("resource_group_name", resource_group_name, 'str', max_length=90, min_length=1, pattern=r'^[-\w\._\(\)]+$'),
            'factoryName': self._serialize.url("factory_name", factory_name, 'str', max_length=63, min_length=3, pattern=r'^[A-Za-z0-9]+(?:-[A-Za-z0-9]+)*$'),
            'linkedServiceName': self._serialize.url("linked_service_name", linked_service_name, 'str', max_length=260, min_length=1, pattern=r'^[A-Za-z0-9_][^<>*#.%&:\\+?/]*$'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = 'application/json'

        # Construct and send request
        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_linked_service, 'LinkedServiceResource')
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = self._deserialize('LinkedServiceResource', pipeline_response)

        if cls:
          return cls(pipeline_response, deserialized, {})

        return deserialized
    create_or_update_xero.metadata = {'url': '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataFactory/factories/{factoryName}/linkedservices/{linkedServiceName}'}

    def create_or_update_zoho(
        self,
        resource_group_name,  # type: str
        factory_name,  # type: str
        linked_service_name,  # type: str
        zoho_type,  # type: str
        zoho_endpoint,  # type: object
        if_match=None,  # type: Optional[str]
        zoho_connect_via=None,  # type: Optional["models.IntegrationRuntimeReference"]
        zoho_description=None,  # type: Optional[str]
        zoho_parameters=None,  # type: Optional[Dict[str, "ParameterSpecification"]]
        zoho_annotations=None,  # type: Optional[List[object]]
        zoho_access_token=None,  # type: Optional["models.SecretBase"]
        zoho_use_encrypted_endpoints=None,  # type: Optional[object]
        zoho_use_host_verification=None,  # type: Optional[object]
        zoho_use_peer_verification=None,  # type: Optional[object]
        zoho_encrypted_credential=None,  # type: Optional[object]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.LinkedServiceResource"
        """Creates or updates a linked service.

        :param resource_group_name: The resource group name.
        :type resource_group_name: str
        :param factory_name: The factory name.
        :type factory_name: str
        :param linked_service_name: The linked service name.
        :type linked_service_name: str
        :param zoho_type: Type of linked service.
        :type zoho_type: str
        :param zoho_endpoint: The endpoint of the Zoho server. (i.e. crm.zoho.com/crm/private).
        :type zoho_endpoint: object
        :param if_match: ETag of the linkedService entity.  Should only be specified for update, for
         which it should match existing entity or can be * for unconditional update.
        :type if_match: str
        :param zoho_connect_via: The integration runtime reference.
        :type zoho_connect_via: ~azure.mgmt.datafactory.models.IntegrationRuntimeReference
        :param zoho_description: Linked service description.
        :type zoho_description: str
        :param zoho_parameters: Parameters for linked service.
        :type zoho_parameters: dict[str, ~azure.mgmt.datafactory.models.ParameterSpecification]
        :param zoho_annotations: List of tags that can be used for describing the linked service.
        :type zoho_annotations: list[object]
        :param zoho_access_token: The access token for Zoho authentication.
        :type zoho_access_token: ~azure.mgmt.datafactory.models.SecretBase
        :param zoho_use_encrypted_endpoints: Specifies whether the data source endpoints are encrypted
         using HTTPS. The default value is true.
        :type zoho_use_encrypted_endpoints: object
        :param zoho_use_host_verification: Specifies whether to require the host name in the server's
         certificate to match the host name of the server when connecting over SSL. The default value is
         true.
        :type zoho_use_host_verification: object
        :param zoho_use_peer_verification: Specifies whether to verify the identity of the server when
         connecting over SSL. The default value is true.
        :type zoho_use_peer_verification: object
        :param zoho_encrypted_credential: The encrypted credential used for authentication. Credentials
         are encrypted using the integration runtime credential manager. Type: string (or Expression
         with resultType string).
        :type zoho_encrypted_credential: object
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: LinkedServiceResource or the result of cls(response)
        :rtype: ~azure.mgmt.datafactory.models.LinkedServiceResource
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.LinkedServiceResource"]
        error_map = kwargs.pop('error_map', {404: ResourceNotFoundError, 409: ResourceExistsError})

        _linked_service = models.LinkedServiceResource(properties=properties, type=zoho_type, connect_via=zoho_connect_via, description=zoho_description, parameters=zoho_parameters, annotations=zoho_annotations, endpoint=zoho_endpoint, access_token=zoho_access_token, use_encrypted_endpoints=zoho_use_encrypted_endpoints, use_host_verification=zoho_use_host_verification, use_peer_verification=zoho_use_peer_verification, encrypted_credential=zoho_encrypted_credential)
        api_version = "2018-06-01"
        content_type = kwargs.pop("content_type", "application/json")

        # Construct URL
        url = self.create_or_update_zoho.metadata['url']
        path_format_arguments = {
            'subscriptionId': self._serialize.url("self._config.subscription_id", self._config.subscription_id, 'str'),
            'resourceGroupName': self._serialize.url("resource_group_name", resource_group_name, 'str', max_length=90, min_length=1, pattern=r'^[-\w\._\(\)]+$'),
            'factoryName': self._serialize.url("factory_name", factory_name, 'str', max_length=63, min_length=3, pattern=r'^[A-Za-z0-9]+(?:-[A-Za-z0-9]+)*$'),
            'linkedServiceName': self._serialize.url("linked_service_name", linked_service_name, 'str', max_length=260, min_length=1, pattern=r'^[A-Za-z0-9_][^<>*#.%&:\\+?/]*$'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = 'application/json'

        # Construct and send request
        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_linked_service, 'LinkedServiceResource')
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        deserialized = self._deserialize('LinkedServiceResource', pipeline_response)

        if cls:
          return cls(pipeline_response, deserialized, {})

        return deserialized
    create_or_update_zoho.metadata = {'url': '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataFactory/factories/{factoryName}/linkedservices/{linkedServiceName}'}
